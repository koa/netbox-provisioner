# This file was generated. Do not edit manually.

schema {
    query: Query
}

union CableTerminationTerminationType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | RearPortType

union CircuitGroupAssignmentMemberType = CircuitType | VirtualCircuitType

union CircuitTerminationTerminationType = LocationType | ProviderNetworkType | RegionType | SiteGroupType | SiteType

union ClusterScopeType = LocationType | RegionType | SiteGroupType | SiteType

union ConnectedEndpointType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | ProviderNetworkType | RearPortType | VirtualCircuitTerminationType

union FHRPGroupInterfaceType = InterfaceType | VMInterfaceType

union IPAddressAssignmentType = FHRPGroupType | InterfaceType | VMInterfaceType

union InventoryItemComponentType = ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerOutletType | PowerPortType | RearPortType

union InventoryItemTemplateComponentType = ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerOutletType | PowerPortType | RearPortType

union L2VPNAssignmentType = InterfaceType | VLANType | VMInterfaceType

union LinkPeerType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | RearPortType

union MACAddressAssignmentType = InterfaceType | VMInterfaceType

union PrefixScopeType = LocationType | RegionType | SiteGroupType | SiteType

union ServiceParentType = DeviceType | FHRPGroupType | VirtualMachineType

union VLANGroupScopeType = ClusterGroupType | ClusterType | LocationType | RackType | RegionType | SiteGroupType | SiteType

union WirelessLANScopeType = LocationType | RegionType | SiteGroupType | SiteType

"ASNRange(id, created, last_updated, custom_field_data, description, name, slug, rir, start, end, tenant)"
type ASNRangeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    end: Union!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    rir: RIRType
    slug: String!
    start: Union!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"""

An autonomous system (AS) number is typically used to represent an independent routing domain. A site can have
one or more ASNs assigned to it.
"""
type ASNType {
    asn: Union!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    providers(filters: ProviderFilter, pagination: OffsetPaginationInput): [ProviderType!]!
    rir: RIRType
    sites(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"""

An aggregate exists at the root level of the IP address space hierarchy in NetBox. Aggregates are used to organize
the hierarchy and track the overall utilization of available address space. Each Aggregate is assigned to a RIR.
"""
type AggregateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    date_added: Date
    description: String!
    display: String!
    family: IPAddressFamilyType!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    prefix: String!
    rir: RIRType
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"A mapping between side A or B of a Cable and a terminating object (e.g. an Interface or CircuitTermination)."
type CableTerminationType {
    cable: CableType
    cable_end: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_fields: JSON!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    termination: CableTerminationTerminationType
}

"A physical connection between two endpoints."
type CableType {
    _abs_length: Decimal
    a_terminations: [CableTerminationTerminationType!]!
    b_terminations: [CableTerminationTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    label: String!
    last_updated: DateTime
    length: Decimal
    length_unit: String
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    terminations(filters: CableTerminationFilter, pagination: OffsetPaginationInput): [CableTerminationType!]!
    type: String
}

"Assignment of a physical or virtual circuit to a CircuitGroup with an optional priority."
type CircuitGroupAssignmentType {
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    display: String!
    group: CircuitGroupType!
    id: ID!
    last_updated: DateTime
    member: CircuitGroupAssignmentMemberType
    priority: String
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"An administrative grouping of Circuits."
type CircuitGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"CircuitTermination(id, created, last_updated, custom_field_data, cable, cable_end, mark_connected, circuit, term_side, termination_type, termination_id, port_speed, upstream_speed, xconnect_id, pp_info, description, _provider_network, _location, _site, _region, _site_group)"
type CircuitTerminationType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    circuit: CircuitType!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    port_speed: Int
    pp_info: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    term_side: String!
    termination: CircuitTerminationTerminationType
    upstream_speed: Int
    xconnect_id: String!
}

"""

A communications circuit connects two points. Each Circuit belongs to a Provider; Providers may have multiple
circuits. Each circuit is also assigned a CircuitType and a Site, and may optionally be assigned to a particular
ProviderAccount. Circuit port speed and commit rate are measured in Kbps.
"""
type CircuitType {
    _abs_distance: Decimal
    changelog: [ObjectChangeType!]!
    cid: String!
    class_type: String!
    comments: String!
    commit_rate: Int
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    distance: Decimal
    distance_unit: String
    id: ID!
    install_date: Date
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    provider: ProviderType!
    provider_account: ProviderAccountType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    termination_a: CircuitTerminationType
    termination_date: Date
    termination_z: CircuitTerminationType
    terminations(filters: CircuitTerminationFilter, pagination: OffsetPaginationInput): [CircuitTerminationType!]!
    type: CircuitTypeType!
}

"""

Circuits can be organized by their functional role. For example, a user might wish to define CircuitTypes named
"Long Haul," "Metro," or "Out-of-Band".
"""
type CircuitTypeType {
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter, pagination: OffsetPaginationInput): [CircuitType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"An organizational group of Clusters."
type ClusterGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    clusters(filters: ClusterFilter, pagination: OffsetPaginationInput): [ClusterType!]!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
}

"A cluster of VirtualMachines. Each Cluster may optionally be associated with one or more Devices."
type ClusterType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    group: ClusterGroupType
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    scope: ClusterScopeType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    type: ClusterTypeType
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
}

"A type of Cluster."
type ClusterTypeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    clusters(filters: ClusterFilter, pagination: OffsetPaginationInput): [ClusterType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned
qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B
will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.
"""
type ConfigContextType {
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster_groups(filters: ClusterGroupFilter, pagination: OffsetPaginationInput): [ClusterGroupType!]!
    cluster_types(filters: ClusterTypeFilter, pagination: OffsetPaginationInput): [ClusterTypeType!]!
    clusters(filters: ClusterFilter, pagination: OffsetPaginationInput): [ClusterType!]!
    created: DateTime
    data: JSON!
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    device_types(filters: DeviceTypeFilter, pagination: OffsetPaginationInput): [DeviceTypeType!]!
    display: String!
    id: ID!
    is_active: Boolean!
    last_updated: DateTime
    locations(filters: LocationFilter, pagination: OffsetPaginationInput): [LocationType!]!
    name: String!
    platforms(filters: PlatformFilter, pagination: OffsetPaginationInput): [PlatformType!]!
    regions(filters: RegionFilter, pagination: OffsetPaginationInput): [RegionType!]!
    roles(filters: DeviceRoleFilter, pagination: OffsetPaginationInput): [DeviceRoleType!]!
    site_groups(filters: SiteGroupFilter, pagination: OffsetPaginationInput): [SiteGroupType!]!
    sites(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant_groups(filters: TenantGroupFilter, pagination: OffsetPaginationInput): [TenantGroupType!]!
    tenants(filters: TenantFilter, pagination: OffsetPaginationInput): [TenantType!]!
    weight: Int!
}

"ConfigTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, template_code, environment_params, mime_type, file_name, file_extension, as_attachment, name, description)"
type ConfigTemplateType {
    as_attachment: Boolean!
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    device_roles(filters: DeviceRoleFilter, pagination: OffsetPaginationInput): [DeviceRoleType!]!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    environment_params: JSON
    file_extension: String!
    file_name: String!
    id: ID!
    last_updated: DateTime
    mime_type: String!
    name: String!
    platforms(filters: PlatformFilter, pagination: OffsetPaginationInput): [PlatformType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    template_code: String!
    virtualmachines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
}

"A template for a ConsolePort to be created for a new Device."
type ConsolePortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    type: String
}

"A physical console port within a Device. ConsolePorts connect to ConsoleServerPorts."
type ConsolePortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    speed: Int
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String
}

"A template for a ConsoleServerPort to be created for a new Device."
type ConsoleServerPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    type: String
}

"A physical port within a Device (typically a designated console server) which provides access to ConsolePorts."
type ConsoleServerPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    speed: Int
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String
}

"ContactAssignment(id, created, last_updated, custom_field_data, object_type, object_id, contact, role, priority)"
type ContactAssignmentType {
    class_type: String!
    contact: ContactType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    last_updated: DateTime
    object_id: Int!
    object_type: ContentTypeType
    priority: String
    role: ContactRoleType
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"An arbitrary collection of Contacts."
type ContactGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: ContactGroupFilter, pagination: OffsetPaginationInput): [ContactGroupType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactFilter, pagination: OffsetPaginationInput): [ContactType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: ContactGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
}

"Functional role for a Contact assigned to an object."
type ContactRoleType {
    assignments(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"Contact information for a particular object(s) in NetBox."
type ContactType {
    address: String!
    assignments(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    email: String!
    groups(filters: ContactGroupFilter, pagination: OffsetPaginationInput): [ContactGroupType!]!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    link: String!
    name: String!
    phone: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    title: String!
}

"ContentType(id, app_label, model)"
type ContentTypeType {
    app_label: String!
    id: ID!
    model: String!
}

"Represents a set of choices available for choice and multi-choice custom fields."
type CustomFieldChoiceSetType {
    base_choices: String
    changelog: [ObjectChangeType!]!
    choices_for(filters: CustomFieldFilter, pagination: OffsetPaginationInput): [CustomFieldType!]!
    class_type: String!
    created: DateTime
    description: String!
    display: String!
    extra_choices: [[String!]!]
    id: ID!
    last_updated: DateTime
    name: String!
    order_alphabetically: Boolean!
}

"CustomField(id, created, last_updated, type, related_object_type, name, label, group_name, description, required, unique, search_weight, filter_logic, default, related_object_filter, weight, validation_minimum, validation_maximum, validation_regex, choice_set, ui_visible, ui_editable, is_cloneable, comments)"
type CustomFieldType {
    changelog: [ObjectChangeType!]!
    choice_set: CustomFieldChoiceSetType
    class_type: String!
    comments: String!
    created: DateTime
    default: JSON
    description: String!
    display: String!
    filter_logic: String!
    group_name: String!
    id: ID!
    is_cloneable: Boolean!
    label: String!
    last_updated: DateTime
    name: String!
    related_object_filter: JSON
    related_object_type: ContentTypeType
    required: Boolean!
    search_weight: Int!
    type: String!
    ui_editable: String!
    ui_visible: String!
    unique: Boolean!
    validation_maximum: Int
    validation_minimum: Int
    validation_regex: String!
    weight: Int!
}

"""

A custom link to an external representation of a NetBox object. The link text and URL fields accept Jinja2 template
code to be rendered with an object as context.
"""
type CustomLinkType {
    button_class: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    display: String!
    enabled: Boolean!
    group_name: String!
    id: ID!
    last_updated: DateTime
    link_text: String!
    link_url: String!
    name: String!
    new_window: Boolean!
    weight: Int!
}

"""

The database representation of a remote file fetched from a remote DataSource. DataFile instances should be created,
updated, or deleted only by calling DataSource.sync().
"""
type DataFileType {
    class_type: String!
    created: DateTime!
    display: String!
    hash: String!
    id: ID!
    last_updated: DateTime!
    path: String!
    size: Int!
    source: DataSourceType!
}

"A remote source, such as a git repository, from which DataFiles are synchronized."
type DataSourceType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    datafiles(filters: DataFileFilter, pagination: OffsetPaginationInput): [DataFileType!]!
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    ignore_rules: String!
    journal_entries: [JournalEntryType!]!
    last_synced: DateTime
    last_updated: DateTime
    name: String!
    parameters: JSON
    source_url: String!
    status: String!
    sync_interval: Int
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String!
}

"A template for a DeviceBay to be created for a new parent Device."
type DeviceBayTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    name: String!
}

"An empty space within a Device which can house a child device"
type DeviceBayType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    installed_device: DeviceType
    label: String!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

Devices are organized by functional role; for example, "Core Switch" or "File Server". Each DeviceRole is assigned a
color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to
virtual machines as well.
"""
type DeviceRoleType {
    changelog: [ObjectChangeType!]!
    children(filters: DeviceRoleFilter, pagination: OffsetPaginationInput): [DeviceRoleType!]!
    class_type: String!
    color: String!
    comments: String!
    config_template: ConfigTemplateType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: DeviceRoleType
    rght: Int!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
    vm_role: Boolean!
}

"""

A Device represents a piece of physical hardware mounted within a Rack. Each Device is assigned a DeviceType,
DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.

Each Device must be assigned to a site, and optionally to a rack within that site. Associating a device with a
particular rack face or unit is optional (for example, vertically mounted PDUs do not consume rack units).

When a new Device is created, console/power/interface/device bay components are created along with it as dictated
by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the
creation of a Device.
"""
type DeviceType {
    airflow: String
    asset_tag: String
    cabletermination_set(filters: CableTerminationFilter, pagination: OffsetPaginationInput): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster: ClusterType
    comments: String!
    config_context: JSON!
    config_template: ConfigTemplateType
    console_port_count: Union!
    console_server_port_count: Union!
    consoleports(filters: ConsolePortFilter, pagination: OffsetPaginationInput): [ConsolePortType!]!
    consoleserverports(filters: ConsoleServerPortFilter, pagination: OffsetPaginationInput): [ConsoleServerPortType!]!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device_bay_count: Union!
    device_type: DeviceTypeType!
    devicebays(filters: DeviceBayFilter, pagination: OffsetPaginationInput): [DeviceBayType!]!
    display: String!
    face: String
    front_port_count: Union!
    frontports(filters: FrontPortFilter, pagination: OffsetPaginationInput): [FrontPortType!]!
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    interface_count: Union!
    interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    inventory_item_count: Union!
    inventoryitems(filters: InventoryItemFilter, pagination: OffsetPaginationInput): [InventoryItemType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    latitude: Decimal
    local_context_data: JSON
    location: LocationType
    longitude: Decimal
    module_bay_count: Union!
    modulebays(filters: ModuleBayFilter, pagination: OffsetPaginationInput): [ModuleBayType!]!
    modules(filters: ModuleFilter, pagination: OffsetPaginationInput): [ModuleType!]!
    name: String
    oob_ip: IPAddressType
    parent_bay: DeviceBayType
    platform: PlatformType
    position: Decimal
    power_outlet_count: Union!
    power_port_count: Union!
    poweroutlets(filters: PowerOutletFilter, pagination: OffsetPaginationInput): [PowerOutletType!]!
    powerports(filters: PowerPortFilter, pagination: OffsetPaginationInput): [PowerPortType!]!
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    rack: RackType
    rear_port_count: Union!
    rearports(filters: RearPortFilter, pagination: OffsetPaginationInput): [RearPortType!]!
    role: DeviceRoleType!
    serial: String!
    services(filters: ServiceFilter, pagination: OffsetPaginationInput): [ServiceType!]!
    site: SiteType!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vc_master_for: VirtualChassisType
    vc_position: Int
    vc_priority: Int
    vdcs(filters: VirtualDeviceContextFilter, pagination: OffsetPaginationInput): [VirtualDeviceContextType!]!
    virtual_chassis: VirtualChassisType
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
}

"""

A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as
well as high-level functional role(s).

Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and
interface objects. For example, a Juniper EX4300-48T DeviceType would have:

* 1 ConsolePortTemplate
* 2 PowerPortTemplates
* 48 InterfaceTemplates

When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the
DeviceType) are automatically created as well.
"""
type DeviceTypeType {
    _abs_weight: Int
    airflow: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    console_port_template_count: Union!
    console_server_port_template_count: Union!
    consoleporttemplates(filters: ConsolePortTemplateFilter, pagination: OffsetPaginationInput): [ConsolePortTemplateType!]!
    consoleserverporttemplates(filters: ConsoleServerPortTemplateFilter, pagination: OffsetPaginationInput): [ConsoleServerPortTemplateType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    default_platform: PlatformType
    description: String!
    device_bay_template_count: Union!
    devicebaytemplates(filters: DeviceBayTemplateFilter, pagination: OffsetPaginationInput): [DeviceBayTemplateType!]!
    display: String!
    exclude_from_utilization: Boolean!
    front_image: DjangoImageType
    front_port_template_count: Union!
    frontporttemplates(filters: FrontPortTemplateFilter, pagination: OffsetPaginationInput): [FrontPortTemplateType!]!
    id: ID!
    instances(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    interface_template_count: Union!
    interfacetemplates(filters: InterfaceTemplateFilter, pagination: OffsetPaginationInput): [InterfaceTemplateType!]!
    inventory_item_template_count: Union!
    inventoryitemtemplates(filters: InventoryItemTemplateFilter, pagination: OffsetPaginationInput): [InventoryItemTemplateType!]!
    is_full_depth: Boolean!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    model: String!
    module_bay_template_count: Union!
    modulebaytemplates(filters: ModuleBayTemplateFilter, pagination: OffsetPaginationInput): [ModuleBayTemplateType!]!
    part_number: String!
    power_outlet_template_count: Union!
    power_port_template_count: Union!
    poweroutlettemplates(filters: PowerOutletTemplateFilter, pagination: OffsetPaginationInput): [PowerOutletTemplateType!]!
    powerporttemplates(filters: PowerPortTemplateFilter, pagination: OffsetPaginationInput): [PowerPortTemplateType!]!
    rear_image: DjangoImageType
    rear_port_template_count: Union!
    rearporttemplates(filters: RearPortTemplateFilter, pagination: OffsetPaginationInput): [RearPortTemplateType!]!
    slug: String!
    subdevice_role: String
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    u_height: Decimal!
    weight: Decimal
    weight_unit: String
}

type DjangoImageType {
    height: Int!
    name: String!
    path: String!
    size: Int!
    url: String!
    width: Int!
}

type DjangoModelType {
    pk: ID!
}

"""

An EventRule defines an action to be taken automatically in response to a specific set of events, such as when a
specific type of object is created, modified, or deleted. The action to be taken might entail transmitting a
webhook or executing a custom script.
"""
type EventRuleType {
    action_data: JSON
    action_object_id: Int
    action_object_type: ContentTypeType
    action_type: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    conditions: JSON
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enabled: Boolean!
    event_types: [String!]!
    id: ID!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"ExportTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, template_code, environment_params, mime_type, file_name, file_extension, as_attachment, name, description)"
type ExportTemplateType {
    as_attachment: Boolean!
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    display: String!
    environment_params: JSON
    file_extension: String!
    file_name: String!
    id: ID!
    last_updated: DateTime
    mime_type: String!
    name: String!
    template_code: String!
}

"FHRPGroupAssignment(id, created, last_updated, interface_type, interface_id, group, priority)"
type FHRPGroupAssignmentType {
    class_type: String!
    created: DateTime
    display: String!
    group: FHRPGroupType!
    id: ID!
    interface: FHRPGroupInterfaceType!
    last_updated: DateTime
    priority: Int!
}

"A grouping of next hope resolution protocol (FHRP) peers. (For instance, VRRP or HSRP.)"
type FHRPGroupType {
    auth_key: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    fhrpgroupassignment_set(filters: FHRPGroupAssignmentFilter, pagination: OffsetPaginationInput): [FHRPGroupAssignmentType!]!
    group_id: Int!
    id: ID!
    ip_addresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    protocol: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"Template for a pass-through port on the front of a new Device."
type FrontPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    rear_port: RearPortTemplateType!
    rear_port_position: Int!
    type: String!
}

"A pass-through port on the front of a Device."
type FrontPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    rear_port: RearPortType!
    rear_port_position: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String!
}

"Group(id, name, description)"
type GroupType {
    class_type: String!
    display: String!
    id: ID!
    name: String!
}

"IKEPolicy(id, created, last_updated, custom_field_data, description, comments, name, version, mode, preshared_key)"
type IKEPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ipsec_profiles(filters: IPSecProfileFilter, pagination: OffsetPaginationInput): [IPSecProfileType!]!
    last_updated: DateTime
    mode: String
    name: String!
    preshared_key: String!
    proposals(filters: IKEProposalFilter, pagination: OffsetPaginationInput): [IKEProposalType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    version: Int!
}

"IKEProposal(id, created, last_updated, custom_field_data, description, comments, name, authentication_method, encryption_algorithm, authentication_algorithm, group, sa_lifetime)"
type IKEProposalType {
    authentication_algorithm: String
    authentication_method: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encryption_algorithm: String!
    group: Int!
    id: ID!
    ike_policies(filters: IKEPolicyFilter, pagination: OffsetPaginationInput): [IKEPolicyType!]!
    last_updated: DateTime
    name: String!
    sa_lifetime: Int
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

type IPAddressFamilyType {
    label: String!
    value: Int!
}

"""

An IPAddress represents an individual IPv4 or IPv6 address and its mask. The mask length should match what is
configured in the real world. (Typically, only loopback interfaces are configured with /32 or /128 masks.) Like
Prefixes, IPAddresses can optionally be assigned to a VRF. An IPAddress can optionally be assigned to an Interface.
Interfaces can have zero or more IPAddresses assigned to them.

An IPAddress can also optionally point to a NAT inside IP, designating itself as a NAT outside IP. This is useful,
for example, when mapping public addresses to private addresses. When an Interface has been assigned an IPAddress
which has a NAT outside IP, that Interface's Device can use either the inside or outside IP as its primary IP.
"""
type IPAddressType {
    address: String!
    assigned_object: IPAddressAssignmentType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    dns_name: String!
    family: IPAddressFamilyType!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    nat_inside: IPAddressType
    nat_outside(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    role: String
    services(filters: ServiceFilter, pagination: OffsetPaginationInput): [ServiceType!]!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    tunnel_terminations(filters: TunnelTerminationFilter, pagination: OffsetPaginationInput): [TunnelTerminationType!]!
    vrf: VRFType
}

"A range of IP addresses, defined by start and end addresses."
type IPRangeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    end_address: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mark_populated: Boolean!
    mark_utilized: Boolean!
    role: RoleType
    size: Int!
    start_address: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vrf: VRFType
}

"IPSecPolicy(id, created, last_updated, custom_field_data, description, comments, name, pfs_group)"
type IPSecPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ipsec_profiles(filters: IPSecProfileFilter, pagination: OffsetPaginationInput): [IPSecProfileType!]!
    last_updated: DateTime
    name: String!
    pfs_group: Int
    proposals(filters: IPSecProposalFilter, pagination: OffsetPaginationInput): [IPSecProposalType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"IPSecProfile(id, created, last_updated, custom_field_data, description, comments, name, mode, ike_policy, ipsec_policy)"
type IPSecProfileType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ike_policy: IKEPolicyType!
    ipsec_policy: IPSecPolicyType!
    last_updated: DateTime
    mode: String!
    name: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tunnels(filters: TunnelFilter, pagination: OffsetPaginationInput): [TunnelType!]!
}

"IPSecProposal(id, created, last_updated, custom_field_data, description, comments, name, encryption_algorithm, authentication_algorithm, sa_lifetime_seconds, sa_lifetime_data)"
type IPSecProposalType {
    authentication_algorithm: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encryption_algorithm: String
    id: ID!
    ipsec_policies(filters: IPSecPolicyFilter, pagination: OffsetPaginationInput): [IPSecPolicyType!]!
    last_updated: DateTime
    name: String!
    sa_lifetime_data: Int
    sa_lifetime_seconds: Int
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"An uploaded image which is associated with an object."
type ImageAttachmentType {
    class_type: String!
    created: DateTime
    display: String!
    id: ID!
    image: DjangoImageType!
    image_height: Int!
    image_width: Int!
    last_updated: DateTime
    name: String!
    object_id: Int!
    object_type: ContentTypeType
}

"A template for a physical data interface on a new Device."
type InterfaceTemplateType {
    _name: String!
    bridge: InterfaceTemplateType
    bridge_interfaces(filters: InterfaceTemplateFilter, pagination: OffsetPaginationInput): [InterfaceTemplateType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    enabled: Boolean!
    id: ID!
    label: String!
    last_updated: DateTime
    mgmt_only: Boolean!
    module_type: ModuleTypeType
    name: String!
    poe_mode: String
    poe_type: String
    rf_role: String
    type: String!
}

"A network interface within a Device. A physical Interface can connect to exactly one other Interface."
type InterfaceType {
    _name: String!
    bridge: InterfaceType
    bridge_interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    child_interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    duplex: String
    enabled: Boolean!
    id: ID!
    ip_addresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    label: String!
    lag: InterfaceType
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mac_addresses(filters: MACAddressFilter, pagination: OffsetPaginationInput): [MACAddressType!]!
    mark_connected: Boolean!
    member_interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    mgmt_only: Boolean!
    mode: String
    module: ModuleType
    mtu: Int
    name: String!
    parent: InterfaceType
    poe_mode: String
    poe_type: String
    primary_mac_address: MACAddressType
    qinq_svlan: VLANType
    rf_channel: String
    rf_channel_frequency: Decimal
    rf_channel_width: Decimal
    rf_role: String
    speed: Int
    tagged_vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tx_power: Int
    type: String!
    untagged_vlan: VLANType
    vdcs(filters: VirtualDeviceContextFilter, pagination: OffsetPaginationInput): [VirtualDeviceContextType!]!
    vlan_translation_policy: VLANTranslationPolicyType
    vrf: VRFType
    wireless_lans(filters: WirelessLANFilter, pagination: OffsetPaginationInput): [WirelessLANType!]!
    wireless_link: WirelessLinkType
    wwn: String
}

"Inventory items may optionally be assigned a functional role."
type InventoryItemRoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    inventory_item_templates(filters: InventoryItemTemplateFilter, pagination: OffsetPaginationInput): [InventoryItemTemplateType!]!
    inventory_items(filters: InventoryItemFilter, pagination: OffsetPaginationInput): [InventoryItemType!]!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A template for an InventoryItem to be created for a new parent Device."
type InventoryItemTemplateType {
    changelog: [ObjectChangeType!]!
    child_items(filters: InventoryItemTemplateFilter, pagination: OffsetPaginationInput): [InventoryItemTemplateType!]!
    class_type: String!
    component: InventoryItemTemplateComponentType
    created: DateTime
    description: String!
    device_type: DeviceTypeType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    manufacturer: ManufacturerType!
    name: String!
    parent: InventoryItemTemplateType
    part_id: String!
    rght: Int!
    role: InventoryItemRoleType
    tree_id: Int!
}

"""

An InventoryItem represents a serialized piece of hardware within a Device, such as a line card or power supply.
InventoryItems are used only for inventory purposes.
"""
type InventoryItemType {
    asset_tag: String
    changelog: [ObjectChangeType!]!
    child_items(filters: InventoryItemFilter, pagination: OffsetPaginationInput): [InventoryItemType!]!
    class_type: String!
    component: InventoryItemComponentType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    discovered: Boolean!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    manufacturer: ManufacturerType
    name: String!
    parent: InventoryItemType
    part_id: String!
    rght: Int!
    role: InventoryItemRoleType
    serial: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
}

"""

A historical remark concerning an object; collectively, these form an object's journal. The journal is used to
preserve historical context around an object, and complements NetBox's built-in change logging. For example, you
might record a new journal entry when a device undergoes maintenance, or when a prefix is expanded.
"""
type JournalEntryType {
    assigned_object_id: Int!
    assigned_object_type: ContentTypeType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    created_by: UserType
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    kind: String!
    last_updated: DateTime
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"L2VPNTermination(id, created, last_updated, custom_field_data, l2vpn, assigned_object_type, assigned_object_id)"
type L2VPNTerminationType {
    assigned_object: L2VPNAssignmentType!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    l2vpn: L2VPNType!
    last_updated: DateTime
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"L2VPN(id, created, last_updated, custom_field_data, description, comments, name, slug, type, status, identifier, tenant)"
type L2VPNType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    export_targets(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    id: ID!
    identifier: Int
    import_targets(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    slug: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    terminations(filters: L2VPNTerminationFilter, pagination: OffsetPaginationInput): [L2VPNTerminationType!]!
    type: String!
}

"""

A Location represents a subgroup of Racks and/or Devices within a Site. A Location may represent a building within a
site, or a room within a building, for example.
"""
type LocationType {
    cabletermination_set(filters: CableTerminationFilter, pagination: OffsetPaginationInput): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    children(filters: LocationFilter, pagination: OffsetPaginationInput): [LocationType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    facility: String!
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: LocationType
    powerpanel_set(filters: PowerPanelFilter, pagination: OffsetPaginationInput): [PowerPanelType!]!
    racks(filters: RackFilter, pagination: OffsetPaginationInput): [RackType!]!
    rght: Int!
    site: SiteType!
    slug: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
}

"MACAddress(id, created, last_updated, custom_field_data, description, comments, mac_address, assigned_object_type, assigned_object_id)"
type MACAddressType {
    assigned_object: MACAddressAssignmentType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mac_address: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell."
type ManufacturerType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device_types(filters: DeviceTypeFilter, pagination: OffsetPaginationInput): [DeviceTypeType!]!
    display: String!
    id: ID!
    inventory_item_templates(filters: InventoryItemTemplateFilter, pagination: OffsetPaginationInput): [InventoryItemTemplateType!]!
    inventory_items(filters: InventoryItemFilter, pagination: OffsetPaginationInput): [InventoryItemType!]!
    last_updated: DateTime
    module_types(filters: ModuleTypeFilter, pagination: OffsetPaginationInput): [ModuleTypeType!]!
    name: String!
    platforms(filters: PlatformFilter, pagination: OffsetPaginationInput): [PlatformType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A template for a ModuleBay to be created for a new parent Device."
type ModuleBayTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    position: String!
}

"An empty space within a Device which can house a child device"
type ModuleBayType {
    changelog: [ObjectChangeType!]!
    children(filters: ModuleBayFilter, pagination: OffsetPaginationInput): [ModuleBayType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    installed_module: ModuleType
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    module: ModuleType
    name: String!
    parent: ModuleBayType
    position: String!
    rght: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
}

"""

A Module represents a field-installable component within a Device which may itself hold multiple device components
(for example, a line card within a chassis switch). Modules are instantiated from ModuleTypes.
"""
type ModuleType {
    asset_tag: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    consoleports(filters: ConsolePortFilter, pagination: OffsetPaginationInput): [ConsolePortType!]!
    consoleserverports(filters: ConsoleServerPortFilter, pagination: OffsetPaginationInput): [ConsoleServerPortType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    frontports(filters: FrontPortFilter, pagination: OffsetPaginationInput): [FrontPortType!]!
    id: ID!
    interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_context_data: JSON
    module_bay: ModuleBayType!
    module_type: ModuleTypeType!
    poweroutlets(filters: PowerOutletFilter, pagination: OffsetPaginationInput): [PowerOutletType!]!
    powerports(filters: PowerPortFilter, pagination: OffsetPaginationInput): [PowerPortType!]!
    rearports(filters: RearPortFilter, pagination: OffsetPaginationInput): [RearPortType!]!
    serial: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A profile which defines the attributes which can be set on one or more ModuleTypes."
type ModuleTypeProfileType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    module_types(filters: ModuleFilter, pagination: OffsetPaginationInput): [ModuleType!]!
    name: String!
    schema: JSON
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

A ModuleType represents a hardware element that can be installed within a device and which houses additional
components; for example, a line card within a chassis-based switch such as the Cisco Catalyst 6500. Like a
DeviceType, each ModuleType can have console, power, interface, and pass-through port templates assigned to it. It
cannot, however house device bays or module bays.
"""
type ModuleTypeType {
    _abs_weight: Int
    airflow: String
    attribute_data: JSON
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    consoleporttemplates(filters: ConsolePortTemplateFilter, pagination: OffsetPaginationInput): [ConsolePortTemplateType!]!
    consoleserverporttemplates(filters: ConsoleServerPortTemplateFilter, pagination: OffsetPaginationInput): [ConsoleServerPortTemplateType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    frontporttemplates(filters: FrontPortTemplateFilter, pagination: OffsetPaginationInput): [FrontPortTemplateType!]!
    id: ID!
    instances(filters: ModuleFilter, pagination: OffsetPaginationInput): [ModuleType!]!
    interfacetemplates(filters: InterfaceTemplateFilter, pagination: OffsetPaginationInput): [InterfaceTemplateType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    model: String!
    part_number: String!
    poweroutlettemplates(filters: PowerOutletTemplateFilter, pagination: OffsetPaginationInput): [PowerOutletTemplateType!]!
    powerporttemplates(filters: PowerPortTemplateFilter, pagination: OffsetPaginationInput): [PowerPortTemplateType!]!
    profile: ModuleTypeProfileType
    rearporttemplates(filters: RearPortTemplateFilter, pagination: OffsetPaginationInput): [RearPortTemplateType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    weight: Decimal
    weight_unit: String
}

"A collection of users and/or groups to be informed for certain notifications."
type NotificationGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    groups(filters: GroupFilter, pagination: OffsetPaginationInput): [GroupType!]!
    users(filters: UserFilter, pagination: OffsetPaginationInput): [UserType!]!
}

"A notification message for a User relating to a specific object in NetBox."
type NotificationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    user: UserType
}

"""

Record a change to an object and the user account associated with that change. A change record may optionally
indicate an object related to the one being changed. For example, a change to an interface may also indicate the
parent device. This will ensure changes made to component models appear in the parent model's changelog.
"""
type ObjectChangeType {
    action: String!
    changed_object_id: Int!
    changed_object_type: DjangoModelType!
    class_type: String!
    display: String!
    id: ID!
    object_repr: String!
    postchange_data: JSON
    prechange_data: JSON
    related_object_id: Int
    related_object_type: DjangoModelType
    request_id: UUID!
    time: DateTime!
    user: DjangoModelType
    user_name: String!
}

"""

Platform refers to the software or firmware running on a Device. For example, "Cisco IOS-XR" or "Juniper Junos". A
Platform may optionally be associated with a particular Manufacturer.
"""
type PlatformType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    config_template: ConfigTemplateType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    id: ID!
    last_updated: DateTime
    manufacturer: ManufacturerType
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
}

"An electrical circuit delivered from a PowerPanel."
type PowerFeedType {
    amperage: Int!
    available_power: Int!
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    max_utilization: Int!
    name: String!
    phase: String!
    power_panel: PowerPanelType!
    rack: RackType
    status: String!
    supply: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    type: String!
    voltage: Int!
}

"A template for a PowerOutlet to be created for a new Device."
type PowerOutletTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    feed_leg: String
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    power_port: PowerPortTemplateType
    type: String
}

"A physical power outlet (output) within a Device which provides power to a PowerPort."
type PowerOutletType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    feed_leg: String
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    power_port: PowerPortType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String
}

"A distribution point for electrical power; e.g. a data center RPP."
type PowerPanelType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    location: LocationType
    name: String!
    powerfeeds(filters: PowerFeedFilter, pagination: OffsetPaginationInput): [PowerFeedType!]!
    site: SiteType!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A template for a PowerPort to be created for a new Device."
type PowerPortTemplateType {
    allocated_draw: Int
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    maximum_draw: Int
    module_type: ModuleTypeType
    name: String!
    poweroutlet_templates(filters: PowerOutletTemplateFilter, pagination: OffsetPaginationInput): [PowerOutletTemplateType!]!
    type: String
}

"A physical power supply (intake) port within a Device. PowerPorts connect to PowerOutlets."
type PowerPortType {
    allocated_draw: Int
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    maximum_draw: Int
    module: ModuleType
    name: String!
    poweroutlets(filters: PowerOutletFilter, pagination: OffsetPaginationInput): [PowerOutletType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String
}

"""

A Prefix represents an IPv4 or IPv6 network, including mask length. Prefixes can optionally be scoped to certain
areas and/or assigned to VRFs. A Prefix must be assigned a status and may optionally be assigned a used-define Role.
A Prefix can also be assigned to a VLAN where appropriate.
"""
type PrefixType {
    _children: Int!
    _depth: Int!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    family: IPAddressFamilyType!
    id: ID!
    is_pool: Boolean!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mark_utilized: Boolean!
    prefix: String!
    role: RoleType
    scope: PrefixScopeType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vlan: VLANType
    vrf: VRFType
}

"This is a discrete account within a provider.  Each Circuit belongs to a Provider Account."
type ProviderAccountType {
    account: String!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter, pagination: OffsetPaginationInput): [CircuitType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    provider: ProviderType!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

This represents a provider network which exists outside of NetBox, the details of which are unknown or
unimportant to the user.
"""
type ProviderNetworkType {
    changelog: [ObjectChangeType!]!
    circuit_terminations(filters: CircuitTerminationFilter, pagination: OffsetPaginationInput): [CircuitTerminationType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    provider: ProviderType!
    service_id: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

Each Circuit belongs to a Provider. This is usually a telecommunications company or similar organization. This model
stores information pertinent to the user's relationship with the Provider.
"""
type ProviderType {
    accounts(filters: ProviderAccountFilter, pagination: OffsetPaginationInput): [ProviderAccountType!]!
    asns(filters: ASNFilter, pagination: OffsetPaginationInput): [ASNType!]!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter, pagination: OffsetPaginationInput): [CircuitType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    networks(filters: ProviderNetworkFilter, pagination: OffsetPaginationInput): [ProviderNetworkType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

type Query {
    aggregate(id: ID!): AggregateType!
    aggregate_list(filters: AggregateFilter, pagination: OffsetPaginationInput): [AggregateType!]!
    asn(id: ID!): ASNType!
    asn_list(filters: ASNFilter, pagination: OffsetPaginationInput): [ASNType!]!
    asn_range(id: ID!): ASNRangeType!
    asn_range_list(filters: ASNRangeFilter, pagination: OffsetPaginationInput): [ASNRangeType!]!
    cable(id: ID!): CableType!
    cable_list(filters: CableFilter, pagination: OffsetPaginationInput): [CableType!]!
    circuit(id: ID!): CircuitType!
    circuit_group(id: ID!): CircuitGroupType!
    circuit_group_assignment(id: ID!): CircuitGroupAssignmentType!
    circuit_group_assignment_list(filters: CircuitGroupAssignmentFilter, pagination: OffsetPaginationInput): [CircuitGroupAssignmentType!]!
    circuit_group_list(filters: CircuitGroupFilter, pagination: OffsetPaginationInput): [CircuitGroupType!]!
    circuit_list(filters: CircuitFilter, pagination: OffsetPaginationInput): [CircuitType!]!
    circuit_termination(id: ID!): CircuitTerminationType!
    circuit_termination_list(filters: CircuitTerminationFilter, pagination: OffsetPaginationInput): [CircuitTerminationType!]!
    circuit_type(id: ID!): CircuitTypeType!
    circuit_type_list(filters: CircuitTypeFilter, pagination: OffsetPaginationInput): [CircuitTypeType!]!
    cluster(id: ID!): ClusterType!
    cluster_group(id: ID!): ClusterGroupType!
    cluster_group_list(filters: ClusterGroupFilter, pagination: OffsetPaginationInput): [ClusterGroupType!]!
    cluster_list(filters: ClusterFilter, pagination: OffsetPaginationInput): [ClusterType!]!
    cluster_type(id: ID!): ClusterTypeType!
    cluster_type_list(filters: ClusterTypeFilter, pagination: OffsetPaginationInput): [ClusterTypeType!]!
    config_context(id: ID!): ConfigContextType!
    config_context_list(filters: ConfigContextFilter, pagination: OffsetPaginationInput): [ConfigContextType!]!
    config_template(id: ID!): ConfigTemplateType!
    config_template_list(filters: ConfigTemplateFilter, pagination: OffsetPaginationInput): [ConfigTemplateType!]!
    console_port(id: ID!): ConsolePortType!
    console_port_list(filters: ConsolePortFilter, pagination: OffsetPaginationInput): [ConsolePortType!]!
    console_port_template(id: ID!): ConsolePortTemplateType!
    console_port_template_list(filters: ConsolePortTemplateFilter, pagination: OffsetPaginationInput): [ConsolePortTemplateType!]!
    console_server_port(id: ID!): ConsoleServerPortType!
    console_server_port_list(filters: ConsoleServerPortFilter, pagination: OffsetPaginationInput): [ConsoleServerPortType!]!
    console_server_port_template(id: ID!): ConsoleServerPortTemplateType!
    console_server_port_template_list(filters: ConsoleServerPortTemplateFilter, pagination: OffsetPaginationInput): [ConsoleServerPortTemplateType!]!
    contact(id: ID!): ContactType!
    contact_assignment(id: ID!): ContactAssignmentType!
    contact_assignment_list(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    contact_group(id: ID!): ContactGroupType!
    contact_group_list(filters: ContactGroupFilter, pagination: OffsetPaginationInput): [ContactGroupType!]!
    contact_list(filters: ContactFilter, pagination: OffsetPaginationInput): [ContactType!]!
    contact_role(id: ID!): ContactRoleType!
    contact_role_list(filters: ContactRoleFilter, pagination: OffsetPaginationInput): [ContactRoleType!]!
    custom_field(id: ID!): CustomFieldType!
    custom_field_choice_set(id: ID!): CustomFieldChoiceSetType!
    custom_field_choice_set_list(filters: CustomFieldChoiceSetFilter, pagination: OffsetPaginationInput): [CustomFieldChoiceSetType!]!
    custom_field_list(filters: CustomFieldFilter, pagination: OffsetPaginationInput): [CustomFieldType!]!
    custom_link(id: ID!): CustomLinkType!
    custom_link_list(filters: CustomLinkFilter, pagination: OffsetPaginationInput): [CustomLinkType!]!
    data_file(id: ID!): DataFileType!
    data_file_list(filters: DataFileFilter, pagination: OffsetPaginationInput): [DataFileType!]!
    data_source(id: ID!): DataSourceType!
    data_source_list(filters: DataSourceFilter, pagination: OffsetPaginationInput): [DataSourceType!]!
    device(id: ID!): DeviceType!
    device_bay(id: ID!): DeviceBayType!
    device_bay_list(filters: DeviceBayFilter, pagination: OffsetPaginationInput): [DeviceBayType!]!
    device_bay_template(id: ID!): DeviceBayTemplateType!
    device_bay_template_list(filters: DeviceBayTemplateFilter, pagination: OffsetPaginationInput): [DeviceBayTemplateType!]!
    device_list(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    device_role(id: ID!): DeviceRoleType!
    device_role_list(filters: DeviceRoleFilter, pagination: OffsetPaginationInput): [DeviceRoleType!]!
    device_type(id: ID!): DeviceTypeType!
    device_type_list(filters: DeviceTypeFilter, pagination: OffsetPaginationInput): [DeviceTypeType!]!
    event_rule(id: ID!): EventRuleType!
    event_rule_list(filters: EventRuleFilter, pagination: OffsetPaginationInput): [EventRuleType!]!
    export_template(id: ID!): ExportTemplateType!
    export_template_list(filters: ExportTemplateFilter, pagination: OffsetPaginationInput): [ExportTemplateType!]!
    fhrp_group(id: ID!): FHRPGroupType!
    fhrp_group_assignment(id: ID!): FHRPGroupAssignmentType!
    fhrp_group_assignment_list(filters: FHRPGroupAssignmentFilter, pagination: OffsetPaginationInput): [FHRPGroupAssignmentType!]!
    fhrp_group_list(filters: FHRPGroupFilter, pagination: OffsetPaginationInput): [FHRPGroupType!]!
    front_port(id: ID!): FrontPortType!
    front_port_list(filters: FrontPortFilter, pagination: OffsetPaginationInput): [FrontPortType!]!
    front_port_template(id: ID!): FrontPortTemplateType!
    front_port_template_list(filters: FrontPortTemplateFilter, pagination: OffsetPaginationInput): [FrontPortTemplateType!]!
    group(id: ID!): GroupType!
    group_list(filters: GroupFilter, pagination: OffsetPaginationInput): [GroupType!]!
    ike_policy(id: ID!): IKEPolicyType!
    ike_policy_list(filters: IKEPolicyFilter, pagination: OffsetPaginationInput): [IKEPolicyType!]!
    ike_proposal(id: ID!): IKEProposalType!
    ike_proposal_list(filters: IKEProposalFilter, pagination: OffsetPaginationInput): [IKEProposalType!]!
    image_attachment(id: ID!): ImageAttachmentType!
    image_attachment_list(filters: ImageAttachmentFilter, pagination: OffsetPaginationInput): [ImageAttachmentType!]!
    interface(id: ID!): InterfaceType!
    interface_list(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    interface_template(id: ID!): InterfaceTemplateType!
    interface_template_list(filters: InterfaceTemplateFilter, pagination: OffsetPaginationInput): [InterfaceTemplateType!]!
    inventory_item(id: ID!): InventoryItemType!
    inventory_item_list(filters: InventoryItemFilter, pagination: OffsetPaginationInput): [InventoryItemType!]!
    inventory_item_role(id: ID!): InventoryItemRoleType!
    inventory_item_role_list(filters: InventoryItemRoleFilter, pagination: OffsetPaginationInput): [InventoryItemRoleType!]!
    inventory_item_template(id: ID!): InventoryItemTemplateType!
    inventory_item_template_list(filters: InventoryItemTemplateFilter, pagination: OffsetPaginationInput): [InventoryItemTemplateType!]!
    ip_address(id: ID!): IPAddressType!
    ip_address_list(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    ip_range(id: ID!): IPRangeType!
    ip_range_list(filters: IPRangeFilter, pagination: OffsetPaginationInput): [IPRangeType!]!
    ipsec_policy(id: ID!): IPSecPolicyType!
    ipsec_policy_list(filters: IPSecPolicyFilter, pagination: OffsetPaginationInput): [IPSecPolicyType!]!
    ipsec_profile(id: ID!): IPSecProfileType!
    ipsec_profile_list(filters: IPSecProfileFilter, pagination: OffsetPaginationInput): [IPSecProfileType!]!
    ipsec_proposal(id: ID!): IPSecProposalType!
    ipsec_proposal_list(filters: IPSecProposalFilter, pagination: OffsetPaginationInput): [IPSecProposalType!]!
    journal_entry(id: ID!): JournalEntryType!
    journal_entry_list(filters: JournalEntryFilter, pagination: OffsetPaginationInput): [JournalEntryType!]!
    l2vpn(id: ID!): L2VPNType!
    l2vpn_list(filters: L2VPNFilter, pagination: OffsetPaginationInput): [L2VPNType!]!
    l2vpn_termination(id: ID!): L2VPNTerminationType!
    l2vpn_termination_list(filters: L2VPNTerminationFilter, pagination: OffsetPaginationInput): [L2VPNTerminationType!]!
    location(id: ID!): LocationType!
    location_list(filters: LocationFilter, pagination: OffsetPaginationInput): [LocationType!]!
    mac_address(id: ID!): MACAddressType!
    mac_address_list(filters: MACAddressFilter, pagination: OffsetPaginationInput): [MACAddressType!]!
    manufacturer(id: ID!): ManufacturerType!
    manufacturer_list(filters: ManufacturerFilter, pagination: OffsetPaginationInput): [ManufacturerType!]!
    module(id: ID!): ModuleType!
    module_bay(id: ID!): ModuleBayType!
    module_bay_list(filters: ModuleBayFilter, pagination: OffsetPaginationInput): [ModuleBayType!]!
    module_bay_template(id: ID!): ModuleBayTemplateType!
    module_bay_template_list(filters: ModuleBayTemplateFilter, pagination: OffsetPaginationInput): [ModuleBayTemplateType!]!
    module_list(filters: ModuleFilter, pagination: OffsetPaginationInput): [ModuleType!]!
    module_type(id: ID!): ModuleTypeType!
    module_type_list(filters: ModuleTypeFilter, pagination: OffsetPaginationInput): [ModuleTypeType!]!
    module_type_profile(id: ID!): ModuleTypeProfileType!
    module_type_profile_list(filters: ModuleTypeProfileFilter, pagination: OffsetPaginationInput): [ModuleTypeProfileType!]!
    notification(id: ID!): NotificationType!
    notification_group(id: ID!): NotificationGroupType!
    notification_group_list(filters: NotificationGroupFilter, pagination: OffsetPaginationInput): [NotificationGroupType!]!
    notification_list(pagination: OffsetPaginationInput): [NotificationType!]!
    platform(id: ID!): PlatformType!
    platform_list(filters: PlatformFilter, pagination: OffsetPaginationInput): [PlatformType!]!
    power_feed(id: ID!): PowerFeedType!
    power_feed_list(filters: PowerFeedFilter, pagination: OffsetPaginationInput): [PowerFeedType!]!
    power_outlet(id: ID!): PowerOutletType!
    power_outlet_list(filters: PowerOutletFilter, pagination: OffsetPaginationInput): [PowerOutletType!]!
    power_outlet_template(id: ID!): PowerOutletTemplateType!
    power_outlet_template_list(filters: PowerOutletTemplateFilter, pagination: OffsetPaginationInput): [PowerOutletTemplateType!]!
    power_panel(id: ID!): PowerPanelType!
    power_panel_list(filters: PowerPanelFilter, pagination: OffsetPaginationInput): [PowerPanelType!]!
    power_port(id: ID!): PowerPortType!
    power_port_list(filters: PowerPortFilter, pagination: OffsetPaginationInput): [PowerPortType!]!
    power_port_template(id: ID!): PowerPortTemplateType!
    power_port_template_list(filters: PowerPortTemplateFilter, pagination: OffsetPaginationInput): [PowerPortTemplateType!]!
    prefix(id: ID!): PrefixType!
    prefix_list(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    provider(id: ID!): ProviderType!
    provider_account(id: ID!): ProviderAccountType!
    provider_account_list(filters: ProviderAccountFilter, pagination: OffsetPaginationInput): [ProviderAccountType!]!
    provider_list(filters: ProviderFilter, pagination: OffsetPaginationInput): [ProviderType!]!
    provider_network(id: ID!): ProviderNetworkType!
    provider_network_list(filters: ProviderNetworkFilter, pagination: OffsetPaginationInput): [ProviderNetworkType!]!
    rack(id: ID!): RackType!
    rack_list(filters: RackFilter, pagination: OffsetPaginationInput): [RackType!]!
    rack_reservation(id: ID!): RackReservationType!
    rack_reservation_list(filters: RackReservationFilter, pagination: OffsetPaginationInput): [RackReservationType!]!
    rack_role(id: ID!): RackRoleType!
    rack_role_list(filters: RackRoleFilter, pagination: OffsetPaginationInput): [RackRoleType!]!
    rack_type(id: ID!): RackTypeType!
    rack_type_list(filters: RackTypeFilter, pagination: OffsetPaginationInput): [RackTypeType!]!
    rear_port(id: ID!): RearPortType!
    rear_port_list(filters: RearPortFilter, pagination: OffsetPaginationInput): [RearPortType!]!
    rear_port_template(id: ID!): RearPortTemplateType!
    rear_port_template_list(filters: RearPortTemplateFilter, pagination: OffsetPaginationInput): [RearPortTemplateType!]!
    region(id: ID!): RegionType!
    region_list(filters: RegionFilter, pagination: OffsetPaginationInput): [RegionType!]!
    rir(id: ID!): RIRType!
    rir_list(filters: RIRFilter, pagination: OffsetPaginationInput): [RIRType!]!
    role(id: ID!): RoleType!
    role_list(filters: RoleFilter, pagination: OffsetPaginationInput): [RoleType!]!
    route_target(id: ID!): RouteTargetType!
    route_target_list(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    saved_filter(id: ID!): SavedFilterType!
    saved_filter_list(filters: SavedFilterFilter, pagination: OffsetPaginationInput): [SavedFilterType!]!
    service(id: ID!): ServiceType!
    service_list(filters: ServiceFilter, pagination: OffsetPaginationInput): [ServiceType!]!
    service_template(id: ID!): ServiceTemplateType!
    service_template_list(filters: ServiceTemplateFilter, pagination: OffsetPaginationInput): [ServiceTemplateType!]!
    site(id: ID!): SiteType!
    site_group(id: ID!): SiteGroupType!
    site_group_list(filters: SiteGroupFilter, pagination: OffsetPaginationInput): [SiteGroupType!]!
    site_list(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    subscription(id: ID!): SubscriptionType!
    subscription_list(pagination: OffsetPaginationInput): [SubscriptionType!]!
    table_config(id: ID!): TableConfigType!
    table_config_list(filters: TableConfigFilter, pagination: OffsetPaginationInput): [TableConfigType!]!
    tag(id: ID!): TagType!
    tag_list(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant(id: ID!): TenantType!
    tenant_group(id: ID!): TenantGroupType!
    tenant_group_list(filters: TenantGroupFilter, pagination: OffsetPaginationInput): [TenantGroupType!]!
    tenant_list(filters: TenantFilter, pagination: OffsetPaginationInput): [TenantType!]!
    tunnel(id: ID!): TunnelType!
    tunnel_group(id: ID!): TunnelGroupType!
    tunnel_group_list(filters: TunnelGroupFilter, pagination: OffsetPaginationInput): [TunnelGroupType!]!
    tunnel_list(filters: TunnelFilter, pagination: OffsetPaginationInput): [TunnelType!]!
    tunnel_termination(id: ID!): TunnelTerminationType!
    tunnel_termination_list(filters: TunnelTerminationFilter, pagination: OffsetPaginationInput): [TunnelTerminationType!]!
    user(id: ID!): UserType!
    user_list(filters: UserFilter, pagination: OffsetPaginationInput): [UserType!]!
    virtual_chassis(id: ID!): VirtualChassisType!
    virtual_chassis_list(filters: VirtualChassisFilter, pagination: OffsetPaginationInput): [VirtualChassisType!]!
    virtual_circuit(id: ID!): VirtualCircuitType!
    virtual_circuit_list(filters: VirtualCircuitFilter, pagination: OffsetPaginationInput): [VirtualCircuitType!]!
    virtual_circuit_termination(id: ID!): VirtualCircuitTerminationType!
    virtual_circuit_termination_list(filters: VirtualCircuitTerminationFilter, pagination: OffsetPaginationInput): [VirtualCircuitTerminationType!]!
    virtual_circuit_type(id: ID!): VirtualCircuitTypeType!
    virtual_circuit_type_list(filters: VirtualCircuitTypeFilter, pagination: OffsetPaginationInput): [VirtualCircuitTypeType!]!
    virtual_device_context(id: ID!): VirtualDeviceContextType!
    virtual_device_context_list(filters: VirtualDeviceContextFilter, pagination: OffsetPaginationInput): [VirtualDeviceContextType!]!
    virtual_disk(id: ID!): VirtualDiskType!
    virtual_disk_list(filters: VirtualDiskFilter, pagination: OffsetPaginationInput): [VirtualDiskType!]!
    virtual_machine(id: ID!): VirtualMachineType!
    virtual_machine_list(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
    vlan(id: ID!): VLANType!
    vlan_group(id: ID!): VLANGroupType!
    vlan_group_list(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
    vlan_list(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
    vlan_translation_policy(id: ID!): VLANTranslationPolicyType!
    vlan_translation_policy_list(filters: VLANTranslationPolicyFilter, pagination: OffsetPaginationInput): [VLANTranslationPolicyType!]!
    vlan_translation_rule(id: ID!): VLANTranslationRuleType!
    vlan_translation_rule_list(filters: VLANTranslationRuleFilter, pagination: OffsetPaginationInput): [VLANTranslationRuleType!]!
    vm_interface(id: ID!): VMInterfaceType!
    vm_interface_list(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    vrf(id: ID!): VRFType!
    vrf_list(filters: VRFFilter, pagination: OffsetPaginationInput): [VRFType!]!
    webhook(id: ID!): WebhookType!
    webhook_list(filters: WebhookFilter, pagination: OffsetPaginationInput): [WebhookType!]!
    wireless_lan(id: ID!): WirelessLANType!
    wireless_lan_group(id: ID!): WirelessLANGroupType!
    wireless_lan_group_list(filters: WirelessLANGroupFilter, pagination: OffsetPaginationInput): [WirelessLANGroupType!]!
    wireless_lan_list(filters: WirelessLANFilter, pagination: OffsetPaginationInput): [WirelessLANType!]!
    wireless_link(id: ID!): WirelessLinkType!
    wireless_link_list(filters: WirelessLinkFilter, pagination: OffsetPaginationInput): [WirelessLinkType!]!
}

"""

A Regional Internet Registry (RIR) is responsible for the allocation of a large portion of the global IP address
space. This can be an organization like ARIN or RIPE, or a governing standard such as RFC 1918.
"""
type RIRType {
    aggregates(filters: AggregateFilter, pagination: OffsetPaginationInput): [AggregateType!]!
    asn_ranges(filters: ASNRangeFilter, pagination: OffsetPaginationInput): [ASNRangeType!]!
    asns(filters: ASNFilter, pagination: OffsetPaginationInput): [ASNType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    is_private: Boolean!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"One or more reserved units within a Rack."
type RackReservationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    rack: RackType!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    units: [Int!]!
    user: UserType!
}

"Racks can be organized by functional role, similar to Devices."
type RackRoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    racks(filters: RackFilter, pagination: OffsetPaginationInput): [RackType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
type RackType {
    _abs_max_weight: Int
    _abs_weight: Int
    airflow: String
    asset_tag: String
    cabletermination_set(filters: CableTerminationFilter, pagination: OffsetPaginationInput): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    desc_units: Boolean!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    facility_id: String
    form_factor: String
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    location: LocationType
    max_weight: Int
    mounting_depth: Int
    name: String!
    outer_depth: Int
    outer_height: Int
    outer_unit: String
    outer_width: Int
    powerfeeds(filters: PowerFeedFilter, pagination: OffsetPaginationInput): [PowerFeedType!]!
    rack_type: RackTypeType
    reservations(filters: RackReservationFilter, pagination: OffsetPaginationInput): [RackReservationType!]!
    role: RackRoleType
    serial: String!
    site: SiteType!
    starting_unit: Int!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    u_height: Int!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
    weight: Decimal
    weight_unit: String
    width: Int!
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
type RackTypeType {
    _abs_max_weight: Int
    _abs_weight: Int
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    desc_units: Boolean!
    description: String!
    display: String!
    form_factor: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    max_weight: Int
    model: String!
    mounting_depth: Int
    outer_depth: Int
    outer_height: Int
    outer_unit: String
    outer_width: Int
    slug: String!
    starting_unit: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    u_height: Int!
    weight: Decimal
    weight_unit: String
    width: Int!
}

"Template for a pass-through port on the rear of a new Device."
type RearPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    frontport_templates(filters: FrontPortTemplateFilter, pagination: OffsetPaginationInput): [FrontPortTemplateType!]!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    positions: Int!
    type: String!
}

"A pass-through port on the rear of a Device."
type RearPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    frontports(filters: FrontPortFilter, pagination: OffsetPaginationInput): [FrontPortType!]!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    positions: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    type: String!
}

"""

A region represents a geographic collection of sites. For example, you might create regions representing countries,
states, and/or cities. Regions are recursively nested into a hierarchy: all sites belonging to a child region are
also considered to be members of its parent and ancestor region(s).
"""
type RegionType {
    changelog: [ObjectChangeType!]!
    children(filters: RegionFilter, pagination: OffsetPaginationInput): [RegionType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: RegionType
    rght: Int!
    sites(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
}

"""

A Role represents the functional role of a Prefix or VLAN; for example, "Customer," "Infrastructure," or
"Management."
"""
type RoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ip_ranges(filters: IPRangeFilter, pagination: OffsetPaginationInput): [IPRangeType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
    weight: Int!
}

"A BGP extended community used to control the redistribution of routes among VRFs, as defined in RFC 4364."
type RouteTargetType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    exporting_l2vpns(filters: L2VPNFilter, pagination: OffsetPaginationInput): [L2VPNType!]!
    exporting_vrfs(filters: VRFFilter, pagination: OffsetPaginationInput): [VRFType!]!
    id: ID!
    importing_l2vpns(filters: L2VPNFilter, pagination: OffsetPaginationInput): [L2VPNType!]!
    importing_vrfs(filters: VRFFilter, pagination: OffsetPaginationInput): [VRFType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"A set of predefined keyword parameters that can be reused to filter for specific objects."
type SavedFilterType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    last_updated: DateTime
    name: String!
    parameters: JSON!
    shared: Boolean!
    slug: String!
    user: UserType
    weight: Int!
}

"A template for a Service to be applied to a device or virtual machine."
type ServiceTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    ports: [Int!]!
    protocol: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

A Service represents a layer-four service (e.g. HTTP or SSH) running on a Device or VirtualMachine. A Service may
optionally be tied to one or more specific IPAddresses belonging to its parent.
"""
type ServiceType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ipaddresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    parent: ServiceParentType
    ports: [Int!]!
    protocol: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

A site group is an arbitrary grouping of sites. For example, you might have corporate sites and customer sites; and
within corporate sites you might distinguish between offices and data centers. Like regions, site groups can be
nested recursively to form a hierarchy.
"""
type SiteGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: SiteGroupFilter, pagination: OffsetPaginationInput): [SiteGroupType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: SiteGroupType
    rght: Int!
    sites(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
}

"""

A Site represents a geographic location within a network; typically a building or campus. The optional facility
field can be used to include an external designation, such as a data center name (e.g. Equinix SV6).
"""
type SiteType {
    asns(filters: ASNFilter, pagination: OffsetPaginationInput): [ASNType!]!
    cabletermination_set(filters: CableTerminationFilter, pagination: OffsetPaginationInput): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    facility: String!
    group: SiteGroupType
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    latitude: Decimal
    locations(filters: LocationFilter, pagination: OffsetPaginationInput): [LocationType!]!
    longitude: Decimal
    name: String!
    physical_address: String!
    powerpanel_set(filters: PowerPanelFilter, pagination: OffsetPaginationInput): [PowerPanelType!]!
    prefixes(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    racks(filters: RackFilter, pagination: OffsetPaginationInput): [RackType!]!
    region: RegionType
    shipping_address: String!
    slug: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    time_zone: String
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
    vlan_groups(filters: VLANGroupFilter, pagination: OffsetPaginationInput): [VLANGroupType!]!
    vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
}

"A User's subscription to a particular object, to be notified of changes."
type SubscriptionType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    user: UserType
}

"A saved configuration of columns and ordering which applies to a specific table."
type TableConfigType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    columns: [String!]!
    created: DateTime
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    last_updated: DateTime
    name: String!
    object_type: DjangoModelType!
    ordering: [String!]
    shared: Boolean!
    table: String!
    user: UserType
    weight: Int!
}

"Tag(name, slug, created, last_updated, id, color, description, weight)"
type TagType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    object_types(pagination: OffsetPaginationInput): [ContentTypeType!]!
    slug: String!
    weight: Int!
}

"An arbitrary collection of Tenants."
type TenantGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: TenantGroupFilter, pagination: OffsetPaginationInput): [TenantGroupType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: TenantGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenants(filters: TenantFilter, pagination: OffsetPaginationInput): [TenantType!]!
    tree_id: Int!
}

"""

A Tenant represents an organization served by the NetBox owner. This is typically a customer or an internal
department.
"""
type TenantType {
    aggregates(filters: AggregateFilter, pagination: OffsetPaginationInput): [AggregateType!]!
    asn_ranges(filters: ASNRangeFilter, pagination: OffsetPaginationInput): [ASNRangeType!]!
    asns(filters: ASNFilter, pagination: OffsetPaginationInput): [ASNType!]!
    cables(filters: CableFilter, pagination: OffsetPaginationInput): [CableType!]!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter, pagination: OffsetPaginationInput): [CircuitType!]!
    class_type: String!
    clusters(filters: ClusterFilter, pagination: OffsetPaginationInput): [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    display: String!
    group: TenantGroupType
    id: ID!
    ip_addresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    ip_ranges(filters: IPRangeFilter, pagination: OffsetPaginationInput): [IPRangeType!]!
    journal_entries: [JournalEntryType!]!
    l2vpns(filters: L2VPNFilter, pagination: OffsetPaginationInput): [L2VPNType!]!
    last_updated: DateTime
    locations(filters: LocationFilter, pagination: OffsetPaginationInput): [LocationType!]!
    name: String!
    power_feeds(filters: PowerFeedFilter, pagination: OffsetPaginationInput): [PowerFeedType!]!
    prefixes(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    rackreservations(filters: RackReservationFilter, pagination: OffsetPaginationInput): [RackReservationType!]!
    racks(filters: RackFilter, pagination: OffsetPaginationInput): [RackType!]!
    route_targets(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    sites(filters: SiteFilter, pagination: OffsetPaginationInput): [SiteType!]!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tunnels(filters: TunnelFilter, pagination: OffsetPaginationInput): [TunnelType!]!
    vdcs(filters: VirtualDeviceContextFilter, pagination: OffsetPaginationInput): [VirtualDeviceContextType!]!
    virtual_machines(filters: VirtualMachineFilter, pagination: OffsetPaginationInput): [VirtualMachineType!]!
    vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
    vrfs(filters: VRFFilter, pagination: OffsetPaginationInput): [VRFType!]!
    wireless_lans(filters: WirelessLANFilter, pagination: OffsetPaginationInput): [WirelessLANType!]!
    wireless_links(filters: WirelessLinkFilter, pagination: OffsetPaginationInput): [WirelessLinkType!]!
}

"""

An administrative grouping of Tunnels. This can be used to correlate peer-to-peer tunnels which form a mesh,
for example.
"""
type TunnelGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tunnels(filters: TunnelFilter, pagination: OffsetPaginationInput): [TunnelType!]!
}

"TunnelTermination(id, created, last_updated, custom_field_data, tunnel, role, termination_type, termination_id, outside_ip)"
type TunnelTerminationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    last_updated: DateTime
    outside_ip: IPAddressType
    role: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    termination_id: Int
    termination_type: ContentTypeType
    tunnel: TunnelType!
}

"Tunnel(id, created, last_updated, custom_field_data, description, comments, name, status, group, encapsulation, ipsec_profile, tenant, tunnel_id)"
type TunnelType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encapsulation: String!
    group: TunnelGroupType
    id: ID!
    ipsec_profile: IPSecProfileType
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    terminations(filters: TunnelTerminationFilter, pagination: OffsetPaginationInput): [TunnelTerminationType!]!
    tunnel_id: Int
}

"User(id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined)"
type UserType {
    class_type: String!
    date_joined: DateTime!
    display: String!
    email: String!
    first_name: String!
    groups(filters: GroupFilter, pagination: OffsetPaginationInput): [GroupType!]!
    id: ID!
    is_active: Boolean!
    is_staff: Boolean!
    last_name: String!
    username: String!
}

"""

A VLAN group is an arbitrary collection of VLANs within which VLAN IDs and names must be unique. Each group must
define one or more ranges of valid VLAN IDs, and may be assigned a specific scope.
"""
type VLANGroupType {
    _total_vlan_ids: Int!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    scope: VLANGroupScopeType
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vid_ranges: [String!]!
    vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
}

"VLANTranslationPolicy(id, created, last_updated, custom_field_data, description, comments, name)"
type VLANTranslationPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    rules(filters: VLANTranslationRuleFilter, pagination: OffsetPaginationInput): [VLANTranslationRuleType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"VLANTranslationRule(id, created, last_updated, custom_field_data, policy, description, local_vid, remote_vid)"
type VLANTranslationRuleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_vid: Int!
    policy: VLANTranslationPolicyType!
    remote_vid: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"""

A VLAN is a distinct layer two forwarding domain identified by a 12-bit integer (1-4094). Each VLAN must be assigned
to a Site, however VLAN IDs need not be unique within a Site. A VLAN may optionally be assigned to a VLANGroup,
within which all VLAN IDs and names but be unique.

Like Prefixes, each VLAN is assigned an operational status and optionally a user-defined Role. A VLAN can have zero
or more Prefixes assigned to it.
"""
type VLANType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    group: VLANGroupType
    id: ID!
    interfaces_as_tagged(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    interfaces_as_untagged(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    qinq_role: String
    qinq_svlan: VLANType
    role: RoleType
    site: SiteType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vid: Int!
    vminterfaces_as_tagged(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    vminterfaces_as_untagged(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    wirelesslan_set(filters: WirelessLANFilter, pagination: OffsetPaginationInput): [WirelessLANType!]!
}

"VMInterface(id, created, last_updated, custom_field_data, enabled, mtu, mode, parent, bridge, untagged_vlan, qinq_svlan, vlan_translation_policy, primary_mac_address, description, name, _name, virtual_machine, vrf)"
type VMInterfaceType {
    _name: String!
    bridge: VMInterfaceType
    bridge_interfaces(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    changelog: [ObjectChangeType!]!
    child_interfaces(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    ip_addresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mac_address: String
    mac_addresses(filters: MACAddressFilter, pagination: OffsetPaginationInput): [MACAddressType!]!
    mode: String
    mtu: Int
    name: String!
    parent: VMInterfaceType
    primary_mac_address: MACAddressType
    qinq_svlan: VLANType
    tagged_vlans(filters: VLANFilter, pagination: OffsetPaginationInput): [VLANType!]!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    untagged_vlan: VLANType
    virtual_machine: VirtualMachineType!
    vlan_translation_policy: VLANTranslationPolicyType
    vrf: VRFType
}

"""

A virtual routing and forwarding (VRF) table represents a discrete layer three forwarding domain (e.g. a routing
table). Prefixes and IPAddresses can optionally be assigned to VRFs. (Prefixes and IPAddresses not assigned to a VRF
are said to exist in the "global" table.)
"""
type VRFType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enforce_unique: Boolean!
    export_targets(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    id: ID!
    import_targets(filters: RouteTargetFilter, pagination: OffsetPaginationInput): [RouteTargetType!]!
    interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    ip_addresses(filters: IPAddressFilter, pagination: OffsetPaginationInput): [IPAddressType!]!
    ip_ranges(filters: IPRangeFilter, pagination: OffsetPaginationInput): [IPRangeType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter, pagination: OffsetPaginationInput): [PrefixType!]!
    rd: String
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vminterfaces(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
}

"A collection of Devices which operate with a shared control plane (e.g. a switch stack)."
type VirtualChassisType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    domain: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    master: DeviceType
    member_count: Union!
    members(filters: DeviceFilter, pagination: OffsetPaginationInput): [DeviceType!]!
    name: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"VirtualCircuitTermination(id, created, last_updated, custom_field_data, virtual_circuit, role, interface, description)"
type VirtualCircuitTerminationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    interface: InterfaceType!
    last_updated: DateTime
    role: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    virtual_circuit: VirtualCircuitType!
}

"A virtual connection between two or more endpoints, delivered across one or more physical circuits."
type VirtualCircuitType {
    changelog: [ObjectChangeType!]!
    cid: String!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    provider_account: ProviderAccountType
    provider_network: ProviderNetworkType!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    terminations(filters: VirtualCircuitTerminationFilter, pagination: OffsetPaginationInput): [VirtualCircuitTerminationType!]!
    type: VirtualCircuitTypeType!
}

"""

Like physical circuits, virtual circuits can be organized by their functional role. For example, a user might wish
to categorize virtual circuits by their technological nature or by product name.
"""
type VirtualCircuitTypeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    virtual_circuits(filters: VirtualCircuitFilter, pagination: OffsetPaginationInput): [VirtualCircuitType!]!
}

"VirtualDeviceContext(id, created, last_updated, custom_field_data, description, device, name, status, identifier, primary_ip4, primary_ip6, tenant, comments)"
type VirtualDeviceContextType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType
    display: String!
    id: ID!
    identifier: Int
    interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

"VirtualDisk(id, created, last_updated, custom_field_data, virtual_machine, name, description, size)"
type VirtualDiskType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    size: Int!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    virtual_machine: VirtualMachineType!
}

"A virtual machine which runs inside a Cluster."
type VirtualMachineType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster: ClusterType
    comments: String!
    config_context: JSON!
    config_template: ConfigTemplateType
    contacts(filters: ContactAssignmentFilter, pagination: OffsetPaginationInput): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType
    disk: Int
    display: String!
    id: ID!
    interface_count: Union!
    interfaces(filters: VMInterfaceFilter, pagination: OffsetPaginationInput): [VMInterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_context_data: JSON
    memory: Int
    name: String!
    platform: PlatformType
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    role: DeviceRoleType
    serial: String!
    services(filters: ServiceFilter, pagination: OffsetPaginationInput): [ServiceType!]!
    site: SiteType
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vcpus: Decimal
    virtual_disk_count: Union!
    virtualdisks(filters: VirtualDiskFilter, pagination: OffsetPaginationInput): [VirtualDiskType!]!
}

"""

A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or
delete in NetBox. The request will contain a representation of the object, which the remote application can act on.
Each Webhook can be limited to firing only on certain actions or certain object types.
"""
type WebhookType {
    additional_headers: String!
    body_template: String!
    ca_file_path: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    http_content_type: String!
    http_method: String!
    id: ID!
    last_updated: DateTime
    name: String!
    payload_url: String!
    secret: String!
    ssl_verification: Boolean!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
}

"A nested grouping of WirelessLANs"
type WirelessLANGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: WirelessLANGroupFilter, pagination: OffsetPaginationInput): [WirelessLANGroupType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: WirelessLANGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tree_id: Int!
    wireless_lans(filters: WirelessLANFilter, pagination: OffsetPaginationInput): [WirelessLANType!]!
}

"A wireless network formed among an arbitrary number of access point and clients."
type WirelessLANType {
    auth_cipher: String
    auth_psk: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    group: WirelessLANGroupType
    id: ID!
    interfaces(filters: InterfaceFilter, pagination: OffsetPaginationInput): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    scope: WirelessLANScopeType
    ssid: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
    vlan: VLANType
}

"A point-to-point connection between two wireless Interfaces."
type WirelessLinkType {
    _abs_distance: Decimal
    _interface_a_device: DeviceType
    _interface_b_device: DeviceType
    auth_cipher: String
    auth_psk: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    distance: Decimal
    distance_unit: String
    id: ID!
    interface_a: InterfaceType!
    interface_b: InterfaceType!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    ssid: String!
    status: String!
    tags(filters: TagFilter, pagination: OffsetPaginationInput): [TagType!]!
    tenant: TenantType
}

enum AuthenticationAlgorithmEnum {
    AUTH_HMAC_MD5
    AUTH_HMAC_SHA1
    AUTH_HMAC_SHA256
    AUTH_HMAC_SHA384
    AUTH_HMAC_SHA512
}

enum AuthenticationMethodEnum {
    CERTIFICATES
    DSA_SIGNATURES
    PRESHARED_KEYS
    RSA_SIGNATURES
}

enum CableEndEnum {
    SIDE_A
    SIDE_B
}

enum CableLengthUnitEnum {
    UNIT_CM
    UNIT_FT
    UNIT_IN
    UNIT_KM
    UNIT_M
    UNIT_MI
}

enum CableTypeEnum {
    TYPE_AOC
    TYPE_CAT3
    TYPE_CAT5
    TYPE_CAT5E
    TYPE_CAT6
    TYPE_CAT6A
    TYPE_CAT7
    TYPE_CAT7A
    TYPE_CAT8
    TYPE_COAXIAL
    TYPE_DAC_ACTIVE
    TYPE_DAC_PASSIVE
    TYPE_MMF
    TYPE_MMF_OM1
    TYPE_MMF_OM2
    TYPE_MMF_OM3
    TYPE_MMF_OM4
    TYPE_MMF_OM5
    TYPE_MRJ21_TRUNK
    TYPE_POWER
    TYPE_SMF
    TYPE_SMF_OS1
    TYPE_SMF_OS2
    TYPE_USB
}

enum CircuitPriorityEnum {
    PRIORITY_INACTIVE
    PRIORITY_PRIMARY
    PRIORITY_SECONDARY
    PRIORITY_TERTIARY
}

enum CircuitTerminationSideEnum {
    SIDE_A
    SIDE_Z
}

enum ClusterStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_OFFLINE
    STATUS_PLANNED
    STATUS_STAGING
}

enum ColorEnum {
    COLOR_009688
    COLOR_00BCD4
    COLOR_00FFFF
    COLOR_03A9F4
    COLOR_111111
    COLOR_2196F3
    COLOR_2F6A31
    COLOR_3F51B5
    COLOR_4CAF50
    COLOR_607D8B
    COLOR_673AB7
    COLOR_795548
    COLOR_8BC34A
    COLOR_9C27B0
    COLOR_9E9E9E
    COLOR_AA1409
    COLOR_C0C0C0
    COLOR_CDDC39
    COLOR_E91E63
    COLOR_F44336
    COLOR_FF5722
    COLOR_FF66FF
    COLOR_FF9800
    COLOR_FFC107
    COLOR_FFE4E1
    COLOR_FFEB3B
    COLOR_FFFFFF
}

enum ConsolePortSpeedEnum {
    SPEED_115200
    SPEED_1200
    SPEED_19200
    SPEED_2400
    SPEED_38400
    SPEED_4800
    SPEED_57600
    SPEED_9600
}

enum ConsolePortTypeEnum {
    TYPE_DB_25
    TYPE_DE_9
    TYPE_MINI_DIN_8
    TYPE_OTHER
    TYPE_RJ_11
    TYPE_RJ_12
    TYPE_RJ_45
    TYPE_USB_A
    TYPE_USB_B
    TYPE_USB_C
    TYPE_USB_MICRO_A
    TYPE_USB_MICRO_AB
    TYPE_USB_MICRO_B
    TYPE_USB_MINI_A
    TYPE_USB_MINI_B
}

enum ContactPriorityEnum {
    PRIORITY_INACTIVE
    PRIORITY_PRIMARY
    PRIORITY_SECONDARY
    PRIORITY_TERTIARY
}

enum CustomFieldChoiceSetBaseEnum {
    IATA
    ISO_3166
    UN_LOCODE
}

enum CustomFieldFilterLogicEnum {
    FILTER_DISABLED
    FILTER_EXACT
    FILTER_LOOSE
}

enum CustomFieldTypeEnum {
    TYPE_BOOLEAN
    TYPE_DATE
    TYPE_DATETIME
    TYPE_DECIMAL
    TYPE_INTEGER
    TYPE_JSON
    TYPE_LONGTEXT
    TYPE_MULTIOBJECT
    TYPE_MULTISELECT
    TYPE_OBJECT
    TYPE_SELECT
    TYPE_TEXT
    TYPE_URL
}

enum CustomFieldUIEditableEnum {
    HIDDEN
    NO
    YES
}

enum CustomFieldUIVisibleEnum {
    ALWAYS
    HIDDEN
    IF_SET
}

enum CustomLinkButtonClassEnum {
    BLACK
    BLUE
    CYAN
    DEFAULT
    GHOST_DARK
    GRAY
    GREEN
    INDIGO
    ORANGE
    PINK
    PURPLE
    RED
    TEAL
    WHITE
    YELLOW
}

enum DHGroupEnum {
    GROUP_1
    GROUP_14
    GROUP_15
    GROUP_16
    GROUP_17
    GROUP_18
    GROUP_19
    GROUP_2
    GROUP_20
    GROUP_21
    GROUP_22
    GROUP_23
    GROUP_24
    GROUP_25
    GROUP_26
    GROUP_27
    GROUP_28
    GROUP_29
    GROUP_30
    GROUP_31
    GROUP_32
    GROUP_33
    GROUP_34
    GROUP_5
}

enum DeviceAirflowEnum {
    AIRFLOW_BOTTOM_TO_TOP
    AIRFLOW_FRONT_TO_REAR
    AIRFLOW_LEFT_TO_RIGHT
    AIRFLOW_MIXED
    AIRFLOW_PASSIVE
    AIRFLOW_REAR_TO_FRONT
    AIRFLOW_REAR_TO_SIDE
    AIRFLOW_RIGHT_TO_LEFT
    AIRFLOW_SIDE_TO_REAR
    AIRFLOW_TOP_TO_BOTTOM
}

enum DeviceFaceEnum {
    FACE_FRONT
    FACE_REAR
}

enum DeviceStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_FAILED
    STATUS_INVENTORY
    STATUS_OFFLINE
    STATUS_PLANNED
    STATUS_STAGED
}

enum DistanceUnitEnum {
    FT
    KM
    M
    MI
}

enum EncryptionAlgorithmEnum {
    ENCRYPTION_3DES_CBC
    ENCRYPTION_AES_128_CBC
    ENCRYPTION_AES_128_GCM
    ENCRYPTION_AES_192_CBC
    ENCRYPTION_AES_192_GCM
    ENCRYPTION_AES_256_CBC
    ENCRYPTION_AES_256_GCM
    ENCRYPTION_DES_CBC
}

enum EventRuleActionEnum {
    NOTIFICATION
    SCRIPT
    WEBHOOK
}

enum FHRPGroupAuthTypeEnum {
    AUTHENTICATION_MD5
    AUTHENTICATION_PLAINTEXT
}

enum FHRPGroupProtocolEnum {
    PROTOCOL_CARP
    PROTOCOL_CLUSTERXL
    PROTOCOL_GLBP
    PROTOCOL_HSRP
    PROTOCOL_OTHER
    PROTOCOL_VRRP2
    PROTOCOL_VRRP3
}

enum IKEModeEnum {
    AGGRESSIVE
    MAIN
}

enum IKEVersionEnum {
    VERSION_1
    VERSION_2
}

enum IPAddressRoleEnum {
    ROLE_ANYCAST
    ROLE_CARP
    ROLE_GLBP
    ROLE_HSRP
    ROLE_LOOPBACK
    ROLE_SECONDARY
    ROLE_VIP
    ROLE_VRRP
}

enum IPAddressStatusEnum {
    STATUS_ACTIVE
    STATUS_DEPRECATED
    STATUS_DHCP
    STATUS_RESERVED
    STATUS_SLAAC
}

enum IPRangeStatusEnum {
    STATUS_ACTIVE
    STATUS_DEPRECATED
    STATUS_RESERVED
}

enum IPSecModeEnum {
    AH
    ESP
}

enum InterfaceDuplexEnum {
    DUPLEX_AUTO
    DUPLEX_FULL
    DUPLEX_HALF
}

enum InterfaceModeEnum {
    MODE_ACCESS
    MODE_Q_IN_Q
    MODE_TAGGED
    MODE_TAGGED_ALL
}

enum InterfacePoEModeEnum {
    MODE_PD
    MODE_PSE
}

enum InterfacePoETypeEnum {
    PASSIVE_24V_2PAIR
    PASSIVE_24V_4PAIR
    PASSIVE_48V_2PAIR
    PASSIVE_48V_4PAIR
    TYPE1_IEEE802_3AF
    TYPE2_IEEE802_3AT
    TYPE3_IEEE802_3BT
    TYPE4_IEEE802_3BT
}

enum InterfaceTypeEnum {
    TYPE_1000BASE_KX
    TYPE_1000BASE_LX
    TYPE_1000BASE_SX
    TYPE_1000BASE_T
    TYPE_1000BASE_TX
    TYPE_1000BASE_X_GBIC
    TYPE_1000BASE_X_SFP
    TYPE_100BASE_FX
    TYPE_100BASE_LFX
    TYPE_100BASE_T1
    TYPE_100BASE_TX
    TYPE_100BASE_X_SFP
    TYPE_100GBASE_KP4
    TYPE_100GBASE_KR2
    TYPE_100GBASE_KR4
    TYPE_100GBASE_X_CFP
    TYPE_100GBASE_X_CFP2
    TYPE_100GBASE_X_CFP4
    TYPE_100GBASE_X_CPAK
    TYPE_100GBASE_X_CXP
    TYPE_100GBASE_X_DSFP
    TYPE_100GBASE_X_QSFP28
    TYPE_100GBASE_X_QSFPDD
    TYPE_100GBASE_X_SFPDD
    TYPE_10GBASE_CX4
    TYPE_10GBASE_KR
    TYPE_10GBASE_KX4
    TYPE_10GBASE_T
    TYPE_10GBASE_X_SFPP
    TYPE_10GBASE_X_X2
    TYPE_10GBASE_X_XENPAK
    TYPE_10GBASE_X_XFP
    TYPE_10G_EPON
    TYPE_128GFC_QSFP28
    TYPE_16GFC_SFPP
    TYPE_1GFC_SFP
    TYPE_200GBASE_X_CFP2
    TYPE_200GBASE_X_QSFP56
    TYPE_200GBASE_X_QSFPDD
    TYPE_25GBASE_KR
    TYPE_25GBASE_X_SFP28
    TYPE_25G_PON
    TYPE_2GFC_SFP
    TYPE_2_5GBASE_KX
    TYPE_2_5GBASE_T
    TYPE_32GFC_SFP28
    TYPE_32GFC_SFPP
    TYPE_400GBASE_X_CDFP
    TYPE_400GBASE_X_CFP2
    TYPE_400GBASE_X_CFP8
    TYPE_400GBASE_X_OSFP
    TYPE_400GBASE_X_OSFP_RHS
    TYPE_400GBASE_X_QSFP112
    TYPE_400GBASE_X_QSFPDD
    TYPE_40GBASE_KR4
    TYPE_40GBASE_X_QSFPP
    TYPE_4G
    TYPE_4GFC_SFP
    TYPE_50GBASE_KR
    TYPE_50GBASE_X_SFP28
    TYPE_50GBASE_X_SFP56
    TYPE_50G_PON
    TYPE_5G
    TYPE_5GBASE_KR
    TYPE_5GBASE_T
    TYPE_64GFC_QSFPP
    TYPE_64GFC_SFPDD
    TYPE_64GFC_SFPP
    TYPE_800GBASE_X_OSFP
    TYPE_800GBASE_X_QSFPDD
    TYPE_8GFC_SFPP
    TYPE_BPON
    TYPE_BRIDGE
    TYPE_CDMA
    TYPE_CISCO_FLEXSTACK
    TYPE_CISCO_FLEXSTACK_PLUS
    TYPE_CISCO_STACKWISE
    TYPE_CISCO_STACKWISE_160
    TYPE_CISCO_STACKWISE_1T
    TYPE_CISCO_STACKWISE_320
    TYPE_CISCO_STACKWISE_480
    TYPE_CISCO_STACKWISE_80
    TYPE_CISCO_STACKWISE_PLUS
    TYPE_DOCSIS
    TYPE_E1
    TYPE_E3
    TYPE_EPON
    TYPE_EXTREME_SUMMITSTACK
    TYPE_EXTREME_SUMMITSTACK_128
    TYPE_EXTREME_SUMMITSTACK_256
    TYPE_EXTREME_SUMMITSTACK_512
    TYPE_GPON
    TYPE_GSM
    TYPE_IEEE802_11A
    TYPE_IEEE802_11AC
    TYPE_IEEE802_11AD
    TYPE_IEEE802_11AX
    TYPE_IEEE802_11AY
    TYPE_IEEE802_11BE
    TYPE_IEEE802_11G
    TYPE_IEEE802_11N
    TYPE_IEEE802_15_1
    TYPE_IEEE802_15_4
    TYPE_INFINIBAND_DDR
    TYPE_INFINIBAND_EDR
    TYPE_INFINIBAND_FDR
    TYPE_INFINIBAND_FDR10
    TYPE_INFINIBAND_HDR
    TYPE_INFINIBAND_NDR
    TYPE_INFINIBAND_QDR
    TYPE_INFINIBAND_SDR
    TYPE_INFINIBAND_XDR
    TYPE_JUNIPER_VCP
    TYPE_LAG
    TYPE_LTE
    TYPE_MOCA
    TYPE_NG_PON2
    TYPE_OTHER
    TYPE_OTHER_WIRELESS
    TYPE_SONET_OC12
    TYPE_SONET_OC192
    TYPE_SONET_OC1920
    TYPE_SONET_OC3
    TYPE_SONET_OC3840
    TYPE_SONET_OC48
    TYPE_SONET_OC768
    TYPE_T1
    TYPE_T3
    TYPE_VIRTUAL
    TYPE_XDSL
    TYPE_XGS_PON
    TYPE_XG_PON
}

enum InventoryItemStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_FAILED
    STATUS_OFFLINE
    STATUS_PLANNED
    STATUS_STAGED
}

enum JournalEntryKindEnum {
    KIND_DANGER
    KIND_INFO
    KIND_SUCCESS
    KIND_WARNING
}

enum L2VPNTypeEnum {
    TYPE_EPL
    TYPE_EP_LAN
    TYPE_EP_TREE
    TYPE_EVPL
    TYPE_EVPN_VPWS
    TYPE_EVP_LAN
    TYPE_EVP_TREE
    TYPE_MPLS_EVPN
    TYPE_PBB_EVPN
    TYPE_SPB
    TYPE_VPLS
    TYPE_VPWS
    TYPE_VXLAN
    TYPE_VXLAN_EVPN
}

enum LinkStatusEnum {
    STATUS_CONNECTED
    STATUS_DECOMMISSIONING
    STATUS_PLANNED
}

enum LocationStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_PLANNED
    STATUS_RETIRED
    STATUS_STAGING
}

enum ModuleAirflowEnum {
    FRONT_TO_REAR
    LEFT_TO_RIGHT
    PASSIVE
    REAR_TO_FRONT
    RIGHT_TO_LEFT
    SIDE_TO_REAR
}

enum ModuleStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_FAILED
    STATUS_OFFLINE
    STATUS_PLANNED
    STATUS_STAGED
}

enum PortTypeEnum {
    TYPE_110_PUNCH
    TYPE_4P2C
    TYPE_4P4C
    TYPE_6P2C
    TYPE_6P4C
    TYPE_6P6C
    TYPE_8P2C
    TYPE_8P4C
    TYPE_8P6C
    TYPE_8P8C
    TYPE_BNC
    TYPE_CS
    TYPE_F
    TYPE_FC
    TYPE_FC_APC
    TYPE_FC_PC
    TYPE_FC_UPC
    TYPE_GG45
    TYPE_LC
    TYPE_LC_APC
    TYPE_LC_PC
    TYPE_LC_UPC
    TYPE_LSH
    TYPE_LSH_APC
    TYPE_LSH_PC
    TYPE_LSH_UPC
    TYPE_LX5
    TYPE_LX5_APC
    TYPE_LX5_PC
    TYPE_LX5_UPC
    TYPE_MPO
    TYPE_MRJ21
    TYPE_MTRJ
    TYPE_N
    TYPE_OTHER
    TYPE_SC
    TYPE_SC_APC
    TYPE_SC_PC
    TYPE_SC_UPC
    TYPE_SMA_905
    TYPE_SMA_906
    TYPE_SN
    TYPE_SPLICE
    TYPE_ST
    TYPE_TERA_1P
    TYPE_TERA_2P
    TYPE_TERA_4P
    TYPE_URM_P2
    TYPE_URM_P4
    TYPE_URM_P8
    TYPE_USB_A
    TYPE_USB_B
    TYPE_USB_C
    TYPE_USB_MICRO_A
    TYPE_USB_MICRO_AB
    TYPE_USB_MICRO_B
    TYPE_USB_MINI_A
    TYPE_USB_MINI_B
}

enum PowerFeedPhaseEnum {
    PHASE_SINGLE_PHASE
    PHASE_THREE_PHASE
}

enum PowerFeedStatusEnum {
    STATUS_ACTIVE
    STATUS_FAILED
    STATUS_OFFLINE
    STATUS_PLANNED
}

enum PowerFeedSupplyEnum {
    SUPPLY_AC
    SUPPLY_DC
}

enum PowerFeedTypeEnum {
    TYPE_PRIMARY
    TYPE_REDUNDANT
}

enum PowerOutletFeedLegEnum {
    FEED_LEG_A
    FEED_LEG_B
    FEED_LEG_C
}

enum PowerOutletTypeEnum {
    TYPE_CS6360C
    TYPE_CS6364C
    TYPE_CS8164C
    TYPE_CS8264C
    TYPE_CS8364C
    TYPE_CS8464C
    TYPE_DC_TERMINAL
    TYPE_EATON_C39
    TYPE_HARDWIRED
    TYPE_HDOT_CX
    TYPE_IEC_60309_2P_E_4H
    TYPE_IEC_60309_2P_E_6H
    TYPE_IEC_60309_2P_E_9H
    TYPE_IEC_60309_3P_E_4H
    TYPE_IEC_60309_3P_E_6H
    TYPE_IEC_60309_3P_E_9H
    TYPE_IEC_60309_3P_N_E_4H
    TYPE_IEC_60309_3P_N_E_6H
    TYPE_IEC_60309_3P_N_E_9H
    TYPE_IEC_60309_P_N_E_4H
    TYPE_IEC_60309_P_N_E_6H
    TYPE_IEC_60309_P_N_E_9H
    TYPE_IEC_60320_C13
    TYPE_IEC_60320_C15
    TYPE_IEC_60320_C19
    TYPE_IEC_60320_C21
    TYPE_IEC_60320_C5
    TYPE_IEC_60320_C7
    TYPE_IEC_60906_1
    TYPE_ITA_E
    TYPE_ITA_F
    TYPE_ITA_G
    TYPE_ITA_H
    TYPE_ITA_I
    TYPE_ITA_J
    TYPE_ITA_K
    TYPE_ITA_L
    TYPE_ITA_M
    TYPE_ITA_MULTISTANDARD
    TYPE_ITA_N
    TYPE_ITA_O
    TYPE_MOLEX_MICRO_FIT_1X2
    TYPE_MOLEX_MICRO_FIT_2X2
    TYPE_MOLEX_MICRO_FIT_2X4
    TYPE_NBR_14136_10A
    TYPE_NBR_14136_20A
    TYPE_NEMA_10_30R
    TYPE_NEMA_10_50R
    TYPE_NEMA_14_20R
    TYPE_NEMA_14_30R
    TYPE_NEMA_14_50R
    TYPE_NEMA_14_60R
    TYPE_NEMA_15_15R
    TYPE_NEMA_15_20R
    TYPE_NEMA_15_30R
    TYPE_NEMA_15_50R
    TYPE_NEMA_15_60R
    TYPE_NEMA_1_15R
    TYPE_NEMA_5_15R
    TYPE_NEMA_5_20R
    TYPE_NEMA_5_30R
    TYPE_NEMA_5_50R
    TYPE_NEMA_6_15R
    TYPE_NEMA_6_20R
    TYPE_NEMA_6_30R
    TYPE_NEMA_6_50R
    TYPE_NEMA_L10_30R
    TYPE_NEMA_L14_20R
    TYPE_NEMA_L14_30R
    TYPE_NEMA_L14_50R
    TYPE_NEMA_L14_60R
    TYPE_NEMA_L15_20R
    TYPE_NEMA_L15_30R
    TYPE_NEMA_L15_50R
    TYPE_NEMA_L15_60R
    TYPE_NEMA_L1_15R
    TYPE_NEMA_L21_20R
    TYPE_NEMA_L21_30R
    TYPE_NEMA_L22_20R
    TYPE_NEMA_L22_30R
    TYPE_NEMA_L5_15R
    TYPE_NEMA_L5_20R
    TYPE_NEMA_L5_30R
    TYPE_NEMA_L5_50R
    TYPE_NEMA_L6_15R
    TYPE_NEMA_L6_20R
    TYPE_NEMA_L6_30R
    TYPE_NEMA_L6_50R
    TYPE_NEUTRIK_POWERCON_20A
    TYPE_NEUTRIK_POWERCON_32A
    TYPE_NEUTRIK_POWERCON_TRUE1
    TYPE_NEUTRIK_POWERCON_TRUE1_TOP
    TYPE_OTHER
    TYPE_SAF_D_GRID
    TYPE_UBIQUITI_SMARTPOWER
    TYPE_USB_A
    TYPE_USB_C
    TYPE_USB_MICRO_B
}

enum PowerPortTypeEnum {
    TYPE_CS6361C
    TYPE_CS6365C
    TYPE_CS8165C
    TYPE_CS8265C
    TYPE_CS8365C
    TYPE_CS8465C
    TYPE_DC_TERMINAL
    TYPE_HARDWIRED
    TYPE_IEC_60309_2P_E_4H
    TYPE_IEC_60309_2P_E_6H
    TYPE_IEC_60309_2P_E_9H
    TYPE_IEC_60309_3P_E_4H
    TYPE_IEC_60309_3P_E_6H
    TYPE_IEC_60309_3P_E_9H
    TYPE_IEC_60309_3P_N_E_4H
    TYPE_IEC_60309_3P_N_E_6H
    TYPE_IEC_60309_3P_N_E_9H
    TYPE_IEC_60309_P_N_E_4H
    TYPE_IEC_60309_P_N_E_6H
    TYPE_IEC_60309_P_N_E_9H
    TYPE_IEC_60320_C14
    TYPE_IEC_60320_C16
    TYPE_IEC_60320_C20
    TYPE_IEC_60320_C22
    TYPE_IEC_60320_C6
    TYPE_IEC_60320_C8
    TYPE_IEC_60906_1
    TYPE_ITA_C
    TYPE_ITA_E
    TYPE_ITA_EF
    TYPE_ITA_F
    TYPE_ITA_G
    TYPE_ITA_H
    TYPE_ITA_I
    TYPE_ITA_J
    TYPE_ITA_K
    TYPE_ITA_L
    TYPE_ITA_M
    TYPE_ITA_N
    TYPE_ITA_O
    TYPE_MOLEX_MICRO_FIT_1X2
    TYPE_MOLEX_MICRO_FIT_2X2
    TYPE_MOLEX_MICRO_FIT_2X4
    TYPE_NBR_14136_10A
    TYPE_NBR_14136_20A
    TYPE_NEMA_10_30P
    TYPE_NEMA_10_50P
    TYPE_NEMA_14_20P
    TYPE_NEMA_14_30P
    TYPE_NEMA_14_50P
    TYPE_NEMA_14_60P
    TYPE_NEMA_15_15P
    TYPE_NEMA_15_20P
    TYPE_NEMA_15_30P
    TYPE_NEMA_15_50P
    TYPE_NEMA_15_60P
    TYPE_NEMA_1_15P
    TYPE_NEMA_5_15P
    TYPE_NEMA_5_20P
    TYPE_NEMA_5_30P
    TYPE_NEMA_5_50P
    TYPE_NEMA_6_15P
    TYPE_NEMA_6_20P
    TYPE_NEMA_6_30P
    TYPE_NEMA_6_50P
    TYPE_NEMA_L10_30P
    TYPE_NEMA_L14_20P
    TYPE_NEMA_L14_30P
    TYPE_NEMA_L14_50P
    TYPE_NEMA_L14_60P
    TYPE_NEMA_L15_20P
    TYPE_NEMA_L15_30P
    TYPE_NEMA_L15_50P
    TYPE_NEMA_L15_60P
    TYPE_NEMA_L1_15P
    TYPE_NEMA_L21_20P
    TYPE_NEMA_L21_30P
    TYPE_NEMA_L22_20P
    TYPE_NEMA_L22_30P
    TYPE_NEMA_L5_15P
    TYPE_NEMA_L5_20P
    TYPE_NEMA_L5_30P
    TYPE_NEMA_L5_50P
    TYPE_NEMA_L6_15P
    TYPE_NEMA_L6_20P
    TYPE_NEMA_L6_30P
    TYPE_NEMA_L6_50P
    TYPE_NEUTRIK_POWERCON_20
    TYPE_NEUTRIK_POWERCON_32
    TYPE_NEUTRIK_POWERCON_TRUE1
    TYPE_NEUTRIK_POWERCON_TRUE1_TOP
    TYPE_OTHER
    TYPE_SAF_D_GRID
    TYPE_UBIQUITI_SMARTPOWER
    TYPE_USB_3_B
    TYPE_USB_3_MICRO_B
    TYPE_USB_A
    TYPE_USB_B
    TYPE_USB_C
    TYPE_USB_MICRO_A
    TYPE_USB_MICRO_AB
    TYPE_USB_MICRO_B
    TYPE_USB_MINI_A
    TYPE_USB_MINI_B
}

enum PrefixStatusEnum {
    STATUS_ACTIVE
    STATUS_CONTAINER
    STATUS_DEPRECATED
    STATUS_RESERVED
}

enum RackAirflowEnum {
    FRONT_TO_REAR
    REAR_TO_FRONT
}

enum RackDimensionUnitEnum {
    UNIT_IN
    UNIT_MM
}

enum RackFormFactorEnum {
    TYPE_2_POST_FRAME
    TYPE_4_POST_CABINET
    TYPE_4_POST_FRAME
    TYPE_WALL_CABINET
    TYPE_WALL_CABINET_VERTICAL
    TYPE_WALL_FRAME
    TYPE_WALL_FRAME_VERTICAL
}

enum RackStatusEnum {
    STATUS_ACTIVE
    STATUS_AVAILABLE
    STATUS_DEPRECATED
    STATUS_PLANNED
    STATUS_RESERVED
}

enum RackWidthEnum {
    WIDTH_10
    WIDTH_19
    WIDTH_21
    WIDTH_23
}

enum ServiceProtocolEnum {
    ROLE_SCTP
    ROLE_TCP
    ROLE_UDP
}

enum SiteStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_PLANNED
    STATUS_RETIRED
    STATUS_STAGING
}

enum SubdeviceRoleEnum {
    ROLE_CHILD
    ROLE_PARENT
}

enum TreeNodeMatch {
    ANCESTORS
    CHILDREN
    DESCENDANTS
    EXACT
    PARENT
    SELF_AND_DESCENDANTS
    SIBLINGS
}

enum TunnelEncapsulationEnum {
    ENCAP_GRE
    ENCAP_IPSEC_TRANSPORT
    ENCAP_IPSEC_TUNNEL
    ENCAP_IP_IP
    ENCAP_L2TP
    ENCAP_OPENVPN
    ENCAP_PPTP
    ENCAP_WIREGUARD
}

enum TunnelStatusEnum {
    STATUS_ACTIVE
    STATUS_DISABLED
    STATUS_PLANNED
}

enum TunnelTerminationRoleEnum {
    ROLE_HUB
    ROLE_PEER
    ROLE_SPOKE
}

enum TunnelTerminationTypeEnum {
    TYPE_DCIM_DEVICE
    TYPE_VIRTUALIZATION_VIRTUALMACHINE
}

enum VLANQinQRoleEnum {
    ROLE_CVLAN
    ROLE_SVLAN
}

enum VLANStatusEnum {
    STATUS_ACTIVE
    STATUS_DEPRECATED
    STATUS_RESERVED
}

enum VirtualCircuitTerminationRoleEnum {
    ROLE_HUB
    ROLE_PEER
    ROLE_SPOKE
}

enum VirtualDeviceContextStatusEnum {
    STATUS_ACTIVE
    STATUS_OFFLINE
    STATUS_PLANNED
}

enum VirtualMachineStatusEnum {
    STATUS_ACTIVE
    STATUS_DECOMMISSIONING
    STATUS_FAILED
    STATUS_OFFLINE
    STATUS_PAUSED
    STATUS_PLANNED
    STATUS_STAGED
}

enum WebhookHttpMethodEnum {
    DELETE
    GET
    PATCH
    POST
    PUT
}

enum WeightUnitEnum {
    G
    KG
    LB
    OZ
}

enum WirelessAuthCipherEnum {
    CIPHER_AES
    CIPHER_AUTO
    CIPHER_TKIP
}

enum WirelessAuthTypeEnum {
    TYPE_OPEN
    TYPE_WEP
    TYPE_WPA_ENTERPRISE
    TYPE_WPA_PERSONAL
}

enum WirelessChannelEnum {
    CHANNEL_2_4G_10_2457_22
    CHANNEL_2_4G_11_2462_22
    CHANNEL_2_4G_12_2467_22
    CHANNEL_2_4G_13_2472_22
    CHANNEL_2_4G_1_2412_22
    CHANNEL_2_4G_2_2417_22
    CHANNEL_2_4G_3_2422_22
    CHANNEL_2_4G_4_2427_22
    CHANNEL_2_4G_5_2432_22
    CHANNEL_2_4G_6_2437_22
    CHANNEL_2_4G_7_2442_22
    CHANNEL_2_4G_8_2447_22
    CHANNEL_2_4G_9_2452_22
    CHANNEL_5G_100_5500_20
    CHANNEL_5G_102_5510_40
    CHANNEL_5G_104_5520_20
    CHANNEL_5G_106_5530_80
    CHANNEL_5G_108_5540_20
    CHANNEL_5G_110_5550_40
    CHANNEL_5G_112_5560_20
    CHANNEL_5G_114_5570_160
    CHANNEL_5G_116_5580_20
    CHANNEL_5G_118_5590_40
    CHANNEL_5G_120_5600_20
    CHANNEL_5G_122_5610_80
    CHANNEL_5G_124_5620_20
    CHANNEL_5G_126_5630_40
    CHANNEL_5G_128_5640_20
    CHANNEL_5G_132_5660_20
    CHANNEL_5G_134_5670_40
    CHANNEL_5G_136_5680_20
    CHANNEL_5G_138_5690_80
    CHANNEL_5G_140_5700_20
    CHANNEL_5G_142_5710_40
    CHANNEL_5G_144_5720_20
    CHANNEL_5G_149_5745_20
    CHANNEL_5G_151_5755_40
    CHANNEL_5G_153_5765_20
    CHANNEL_5G_155_5775_80
    CHANNEL_5G_157_5785_20
    CHANNEL_5G_159_5795_40
    CHANNEL_5G_161_5805_20
    CHANNEL_5G_163_5815_160
    CHANNEL_5G_165_5825_20
    CHANNEL_5G_167_5835_40
    CHANNEL_5G_169_5845_20
    CHANNEL_5G_171_5855_80
    CHANNEL_5G_173_5865_20
    CHANNEL_5G_175_5875_40
    CHANNEL_5G_177_5885_20
    CHANNEL_5G_32_5160_20
    CHANNEL_5G_34_5170_40
    CHANNEL_5G_36_5180_20
    CHANNEL_5G_38_5190_40
    CHANNEL_5G_40_5200_20
    CHANNEL_5G_42_5210_80
    CHANNEL_5G_44_5220_20
    CHANNEL_5G_46_5230_40
    CHANNEL_5G_48_5240_20
    CHANNEL_5G_50_5250_160
    CHANNEL_5G_52_5260_20
    CHANNEL_5G_54_5270_40
    CHANNEL_5G_56_5280_20
    CHANNEL_5G_58_5290_80
    CHANNEL_5G_60_5300_20
    CHANNEL_5G_62_5310_40
    CHANNEL_5G_64_5320_20
    CHANNEL_60G_10_61560_4320
    CHANNEL_60G_11_63720_4320
    CHANNEL_60G_12_65880_4320
    CHANNEL_60G_13_68040_4320
    CHANNEL_60G_17_60480_6480
    CHANNEL_60G_18_62640_6480
    CHANNEL_60G_19_64800_6480
    CHANNEL_60G_1_58320_2160
    CHANNEL_60G_20_66960_6480
    CHANNEL_60G_25_61560_6480
    CHANNEL_60G_26_63720_6480
    CHANNEL_60G_27_65880_6480
    CHANNEL_60G_2_60480_2160
    CHANNEL_60G_3_62640_2160
    CHANNEL_60G_4_64800_2160
    CHANNEL_60G_5_66960_2160
    CHANNEL_60G_6_69120_2160
    CHANNEL_60G_9_59400_4320
    CHANNEL_6G_101_6455_20
    CHANNEL_6G_103_6465_80
    CHANNEL_6G_105_6475_20
    CHANNEL_6G_107_6485_40
    CHANNEL_6G_109_6495_20
    CHANNEL_6G_111_6505_160
    CHANNEL_6G_113_6515_20
    CHANNEL_6G_115_6525_40
    CHANNEL_6G_117_6535_20
    CHANNEL_6G_119_6545_80
    CHANNEL_6G_11_6005_40
    CHANNEL_6G_121_6555_20
    CHANNEL_6G_123_6565_40
    CHANNEL_6G_125_6575_20
    CHANNEL_6G_129_6595_20
    CHANNEL_6G_131_6605_40
    CHANNEL_6G_133_6615_20
    CHANNEL_6G_135_6625_80
    CHANNEL_6G_137_6635_20
    CHANNEL_6G_139_6645_40
    CHANNEL_6G_13_6015_20
    CHANNEL_6G_141_6655_20
    CHANNEL_6G_143_6665_160
    CHANNEL_6G_145_6675_20
    CHANNEL_6G_147_6685_40
    CHANNEL_6G_149_6695_20
    CHANNEL_6G_151_6705_80
    CHANNEL_6G_153_6715_20
    CHANNEL_6G_155_6725_40
    CHANNEL_6G_157_6735_20
    CHANNEL_6G_159_6745_320
    CHANNEL_6G_15_6025_160
    CHANNEL_6G_161_6755_20
    CHANNEL_6G_163_6765_40
    CHANNEL_6G_165_6775_20
    CHANNEL_6G_167_6785_80
    CHANNEL_6G_169_6795_20
    CHANNEL_6G_171_6805_40
    CHANNEL_6G_173_6815_20
    CHANNEL_6G_175_6825_160
    CHANNEL_6G_177_6835_20
    CHANNEL_6G_179_6845_40
    CHANNEL_6G_17_6035_20
    CHANNEL_6G_181_6855_20
    CHANNEL_6G_183_6865_80
    CHANNEL_6G_185_6875_20
    CHANNEL_6G_187_6885_40
    CHANNEL_6G_189_6895_20
    CHANNEL_6G_193_6915_20
    CHANNEL_6G_195_6925_40
    CHANNEL_6G_197_6935_20
    CHANNEL_6G_199_6945_80
    CHANNEL_6G_19_6045_40
    CHANNEL_6G_1_5955_20
    CHANNEL_6G_201_6955_20
    CHANNEL_6G_203_6965_40
    CHANNEL_6G_205_6975_20
    CHANNEL_6G_207_6985_160
    CHANNEL_6G_209_6995_20
    CHANNEL_6G_211_7005_40
    CHANNEL_6G_213_7015_20
    CHANNEL_6G_215_7025_80
    CHANNEL_6G_217_7035_20
    CHANNEL_6G_219_7045_40
    CHANNEL_6G_21_6055_20
    CHANNEL_6G_221_7055_20
    CHANNEL_6G_225_7075_20
    CHANNEL_6G_227_7085_40
    CHANNEL_6G_229_7095_20
    CHANNEL_6G_233_7115_20
    CHANNEL_6G_23_6065_80
    CHANNEL_6G_25_6075_20
    CHANNEL_6G_27_6085_40
    CHANNEL_6G_29_6095_20
    CHANNEL_6G_31_6105_320
    CHANNEL_6G_33_6115_20
    CHANNEL_6G_35_6125_40
    CHANNEL_6G_37_6135_20
    CHANNEL_6G_39_6145_80
    CHANNEL_6G_3_5965_40
    CHANNEL_6G_41_6155_20
    CHANNEL_6G_43_6165_40
    CHANNEL_6G_45_6175_20
    CHANNEL_6G_47_6185_160
    CHANNEL_6G_49_6195_20
    CHANNEL_6G_51_6205_40
    CHANNEL_6G_53_6215_20
    CHANNEL_6G_55_6225_80
    CHANNEL_6G_57_6235_20
    CHANNEL_6G_59_6245_40
    CHANNEL_6G_5_5975_20
    CHANNEL_6G_61_6255_20
    CHANNEL_6G_65_6275_20
    CHANNEL_6G_67_6285_40
    CHANNEL_6G_69_6295_20
    CHANNEL_6G_71_6305_80
    CHANNEL_6G_73_6315_20
    CHANNEL_6G_75_6325_40
    CHANNEL_6G_77_6335_20
    CHANNEL_6G_79_6345_160
    CHANNEL_6G_7_5985_80
    CHANNEL_6G_81_6355_20
    CHANNEL_6G_83_6365_40
    CHANNEL_6G_85_6375_20
    CHANNEL_6G_87_6385_80
    CHANNEL_6G_89_6395_20
    CHANNEL_6G_91_6405_40
    CHANNEL_6G_93_6415_20
    CHANNEL_6G_95_6425_320
    CHANNEL_6G_97_6435_20
    CHANNEL_6G_99_6445_40
    CHANNEL_6G_9_5995_20
}

enum WirelessLANStatusEnum {
    STATUS_ACTIVE
    STATUS_DEPRECATED
    STATUS_DISABLED
    STATUS_RESERVED
}

enum WirelessRoleEnum {
    ROLE_AP
    ROLE_STATION
}

enum status {
    ACTIVE
    DECOMMISSIONED
    DEPROVISIONING
    OFFLINE
    PLANNED
    PROVISIONING
}

"Date (isoformat)"
scalar Date

"Date with time (isoformat)"
scalar DateTime

"Decimal (fixed-point)"
scalar Decimal

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf)."
scalar JSON

scalar UUID

"BigInt field"
scalar Union

"""

An autonomous system (AS) number is typically used to represent an independent routing domain. A site can have
one or more ASNs assigned to it.
"""
input ASNFilter {
    AND: ASNFilter
    DISTINCT: Boolean
    NOT: ASNFilter
    OR: ASNFilter
    asn: IntegerLookup
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    providers: ProviderFilter
    rir: RIRFilter
    rir_id: ID
    sites: SiteFilter
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"ASNRange(id, created, last_updated, custom_field_data, description, name, slug, rir, start, end, tenant)"
input ASNRangeFilter {
    AND: ASNRangeFilter
    DISTINCT: Boolean
    NOT: ASNRangeFilter
    OR: ASNRangeFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    end: IntegerLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    rir: RIRFilter
    rir_id: ID
    slug: StrFilterLookup
    start: IntegerLookup
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"""

An aggregate exists at the root level of the IP address space hierarchy in NetBox. Aggregates are used to organize
the hierarchy and track the overall utilization of available address space. Each Aggregate is assigned to a RIR.
"""
input AggregateFilter {
    AND: AggregateFilter
    DISTINCT: Boolean
    NOT: AggregateFilter
    OR: AggregateFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    date_added: DateDateFilterLookup
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    prefix: PrefixFilter
    prefix_id: ID
    rir: RIRFilter
    rir_id: ID
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

input BoolFilterLookup {
    "Case-sensitive containment test. Filter will be skipped on `null` value"
    contains: Boolean
    "Case-sensitive ends-with. Filter will be skipped on `null` value"
    ends_with: Boolean
    "Exact match. Filter will be skipped on `null` value"
    exact: Boolean
    "Case-insensitive containment test. Filter will be skipped on `null` value"
    i_contains: Boolean
    "Case-insensitive ends-with. Filter will be skipped on `null` value"
    i_ends_with: Boolean
    "Case-insensitive exact match. Filter will be skipped on `null` value"
    i_exact: Boolean
    "Case-insensitive regular expression match. Filter will be skipped on `null` value"
    i_regex: Boolean
    "Case-insensitive starts-with. Filter will be skipped on `null` value"
    i_starts_with: Boolean
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Boolean!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Case-sensitive regular expression match. Filter will be skipped on `null` value"
    regex: Boolean
    "Case-sensitive starts-with. Filter will be skipped on `null` value"
    starts_with: Boolean
}

"A physical connection between two endpoints."
input CableFilter {
    AND: CableFilter
    DISTINCT: Boolean
    NOT: CableFilter
    OR: CableFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    length: FloatLookup
    length_unit: CableLengthUnitEnum
    status: LinkStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    terminations: CableTerminationFilter
    type: CableTypeEnum
}

"A mapping between side A or B of a Cable and a terminating object (e.g. an Interface or CircuitTermination)."
input CableTerminationFilter {
    AND: CableTerminationFilter
    DISTINCT: Boolean
    NOT: CableTerminationFilter
    OR: CableTerminationFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    termination_id: ID
    termination_type: CableTerminationFilter
}

"""

A communications circuit connects two points. Each Circuit belongs to a Provider; Providers may have multiple
circuits. Each circuit is also assigned a CircuitType and a Site, and may optionally be assigned to a particular
ProviderAccount. Circuit port speed and commit rate are measured in Kbps.
"""
input CircuitFilter {
    AND: CircuitFilter
    DISTINCT: Boolean
    NOT: CircuitFilter
    OR: CircuitFilter
    changelog: ObjectChangeFilter
    cid: StrFilterLookup
    comments: StrFilterLookup
    commit_rate: IntegerLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    distance: FloatFilterLookup
    distance_unit: DistanceUnitEnum
    id: ID
    images: ImageAttachmentFilter
    install_date: DateDateFilterLookup
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    provider: ProviderFilter
    provider_account: ProviderAccountFilter
    provider_account_id: ID
    provider_id: ID
    status: status
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    termination_date: DateDateFilterLookup
    terminations: CircuitTerminationFilter
    type: CircuitTypeFilter
    type_id: ID
}

"Assignment of a physical or virtual circuit to a CircuitGroup with an optional priority."
input CircuitGroupAssignmentFilter {
    AND: CircuitGroupAssignmentFilter
    DISTINCT: Boolean
    NOT: CircuitGroupAssignmentFilter
    OR: CircuitGroupAssignmentFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    group: CircuitGroupFilter
    group_id: ID
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    member_id: ID
    member_type: ContentTypeFilter
    priority: CircuitPriorityEnum
    tags: TagFilter
}

"An administrative grouping of Circuits."
input CircuitGroupFilter {
    AND: CircuitGroupFilter
    DISTINCT: Boolean
    NOT: CircuitGroupFilter
    OR: CircuitGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"CircuitTermination(id, created, last_updated, custom_field_data, cable, cable_end, mark_connected, circuit, term_side, termination_type, termination_id, port_speed, upstream_speed, xconnect_id, pp_info, description, _provider_network, _location, _site, _region, _site_group)"
input CircuitTerminationFilter {
    AND: CircuitTerminationFilter
    DISTINCT: Boolean
    NOT: CircuitTerminationFilter
    OR: CircuitTerminationFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    circuit: CircuitFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    location: LocationFilter
    mark_connected: BoolFilterLookup
    port_speed: IntegerLookup
    pp_info: StrFilterLookup
    provider_network: ProviderNetworkFilter
    region: RegionFilter
    site: SiteFilter
    site_group: SiteGroupFilter
    tags: TagFilter
    term_side: CircuitTerminationSideEnum
    termination_id: ID
    termination_type: ContentTypeFilter
    upstream_speed: IntegerLookup
    xconnect_id: StrFilterLookup
}

"""

Circuits can be organized by their functional role. For example, a user might wish to define CircuitTypes named
"Long Haul," "Metro," or "Out-of-Band".
"""
input CircuitTypeFilter {
    AND: CircuitTypeFilter
    DISTINCT: Boolean
    NOT: CircuitTypeFilter
    OR: CircuitTypeFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"A cluster of VirtualMachines. Each Cluster may optionally be associated with one or more Devices."
input ClusterFilter {
    AND: ClusterFilter
    DISTINCT: Boolean
    NOT: ClusterFilter
    OR: ClusterFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    group: ClusterGroupFilter
    group_id: ID
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    scope_id: ID
    scope_type: ContentTypeFilter
    status: ClusterStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    type: ClusterTypeFilter
    type_id: ID
    vlan_groups: VLANGroupFilter
}

"An organizational group of Clusters."
input ClusterGroupFilter {
    AND: ClusterGroupFilter
    DISTINCT: Boolean
    NOT: ClusterGroupFilter
    OR: ClusterGroupFilter
    changelog: ObjectChangeFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
    vlan_groups: VLANGroupFilter
}

"A type of Cluster."
input ClusterTypeFilter {
    AND: ClusterTypeFilter
    DISTINCT: Boolean
    NOT: ClusterTypeFilter
    OR: ClusterTypeFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"""

A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned
qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B
will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.
"""
input ConfigContextFilter {
    AND: ConfigContextFilter
    DISTINCT: Boolean
    NOT: ConfigContextFilter
    OR: ConfigContextFilter
    auto_sync_enabled: BoolFilterLookup
    changelog: ObjectChangeFilter
    cluster_groups: ClusterGroupFilter
    cluster_types: ClusterTypeFilter
    clusters: ClusterFilter
    created: DatetimeDatetimeFilterLookup
    data: JSONFilter
    data_file: DataFileFilter
    data_file_id: IntFilterLookup
    data_path: StrFilterLookup
    data_source: DataSourceFilter
    data_source_id: IntFilterLookup
    data_synced: DatetimeDatetimeFilterLookup
    description: StrFilterLookup!
    device_types: DeviceTypeFilter
    id: ID
    is_active: BoolFilterLookup!
    last_updated: DatetimeDatetimeFilterLookup
    locations: LocationFilter
    name: StrFilterLookup!
    platforms: PlatformFilter
    region_id: TreeNodeFilter
    regions: RegionFilter
    roles: DeviceRoleFilter
    site_group_id: TreeNodeFilter
    site_groups: SiteGroupFilter
    sites: SiteFilter
    tags: TagFilter
    tenant_group_id: TreeNodeFilter
    tenant_groups: TenantGroupFilter
    tenants: TenantFilter
    weight: IntegerLookup
}

"ConfigTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, template_code, environment_params, mime_type, file_name, file_extension, as_attachment, name, description)"
input ConfigTemplateFilter {
    AND: ConfigTemplateFilter
    DISTINCT: Boolean
    NOT: ConfigTemplateFilter
    OR: ConfigTemplateFilter
    as_attachment: BoolFilterLookup
    auto_sync_enabled: BoolFilterLookup
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    data_file: DataFileFilter
    data_file_id: IntFilterLookup
    data_path: StrFilterLookup
    data_source: DataSourceFilter
    data_source_id: IntFilterLookup
    data_synced: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    environment_params: JSONFilter
    file_extension: StrFilterLookup
    file_name: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    mime_type: StrFilterLookup
    name: StrFilterLookup
    template_code: StrFilterLookup
}

"A physical console port within a Device. ConsolePorts connect to ConsoleServerPorts."
input ConsolePortFilter {
    AND: ConsolePortFilter
    DISTINCT: Boolean
    NOT: ConsolePortFilter
    OR: ConsolePortFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    speed: ConsolePortSpeedEnum
    tags: TagFilter
    type: ConsolePortTypeEnum
}

"A template for a ConsolePort to be created for a new Device."
input ConsolePortTemplateFilter {
    AND: ConsolePortTemplateFilter
    DISTINCT: Boolean
    NOT: ConsolePortTemplateFilter
    OR: ConsolePortTemplateFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    type: ConsolePortTypeEnum
}

"A physical port within a Device (typically a designated console server) which provides access to ConsolePorts."
input ConsoleServerPortFilter {
    AND: ConsoleServerPortFilter
    DISTINCT: Boolean
    NOT: ConsoleServerPortFilter
    OR: ConsoleServerPortFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    speed: ConsolePortSpeedEnum
    tags: TagFilter
    type: ConsolePortTypeEnum
}

"A template for a ConsoleServerPort to be created for a new Device."
input ConsoleServerPortTemplateFilter {
    AND: ConsoleServerPortTemplateFilter
    DISTINCT: Boolean
    NOT: ConsoleServerPortTemplateFilter
    OR: ConsoleServerPortTemplateFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    type: ConsolePortTypeEnum
}

"ContactAssignment(id, created, last_updated, custom_field_data, object_type, object_id, contact, role, priority)"
input ContactAssignmentFilter {
    AND: ContactAssignmentFilter
    DISTINCT: Boolean
    NOT: ContactAssignmentFilter
    OR: ContactAssignmentFilter
    changelog: ObjectChangeFilter
    contact: ContactFilter
    contact_id: ID
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    object_id: ID
    object_type: ContentTypeFilter
    priority: ContactPriorityEnum
    role: ContactRoleFilter
    role_id: ID
    tags: TagFilter
}

"Contact information for a particular object(s) in NetBox."
input ContactFilter {
    AND: ContactFilter
    DISTINCT: Boolean
    NOT: ContactFilter
    OR: ContactFilter
    address: StrFilterLookup
    assignments: ContactAssignmentFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    email: StrFilterLookup
    groups: ContactGroupFilter
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    link: StrFilterLookup
    name: StrFilterLookup
    phone: StrFilterLookup
    tags: TagFilter
    title: StrFilterLookup
}

"An arbitrary collection of Contacts."
input ContactGroupFilter {
    AND: ContactGroupFilter
    DISTINCT: Boolean
    NOT: ContactGroupFilter
    OR: ContactGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent: ContactGroupFilter
    parent_id: ID
    slug: StrFilterLookup
    tags: TagFilter
}

"Functional role for a Contact assigned to an object."
input ContactRoleFilter {
    AND: ContactRoleFilter
    DISTINCT: Boolean
    NOT: ContactRoleFilter
    OR: ContactRoleFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"ContentType(id, app_label, model)"
input ContentTypeFilter {
    AND: ContentTypeFilter
    DISTINCT: Boolean
    NOT: ContentTypeFilter
    OR: ContentTypeFilter
    app_label: StrFilterLookup
    id: ID
    model: StrFilterLookup
}

"Represents a set of choices available for choice and multi-choice custom fields."
input CustomFieldChoiceSetFilter {
    AND: CustomFieldChoiceSetFilter
    DISTINCT: Boolean
    NOT: CustomFieldChoiceSetFilter
    OR: CustomFieldChoiceSetFilter
    base_choices: CustomFieldChoiceSetBaseEnum
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    extra_choices: StringArrayLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    order_alphabetically: BoolFilterLookup
}

"CustomField(id, created, last_updated, type, related_object_type, name, label, group_name, description, required, unique, search_weight, filter_logic, default, related_object_filter, weight, validation_minimum, validation_maximum, validation_regex, choice_set, ui_visible, ui_editable, is_cloneable, comments)"
input CustomFieldFilter {
    AND: CustomFieldFilter
    DISTINCT: Boolean
    NOT: CustomFieldFilter
    OR: CustomFieldFilter
    changelog: ObjectChangeFilter
    choice_set: CustomFieldChoiceSetFilter
    choice_set_id: ID
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    default: JSONFilter
    description: StrFilterLookup
    filter_logic: CustomFieldFilterLogicEnum
    group_name: StrFilterLookup
    id: ID
    is_cloneable: BoolFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    object_types: ContentTypeFilter
    related_object_filter: JSONFilter
    related_object_type: ContentTypeFilter
    required: BoolFilterLookup
    search_weight: IntegerLookup
    type: CustomFieldTypeEnum
    ui_editable: CustomFieldUIEditableEnum
    ui_visible: CustomFieldUIVisibleEnum
    unique: BoolFilterLookup
    validation_maximum: IntegerLookup
    validation_minimum: IntegerLookup
    validation_regex: StrFilterLookup
    weight: IntegerLookup
}

"""

A custom link to an external representation of a NetBox object. The link text and URL fields accept Jinja2 template
code to be rendered with an object as context.
"""
input CustomLinkFilter {
    AND: CustomLinkFilter
    DISTINCT: Boolean
    NOT: CustomLinkFilter
    OR: CustomLinkFilter
    button_class: CustomLinkButtonClassEnum
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    enabled: BoolFilterLookup
    group_name: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    link_text: StrFilterLookup
    link_url: StrFilterLookup
    name: StrFilterLookup
    new_window: BoolFilterLookup
    weight: IntegerLookup
}

"""

The database representation of a remote file fetched from a remote DataSource. DataFile instances should be created,
updated, or deleted only by calling DataSource.sync().
"""
input DataFileFilter {
    AND: DataFileFilter
    DISTINCT: Boolean
    NOT: DataFileFilter
    OR: DataFileFilter
    created: DatetimeDatetimeFilterLookup
    hash: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    path: StrFilterLookup
    size: IntegerLookup
    source: DataSourceFilter
    source_id: ID
}

"A remote source, such as a git repository, from which DataFiles are synchronized."
input DataSourceFilter {
    AND: DataSourceFilter
    DISTINCT: Boolean
    NOT: DataSourceFilter
    OR: DataSourceFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    datafiles: DataFileFilter
    description: StrFilterLookup
    enabled: BoolFilterLookup
    id: ID
    ignore_rules: StrFilterLookup
    journal_entries: JournalEntryFilter
    last_synced: DatetimeDatetimeFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parameters: JSONFilter
    source_url: StrFilterLookup
    status: StrFilterLookup
    tags: TagFilter
    type: StrFilterLookup
}

input DateDateFilterLookup {
    day: IntComparisonFilterLookup
    "Exact match. Filter will be skipped on `null` value"
    exact: Date
    "Greater than. Filter will be skipped on `null` value"
    gt: Date
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: Date
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Date!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    iso_week_day: IntComparisonFilterLookup
    iso_year: IntComparisonFilterLookup
    "Less than. Filter will be skipped on `null` value"
    lt: Date
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: Date
    month: IntComparisonFilterLookup
    quarter: IntComparisonFilterLookup
    "Inclusive range test (between)"
    range: DateRangeLookup
    week: IntComparisonFilterLookup
    week_day: IntComparisonFilterLookup
    year: IntComparisonFilterLookup
}

input DateRangeLookup {
    end: Date
    start: Date
}

input DatetimeDatetimeFilterLookup {
    date: IntComparisonFilterLookup
    day: IntComparisonFilterLookup
    "Exact match. Filter will be skipped on `null` value"
    exact: DateTime
    "Greater than. Filter will be skipped on `null` value"
    gt: DateTime
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: DateTime
    hour: IntComparisonFilterLookup
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [DateTime!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    iso_week_day: IntComparisonFilterLookup
    iso_year: IntComparisonFilterLookup
    "Less than. Filter will be skipped on `null` value"
    lt: DateTime
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: DateTime
    minute: IntComparisonFilterLookup
    month: IntComparisonFilterLookup
    quarter: IntComparisonFilterLookup
    "Inclusive range test (between)"
    range: DatetimeRangeLookup
    second: IntComparisonFilterLookup
    time: IntComparisonFilterLookup
    week: IntComparisonFilterLookup
    week_day: IntComparisonFilterLookup
    year: IntComparisonFilterLookup
}

input DatetimeRangeLookup {
    end: DateTime
    start: DateTime
}

"An empty space within a Device which can house a child device"
input DeviceBayFilter {
    AND: DeviceBayFilter
    DISTINCT: Boolean
    NOT: DeviceBayFilter
    OR: DeviceBayFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    installed_device: DeviceFilter
    installed_device_id: ID
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    tags: TagFilter
}

"A template for a DeviceBay to be created for a new parent Device."
input DeviceBayTemplateFilter {
    AND: DeviceBayTemplateFilter
    DISTINCT: Boolean
    NOT: DeviceBayTemplateFilter
    OR: DeviceBayTemplateFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
}

"""

A Device represents a piece of physical hardware mounted within a Rack. Each Device is assigned a DeviceType,
DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.

Each Device must be assigned to a site, and optionally to a rack within that site. Associating a device with a
particular rack face or unit is optional (for example, vertically mounted PDUs do not consume rack units).

When a new Device is created, console/power/interface/device bay components are created along with it as dictated
by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the
creation of a Device.
"""
input DeviceFilter {
    AND: DeviceFilter
    DISTINCT: Boolean
    NOT: DeviceFilter
    OR: DeviceFilter
    airflow: DeviceAirflowEnum
    asset_tag: StrFilterLookup
    changelog: ObjectChangeFilter
    cluster: ClusterFilter
    cluster_id: ID
    comments: StrFilterLookup
    config_template: ConfigTemplateFilter
    config_template_id: ID
    console_port_count: IntFilterLookup
    console_ports: ConsolePortFilter
    console_server_port_count: IntFilterLookup
    console_server_ports: ConsoleServerPortFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device_bay_count: IntFilterLookup
    device_bays: DeviceBayFilter
    device_type: DeviceTypeFilter
    device_type_id: ID
    face: DeviceFaceEnum
    front_port_count: IntFilterLookup
    front_ports: FrontPortFilter
    id: ID
    images: ImageAttachmentFilter
    interface_count: IntFilterLookup
    interfaces: InterfaceFilter
    inventory_item_count: IntFilterLookup
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    latitude: FloatLookup
    local_context_data: JSONFilter
    location: LocationFilter
    location_id: TreeNodeFilter
    longitude: FloatLookup
    module_bay_count: IntFilterLookup
    module_bays: ModuleBayFilter
    modules: ModuleFilter
    name: StrFilterLookup
    oob_ip: IPAddressFilter
    oob_ip_id: ID
    platform: PlatformFilter
    position: FloatLookup
    power_outlet_count: IntFilterLookup
    power_outlets: PowerOutletFilter
    power_port_count: IntFilterLookup
    power_ports: PowerPortFilter
    primary_ip4: IPAddressFilter
    primary_ip4_id: ID
    primary_ip6: IPAddressFilter
    primary_ip6_id: ID
    rack: RackFilter
    rack_id: ID
    rear_port_count: IntFilterLookup
    rear_ports: RearPortFilter
    role: DeviceRoleFilter
    role_id: ID
    serial: StrFilterLookup
    site: SiteFilter
    site_id: ID
    status: DeviceStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vc_position: IntegerLookup
    vc_priority: IntegerLookup
    virtual_chassis: VirtualChassisFilter
    virtual_chassis_id: ID
}

"""

Devices are organized by functional role; for example, "Core Switch" or "File Server". Each DeviceRole is assigned a
color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to
virtual machines as well.
"""
input DeviceRoleFilter {
    AND: DeviceRoleFilter
    DISTINCT: Boolean
    NOT: DeviceRoleFilter
    OR: DeviceRoleFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    config_template: ConfigTemplateFilter
    config_template_id: ID
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
    vm_role: BoolFilterLookup
}

"""

A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as
well as high-level functional role(s).

Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and
interface objects. For example, a Juniper EX4300-48T DeviceType would have:

* 1 ConsolePortTemplate
* 2 PowerPortTemplates
* 48 InterfaceTemplates

When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the
DeviceType) are automatically created as well.
"""
input DeviceTypeFilter {
    AND: DeviceTypeFilter
    DISTINCT: Boolean
    NOT: DeviceTypeFilter
    OR: DeviceTypeFilter
    airflow: DeviceAirflowEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    console_port_template_count: IntFilterLookup
    console_port_templates: ConsolePortTemplateFilter
    console_server_port_template_count: IntFilterLookup
    console_server_port_templates: ConsoleServerPortTemplateFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    default_platform: PlatformFilter
    default_platform_id: ID
    description: StrFilterLookup
    device_bay_template_count: IntFilterLookup
    device_bay_templates: DeviceBayTemplateFilter
    exclude_from_utilization: BoolFilterLookup
    front_image: ImageAttachmentFilter
    front_port_template_count: IntFilterLookup
    front_port_templates: FrontPortTemplateFilter
    id: ID
    images: ImageAttachmentFilter
    interface_template_count: IntFilterLookup
    interface_templates: InterfaceTemplateFilter
    inventory_item_template_count: IntFilterLookup
    inventory_item_templates: InventoryItemTemplateFilter
    is_full_depth: BoolFilterLookup
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    model: StrFilterLookup
    module_bay_template_count: IntFilterLookup
    module_bay_templates: ModuleBayTemplateFilter
    part_number: StrFilterLookup
    power_outlet_template_count: IntFilterLookup
    power_outlet_templates: PowerOutletTemplateFilter
    power_port_template_count: IntFilterLookup
    power_port_templates: PowerPortTemplateFilter
    rear_image: ImageAttachmentFilter
    rear_port_template_count: IntFilterLookup
    rear_port_templates: RearPortTemplateFilter
    slug: StrFilterLookup
    subdevice_role: SubdeviceRoleEnum
    tags: TagFilter
    u_height: FloatLookup
    weight: FloatFilterLookup
    weight_unit: WeightUnitEnum
}

"""

An EventRule defines an action to be taken automatically in response to a specific set of events, such as when a
specific type of object is created, modified, or deleted. The action to be taken might entail transmitting a
webhook or executing a custom script.
"""
input EventRuleFilter {
    AND: EventRuleFilter
    DISTINCT: Boolean
    NOT: EventRuleFilter
    OR: EventRuleFilter
    action_data: JSONFilter
    action_object_id: ID
    action_object_type: StrFilterLookup
    action_object_type_id: ID
    action_type: EventRuleActionEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    conditions: JSONFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    enabled: BoolFilterLookup
    event_types: StringArrayLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    tags: TagFilter
}

"ExportTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, template_code, environment_params, mime_type, file_name, file_extension, as_attachment, name, description)"
input ExportTemplateFilter {
    AND: ExportTemplateFilter
    DISTINCT: Boolean
    NOT: ExportTemplateFilter
    OR: ExportTemplateFilter
    as_attachment: BoolFilterLookup
    auto_sync_enabled: BoolFilterLookup
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    data_file: DataFileFilter
    data_file_id: IntFilterLookup
    data_path: StrFilterLookup
    data_source: DataSourceFilter
    data_source_id: IntFilterLookup
    data_synced: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    environment_params: JSONFilter
    file_extension: StrFilterLookup
    file_name: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    mime_type: StrFilterLookup
    name: StrFilterLookup
    template_code: StrFilterLookup
}

"FHRPGroupAssignment(id, created, last_updated, interface_type, interface_id, group, priority)"
input FHRPGroupAssignmentFilter {
    AND: FHRPGroupAssignmentFilter
    DISTINCT: Boolean
    NOT: FHRPGroupAssignmentFilter
    OR: FHRPGroupAssignmentFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    group: FHRPGroupFilter
    group_id: ID
    id: ID
    interface_id: StrFilterLookup
    interface_type: ContentTypeFilter
    last_updated: DatetimeDatetimeFilterLookup
    priority: IntegerLookup
}

"A grouping of next hope resolution protocol (FHRP) peers. (For instance, VRRP or HSRP.)"
input FHRPGroupFilter {
    AND: FHRPGroupFilter
    DISTINCT: Boolean
    NOT: FHRPGroupFilter
    OR: FHRPGroupFilter
    auth_key: StrFilterLookup
    auth_type: FHRPGroupAuthTypeEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    group_id: IntegerLookup
    id: ID
    ip_addresses: IPAddressFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    protocol: FHRPGroupProtocolEnum
    tags: TagFilter
}

input FloatComparisonFilterLookup {
    "Exact match. Filter will be skipped on `null` value"
    exact: Float
    "Greater than. Filter will be skipped on `null` value"
    gt: Float
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: Float
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Float!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Less than. Filter will be skipped on `null` value"
    lt: Float
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: Float
    "Inclusive range test (between)"
    range: FloatRangeLookup
}

input FloatFilterLookup {
    "Case-sensitive containment test. Filter will be skipped on `null` value"
    contains: Float
    "Case-sensitive ends-with. Filter will be skipped on `null` value"
    ends_with: Float
    "Exact match. Filter will be skipped on `null` value"
    exact: Float
    "Case-insensitive containment test. Filter will be skipped on `null` value"
    i_contains: Float
    "Case-insensitive ends-with. Filter will be skipped on `null` value"
    i_ends_with: Float
    "Case-insensitive exact match. Filter will be skipped on `null` value"
    i_exact: Float
    "Case-insensitive regular expression match. Filter will be skipped on `null` value"
    i_regex: Float
    "Case-insensitive starts-with. Filter will be skipped on `null` value"
    i_starts_with: Float
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Float!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Case-sensitive regular expression match. Filter will be skipped on `null` value"
    regex: Float
    "Case-sensitive starts-with. Filter will be skipped on `null` value"
    starts_with: Float
}

"Lookup for Float fields. Only one of the lookup fields can be set."
input FloatLookup {
    comparison_lookup: FloatComparisonFilterLookup
    filter_lookup: FloatFilterLookup
    range_lookup: FloatRangeLookup
}

input FloatRangeLookup {
    end: Float
    start: Float
}

"A pass-through port on the front of a Device."
input FrontPortFilter {
    AND: FrontPortFilter
    DISTINCT: Boolean
    NOT: FrontPortFilter
    OR: FrontPortFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    rear_port: RearPortFilter
    rear_port_id: ID
    rear_port_position: IntegerLookup
    tags: TagFilter
    type: PortTypeEnum
}

"Template for a pass-through port on the front of a new Device."
input FrontPortTemplateFilter {
    AND: FrontPortTemplateFilter
    DISTINCT: Boolean
    NOT: FrontPortTemplateFilter
    OR: FrontPortTemplateFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    rear_port: RearPortTemplateFilter
    rear_port_id: ID
    rear_port_position: IntegerLookup
    type: PortTypeEnum
}

"Group(id, name, description)"
input GroupFilter {
    AND: GroupFilter
    DISTINCT: Boolean
    NOT: GroupFilter
    OR: GroupFilter
    description: StrFilterLookup
    id: ID
    name: StrFilterLookup
}

"IKEPolicy(id, created, last_updated, custom_field_data, description, comments, name, version, mode, preshared_key)"
input IKEPolicyFilter {
    AND: IKEPolicyFilter
    DISTINCT: Boolean
    NOT: IKEPolicyFilter
    OR: IKEPolicyFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mode: IKEModeEnum
    name: StrFilterLookup
    preshared_key: StrFilterLookup
    proposals: IKEProposalFilter
    tags: TagFilter
    version: IKEVersionEnum
}

"IKEProposal(id, created, last_updated, custom_field_data, description, comments, name, authentication_method, encryption_algorithm, authentication_algorithm, group, sa_lifetime)"
input IKEProposalFilter {
    AND: IKEProposalFilter
    DISTINCT: Boolean
    NOT: IKEProposalFilter
    OR: IKEProposalFilter
    authentication_algorithm: AuthenticationAlgorithmEnum
    authentication_method: AuthenticationMethodEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    encryption_algorithm: EncryptionAlgorithmEnum
    group: DHGroupEnum
    id: ID
    ike_policies: IKEPolicyFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    sa_lifetime: IntegerLookup
    tags: TagFilter
}

"""

An IPAddress represents an individual IPv4 or IPv6 address and its mask. The mask length should match what is
configured in the real world. (Typically, only loopback interfaces are configured with /32 or /128 masks.) Like
Prefixes, IPAddresses can optionally be assigned to a VRF. An IPAddress can optionally be assigned to an Interface.
Interfaces can have zero or more IPAddresses assigned to them.

An IPAddress can also optionally point to a NAT inside IP, designating itself as a NAT outside IP. This is useful,
for example, when mapping public addresses to private addresses. When an Interface has been assigned an IPAddress
which has a NAT outside IP, that Interface's Device can use either the inside or outside IP as its primary IP.
"""
input IPAddressFilter {
    AND: IPAddressFilter
    DISTINCT: Boolean
    NOT: IPAddressFilter
    OR: IPAddressFilter
    address: StrFilterLookup
    assigned_object_id: ID
    assigned_object_type: ContentTypeFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    dns_name: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    nat_inside: IPAddressFilter
    nat_inside_id: ID
    nat_outside: IPAddressFilter
    nat_outside_id: ID
    parent: [String!]
    role: IPAddressRoleEnum
    status: IPAddressStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vrf: VRFFilter
    vrf_id: ID
}

"A range of IP addresses, defined by start and end addresses."
input IPRangeFilter {
    AND: IPRangeFilter
    DISTINCT: Boolean
    NOT: IPRangeFilter
    OR: IPRangeFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    end_address: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mark_utilized: BoolFilterLookup
    parent: [String!]
    role: RoleFilter
    size: IntegerLookup
    start_address: StrFilterLookup
    status: IPRangeStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vrf: VRFFilter
    vrf_id: ID
}

"IPSecPolicy(id, created, last_updated, custom_field_data, description, comments, name, pfs_group)"
input IPSecPolicyFilter {
    AND: IPSecPolicyFilter
    DISTINCT: Boolean
    NOT: IPSecPolicyFilter
    OR: IPSecPolicyFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    pfs_group: DHGroupEnum
    proposals: IPSecProposalFilter
    tags: TagFilter
}

"IPSecProfile(id, created, last_updated, custom_field_data, description, comments, name, mode, ike_policy, ipsec_policy)"
input IPSecProfileFilter {
    AND: IPSecProfileFilter
    DISTINCT: Boolean
    NOT: IPSecProfileFilter
    OR: IPSecProfileFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    ike_policy: IKEPolicyFilter
    ike_policy_id: ID
    ipsec_policy: IPSecPolicyFilter
    ipsec_policy_id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mode: IPSecModeEnum
    name: StrFilterLookup
    tags: TagFilter
}

"IPSecProposal(id, created, last_updated, custom_field_data, description, comments, name, encryption_algorithm, authentication_algorithm, sa_lifetime_seconds, sa_lifetime_data)"
input IPSecProposalFilter {
    AND: IPSecProposalFilter
    DISTINCT: Boolean
    NOT: IPSecProposalFilter
    OR: IPSecProposalFilter
    authentication_algorithm: AuthenticationAlgorithmEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    encryption_algorithm: EncryptionAlgorithmEnum
    id: ID
    ipsec_policies: IPSecPolicyFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    sa_lifetime_data: IntegerLookup
    sa_lifetime_seconds: IntegerLookup
    tags: TagFilter
}

"An uploaded image which is associated with an object."
input ImageAttachmentFilter {
    AND: ImageAttachmentFilter
    DISTINCT: Boolean
    NOT: ImageAttachmentFilter
    OR: ImageAttachmentFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    id: ID
    image_height: IntegerLookup
    image_width: IntegerLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    object_id: ID
    object_type: ContentTypeFilter
}

input IntComparisonFilterLookup {
    "Exact match. Filter will be skipped on `null` value"
    exact: Int
    "Greater than. Filter will be skipped on `null` value"
    gt: Int
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: Int
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Int!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Less than. Filter will be skipped on `null` value"
    lt: Int
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: Int
    "Inclusive range test (between)"
    range: IntRangeLookup
}

input IntFilterLookup {
    "Case-sensitive containment test. Filter will be skipped on `null` value"
    contains: Int
    "Case-sensitive ends-with. Filter will be skipped on `null` value"
    ends_with: Int
    "Exact match. Filter will be skipped on `null` value"
    exact: Int
    "Case-insensitive containment test. Filter will be skipped on `null` value"
    i_contains: Int
    "Case-insensitive ends-with. Filter will be skipped on `null` value"
    i_ends_with: Int
    "Case-insensitive exact match. Filter will be skipped on `null` value"
    i_exact: Int
    "Case-insensitive regular expression match. Filter will be skipped on `null` value"
    i_regex: Int
    "Case-insensitive starts-with. Filter will be skipped on `null` value"
    i_starts_with: Int
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [Int!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Case-sensitive regular expression match. Filter will be skipped on `null` value"
    regex: Int
    "Case-sensitive starts-with. Filter will be skipped on `null` value"
    starts_with: Int
}

input IntRangeLookup {
    end: Int
    start: Int
}

"Lookup for Array fields. Only one of the lookup fields can be set."
input IntegerArrayLookup {
    "Contained by the value"
    contained_by: [Int!]
    "Contains the value"
    contains: [Int!]
    "Length of the array"
    length: Int
    "Overlaps with the value"
    overlap: [Int!]
}

"Lookup for Integer fields. Only one of the lookup fields can be set."
input IntegerLookup {
    comparison_lookup: IntComparisonFilterLookup
    filter_lookup: IntFilterLookup
    range_lookup: IntRangeLookup
}

"A network interface within a Device. A physical Interface can connect to exactly one other Interface."
input InterfaceFilter {
    AND: InterfaceFilter
    DISTINCT: Boolean
    NOT: InterfaceFilter
    OR: InterfaceFilter
    bridge: InterfaceFilter
    bridge_id: ID
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    duplex: InterfaceDuplexEnum
    enabled: BoolFilterLookup
    fhrp_group_assignments: FHRPGroupAssignmentFilter
    id: ID
    inventory_items: InventoryItemFilter
    ip_addresses: IPAddressFilter
    journal_entries: JournalEntryFilter
    l2vpn_terminations: L2VPNFilter
    label: StrFilterLookup
    lag: InterfaceFilter
    lag_id: ID
    last_updated: DatetimeDatetimeFilterLookup
    mac_addresses: MACAddressFilter
    mark_connected: BoolFilterLookup
    mgmt_only: BoolFilterLookup
    mode: InterfaceModeEnum
    module: ModuleFilter
    module_id: ID
    mtu: IntegerLookup
    name: StrFilterLookup
    parent: InterfaceFilter
    parent_id: ID
    poe_mode: InterfacePoEModeEnum
    poe_type: InterfacePoETypeEnum
    primary_mac_address: MACAddressFilter
    primary_mac_address_id: ID
    qinq_svlan: VLANFilter
    rf_channel: WirelessChannelEnum
    rf_channel_frequency: FloatLookup
    rf_channel_width: FloatLookup
    rf_role: WirelessRoleEnum
    speed: IntegerLookup
    tagged_vlans: VLANFilter
    tags: TagFilter
    tunnel_terminations: TunnelTerminationFilter
    tx_power: IntegerLookup
    type: InterfaceTypeEnum
    untagged_vlan: VLANFilter
    vcdcs: VirtualDeviceContextFilter
    vlan_translation_policy: VLANTranslationPolicyFilter
    vrf: VRFFilter
    vrf_id: ID
    wireless_lans: WirelessLANFilter
    wireless_link: WirelessLinkFilter
    wireless_link_id: ID
    wwn: StrFilterLookup
}

"A template for a physical data interface on a new Device."
input InterfaceTemplateFilter {
    AND: InterfaceTemplateFilter
    DISTINCT: Boolean
    NOT: InterfaceTemplateFilter
    OR: InterfaceTemplateFilter
    bridge: InterfaceTemplateFilter
    bridge_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    enabled: BoolFilterLookup
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mgmt_only: BoolFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    poe_mode: InterfacePoEModeEnum
    poe_type: InterfacePoETypeEnum
    rf_role: WirelessRoleEnum
    type: InterfaceTypeEnum
}

"""

An InventoryItem represents a serialized piece of hardware within a Device, such as a line card or power supply.
InventoryItems are used only for inventory purposes.
"""
input InventoryItemFilter {
    AND: InventoryItemFilter
    DISTINCT: Boolean
    NOT: InventoryItemFilter
    OR: InventoryItemFilter
    asset_tag: StrFilterLookup
    changelog: ObjectChangeFilter
    component_id: ID
    component_type: ContentTypeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    discovered: BoolFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    name: StrFilterLookup
    parent: InventoryItemFilter
    parent_id: ID
    part_id: StrFilterLookup
    role: InventoryItemRoleFilter
    role_id: ID
    serial: StrFilterLookup
    status: InventoryItemStatusEnum
    tags: TagFilter
}

"Inventory items may optionally be assigned a functional role."
input InventoryItemRoleFilter {
    AND: InventoryItemRoleFilter
    DISTINCT: Boolean
    NOT: InventoryItemRoleFilter
    OR: InventoryItemRoleFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"A template for an InventoryItem to be created for a new parent Device."
input InventoryItemTemplateFilter {
    AND: InventoryItemTemplateFilter
    DISTINCT: Boolean
    NOT: InventoryItemTemplateFilter
    OR: InventoryItemTemplateFilter
    changelog: ObjectChangeFilter
    component_id: ID
    component_type: ContentTypeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    name: StrFilterLookup
    parent: InventoryItemTemplateFilter
    part_id: StrFilterLookup
    role: InventoryItemRoleFilter
    role_id: ID
}

input JSONFilter {
    lookup: JSONLookup!
    path: String!
}

"Lookup for JSON field. Only one of the lookup fields can be set."
input JSONLookup {
    boolean_lookup: BoolFilterLookup
    date_lookup: StrDateFilterLookup
    datetime_lookup: StrDatetimeFilterLookup
    float_comparison_lookup: FloatComparisonFilterLookup
    float_range_lookup: FloatRangeLookup
    int_comparison_lookup: IntComparisonFilterLookup
    int_range_lookup: IntRangeLookup
    string_lookup: StrFilterLookup
    time_lookup: StrTimeFilterLookup
}

"""

A historical remark concerning an object; collectively, these form an object's journal. The journal is used to
preserve historical context around an object, and complements NetBox's built-in change logging. For example, you
might record a new journal entry when a device undergoes maintenance, or when a prefix is expanded.
"""
input JournalEntryFilter {
    AND: JournalEntryFilter
    DISTINCT: Boolean
    NOT: JournalEntryFilter
    OR: JournalEntryFilter
    assigned_object_id: ID
    assigned_object_type: ContentTypeFilter
    assigned_object_type_id: ID
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    created_by: UserFilter
    custom_field_data: JSONFilter
    id: ID
    kind: JournalEntryKindEnum
    last_updated: DatetimeDatetimeFilterLookup
    tags: TagFilter
}

"L2VPN(id, created, last_updated, custom_field_data, description, comments, name, slug, type, status, identifier, tenant)"
input L2VPNFilter {
    AND: L2VPNFilter
    DISTINCT: Boolean
    NOT: L2VPNFilter
    OR: L2VPNFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    export_targets: RouteTargetFilter
    id: ID
    identifier: IntegerLookup
    import_targets: RouteTargetFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    terminations: L2VPNTerminationFilter
    type: L2VPNTypeEnum
}

"L2VPNTermination(id, created, last_updated, custom_field_data, l2vpn, assigned_object_type, assigned_object_id)"
input L2VPNTerminationFilter {
    AND: L2VPNTerminationFilter
    DISTINCT: Boolean
    NOT: L2VPNTerminationFilter
    OR: L2VPNTerminationFilter
    assigned_object_id: IntegerLookup
    assigned_object_type: ContentTypeFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    id: ID
    journal_entries: JournalEntryFilter
    l2vpn: L2VPNFilter
    l2vpn_id: ID
    last_updated: DatetimeDatetimeFilterLookup
    tags: TagFilter
}

"""

A Location represents a subgroup of Racks and/or Devices within a Site. A Location may represent a building within a
site, or a room within a building, for example.
"""
input LocationFilter {
    AND: LocationFilter
    DISTINCT: Boolean
    NOT: LocationFilter
    OR: LocationFilter
    changelog: ObjectChangeFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    facility: StrFilterLookup
    id: ID
    images: ImageAttachmentFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent_id: ID
    prefixes: PrefixFilter
    site: SiteFilter
    site_id: ID
    slug: StrFilterLookup
    status: LocationStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vlan_groups: VLANGroupFilter
}

"MACAddress(id, created, last_updated, custom_field_data, description, comments, mac_address, assigned_object_type, assigned_object_id)"
input MACAddressFilter {
    AND: MACAddressFilter
    DISTINCT: Boolean
    NOT: MACAddressFilter
    OR: MACAddressFilter
    assigned_object_id: ID
    assigned_object_type: ContentTypeFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mac_address: StrFilterLookup
    tags: TagFilter
}

"A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell."
input ManufacturerFilter {
    AND: ManufacturerFilter
    DISTINCT: Boolean
    NOT: ManufacturerFilter
    OR: ManufacturerFilter
    changelog: ObjectChangeFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"An empty space within a Device which can house a child device"
input ModuleBayFilter {
    AND: ModuleBayFilter
    DISTINCT: Boolean
    NOT: ModuleBayFilter
    OR: ModuleBayFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    parent: ModuleBayFilter
    parent_id: ID
    position: StrFilterLookup
    tags: TagFilter
}

"A template for a ModuleBay to be created for a new parent Device."
input ModuleBayTemplateFilter {
    AND: ModuleBayTemplateFilter
    DISTINCT: Boolean
    NOT: ModuleBayTemplateFilter
    OR: ModuleBayTemplateFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    position: StrFilterLookup
}

"""

A Module represents a field-installable component within a Device which may itself hold multiple device components
(for example, a line card within a chassis switch). Modules are instantiated from ModuleTypes.
"""
input ModuleFilter {
    AND: ModuleFilter
    DISTINCT: Boolean
    NOT: ModuleFilter
    OR: ModuleFilter
    asset_tag: StrFilterLookup
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    console_ports: ConsolePortFilter
    console_server_ports: ConsoleServerPortFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_bays: DeviceBayFilter
    device_id: ID
    front_ports: FrontPortFilter
    id: ID
    interfaces: InterfaceFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    local_context_data: JSONFilter
    module_bay: ModuleBayFilter
    module_bay_id: ID
    module_bays: ModuleBayFilter
    module_type: ModuleTypeFilter
    module_type_id: ID
    modules: ModuleFilter
    power_outlets: PowerOutletFilter
    power_ports: PowerPortFilter
    rear_ports: RearPortFilter
    serial: StrFilterLookup
    status: ModuleStatusEnum
    tags: TagFilter
}

"""

A ModuleType represents a hardware element that can be installed within a device and which houses additional
components; for example, a line card within a chassis-based switch such as the Cisco Catalyst 6500. Like a
DeviceType, each ModuleType can have console, power, interface, and pass-through port templates assigned to it. It
cannot, however house device bays or module bays.
"""
input ModuleTypeFilter {
    AND: ModuleTypeFilter
    DISTINCT: Boolean
    NOT: ModuleTypeFilter
    OR: ModuleTypeFilter
    airflow: ModuleAirflowEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    console_port_templates: ConsolePortTemplateFilter
    console_server_port_templates: ConsoleServerPortTemplateFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device_bay_templates: DeviceBayTemplateFilter
    front_port_templates: FrontPortTemplateFilter
    id: ID
    images: ImageAttachmentFilter
    interface_templates: InterfaceTemplateFilter
    inventory_item_templates: InventoryItemTemplateFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    model: StrFilterLookup
    module_bay_templates: ModuleBayTemplateFilter
    part_number: StrFilterLookup
    power_outlet_templates: PowerOutletTemplateFilter
    power_port_templates: PowerPortTemplateFilter
    profile: ModuleTypeProfileFilter
    profile_id: ID
    rear_port_templates: RearPortTemplateFilter
    tags: TagFilter
    weight: FloatFilterLookup
    weight_unit: WeightUnitEnum
}

"A profile which defines the attributes which can be set on one or more ModuleTypes."
input ModuleTypeProfileFilter {
    AND: ModuleTypeProfileFilter
    DISTINCT: Boolean
    NOT: ModuleTypeProfileFilter
    OR: ModuleTypeProfileFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    tags: TagFilter
}

"A collection of users and/or groups to be informed for certain notifications."
input NotificationGroupFilter {
    AND: NotificationGroupFilter
    DISTINCT: Boolean
    NOT: NotificationGroupFilter
    OR: NotificationGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    groups: GroupFilter
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    users: UserFilter
}

"""

Record a change to an object and the user account associated with that change. A change record may optionally
indicate an object related to the one being changed. For example, a change to an interface may also indicate the
parent device. This will ensure changes made to component models appear in the parent model's changelog.
"""
input ObjectChangeFilter {
    AND: ObjectChangeFilter
    DISTINCT: Boolean
    NOT: ObjectChangeFilter
    OR: ObjectChangeFilter
    action: StrFilterLookup
    changed_object_id: ID
    changed_object_type: ContentTypeFilter
    changed_object_type_id: ID
    id: ID
    object_repr: StrFilterLookup
    postchange_data: JSONFilter
    prechange_data: JSONFilter
    related_object_id: ID
    related_object_type: ContentTypeFilter
    request_id: StrFilterLookup
    time: DatetimeDatetimeFilterLookup
    user: UserFilter
    user_name: StrFilterLookup
}

input OffsetPaginationInput {
    limit: Int
    offset: Int! = 0
}

"""

Platform refers to the software or firmware running on a Device. For example, "Cisco IOS-XR" or "Juniper Junos". A
Platform may optionally be associated with a particular Manufacturer.
"""
input PlatformFilter {
    AND: PlatformFilter
    DISTINCT: Boolean
    NOT: PlatformFilter
    OR: PlatformFilter
    changelog: ObjectChangeFilter
    config_template: ConfigTemplateFilter
    config_template_id: ID
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"An electrical circuit delivered from a PowerPanel."
input PowerFeedFilter {
    AND: PowerFeedFilter
    DISTINCT: Boolean
    NOT: PowerFeedFilter
    OR: PowerFeedFilter
    amperage: IntegerLookup
    available_power: IntegerLookup
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    max_utilization: IntegerLookup
    name: StrFilterLookup
    phase: PowerFeedPhaseEnum
    power_panel: PowerPanelFilter
    power_panel_id: ID
    rack: RackFilter
    rack_id: ID
    status: PowerFeedStatusEnum
    supply: PowerFeedSupplyEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    type: PowerFeedTypeEnum
    voltage: IntegerLookup
}

"A physical power outlet (output) within a Device which provides power to a PowerPort."
input PowerOutletFilter {
    AND: PowerOutletFilter
    DISTINCT: Boolean
    NOT: PowerOutletFilter
    OR: PowerOutletFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    feed_leg: PowerOutletFeedLegEnum
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    power_port: PowerPortFilter
    power_port_id: ID
    tags: TagFilter
    type: PowerOutletTypeEnum
}

"A template for a PowerOutlet to be created for a new Device."
input PowerOutletTemplateFilter {
    AND: PowerOutletTemplateFilter
    DISTINCT: Boolean
    NOT: PowerOutletTemplateFilter
    OR: PowerOutletTemplateFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    feed_leg: PowerOutletFeedLegEnum
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    power_port: PowerPortTemplateFilter
    power_port_id: ID
    tags: TagFilter
    type: PowerOutletTypeEnum
}

"A distribution point for electrical power; e.g. a data center RPP."
input PowerPanelFilter {
    AND: PowerPanelFilter
    DISTINCT: Boolean
    NOT: PowerPanelFilter
    OR: PowerPanelFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    images: ImageAttachmentFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    location: LocationFilter
    location_id: TreeNodeFilter
    name: StrFilterLookup
    site: SiteFilter
    site_id: ID
    tags: TagFilter
}

"A physical power supply (intake) port within a Device. PowerPorts connect to PowerOutlets."
input PowerPortFilter {
    AND: PowerPortFilter
    DISTINCT: Boolean
    NOT: PowerPortFilter
    OR: PowerPortFilter
    allocated_draw: IntegerLookup
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    maximum_draw: IntegerLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    tags: TagFilter
    type: PowerPortTypeEnum
}

"A template for a PowerPort to be created for a new Device."
input PowerPortTemplateFilter {
    AND: PowerPortTemplateFilter
    DISTINCT: Boolean
    NOT: PowerPortTemplateFilter
    OR: PowerPortTemplateFilter
    allocated_draw: IntegerLookup
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    maximum_draw: IntegerLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    type: PowerPortTypeEnum
}

"""

A Prefix represents an IPv4 or IPv6 network, including mask length. Prefixes can optionally be scoped to certain
areas and/or assigned to VRFs. A Prefix must be assigned a status and may optionally be assigned a used-define Role.
A Prefix can also be assigned to a VLAN where appropriate.
"""
input PrefixFilter {
    AND: PrefixFilter
    DISTINCT: Boolean
    NOT: PrefixFilter
    OR: PrefixFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    is_pool: BoolFilterLookup
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    mark_utilized: BoolFilterLookup
    prefix: StrFilterLookup
    role: RoleFilter
    role_id: ID
    scope_id: ID
    scope_type: ContentTypeFilter
    status: PrefixStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vlan: VLANFilter
    vlan_id: ID
    vrf: VRFFilter
    vrf_id: ID
}

"This is a discrete account within a provider.  Each Circuit belongs to a Provider Account."
input ProviderAccountFilter {
    AND: ProviderAccountFilter
    DISTINCT: Boolean
    NOT: ProviderAccountFilter
    OR: ProviderAccountFilter
    account: StrFilterLookup
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    provider: ProviderFilter
    provider_id: ID
    tags: TagFilter
}

"""

Each Circuit belongs to a Provider. This is usually a telecommunications company or similar organization. This model
stores information pertinent to the user's relationship with the Provider.
"""
input ProviderFilter {
    AND: ProviderFilter
    DISTINCT: Boolean
    NOT: ProviderFilter
    OR: ProviderFilter
    asns: ASNFilter
    changelog: ObjectChangeFilter
    circuits: CircuitFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"""

This represents a provider network which exists outside of NetBox, the details of which are unknown or
unimportant to the user.
"""
input ProviderNetworkFilter {
    AND: ProviderNetworkFilter
    DISTINCT: Boolean
    NOT: ProviderNetworkFilter
    OR: ProviderNetworkFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    provider: ProviderFilter
    provider_id: ID
    service_id: StrFilterLookup
    tags: TagFilter
}

"""

A Regional Internet Registry (RIR) is responsible for the allocation of a large portion of the global IP address
space. This can be an organization like ARIN or RIPE, or a governing standard such as RFC 1918.
"""
input RIRFilter {
    AND: RIRFilter
    DISTINCT: Boolean
    NOT: RIRFilter
    OR: RIRFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    is_private: BoolFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
input RackFilter {
    AND: RackFilter
    DISTINCT: Boolean
    NOT: RackFilter
    OR: RackFilter
    airflow: RackAirflowEnum
    asset_tag: StrFilterLookup
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    desc_units: BoolFilterLookup
    description: StrFilterLookup
    facility_id: StrFilterLookup
    form_factor: RackFormFactorEnum
    id: ID
    images: ImageAttachmentFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    location: LocationFilter
    location_id: TreeNodeFilter
    max_weight: IntegerLookup
    mounting_depth: IntegerLookup
    name: StrFilterLookup
    outer_depth: IntegerLookup
    outer_height: IntegerLookup
    outer_unit: RackDimensionUnitEnum
    outer_width: IntegerLookup
    rack_type: RackTypeFilter
    rack_type_id: ID
    role: RackRoleFilter
    role_id: ID
    serial: StrFilterLookup
    site: SiteFilter
    site_id: ID
    starting_unit: IntegerLookup
    status: RackStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    u_height: IntegerLookup
    vlan_groups: VLANGroupFilter
    weight: FloatFilterLookup
    weight_unit: WeightUnitEnum
    width: RackWidthEnum
}

"One or more reserved units within a Rack."
input RackReservationFilter {
    AND: RackReservationFilter
    DISTINCT: Boolean
    NOT: RackReservationFilter
    OR: RackReservationFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    rack: RackFilter
    rack_id: ID
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    units: IntegerArrayLookup
    user: UserFilter
    user_id: ID
}

"Racks can be organized by functional role, similar to Devices."
input RackRoleFilter {
    AND: RackRoleFilter
    DISTINCT: Boolean
    NOT: RackRoleFilter
    OR: RackRoleFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
input RackTypeFilter {
    AND: RackTypeFilter
    DISTINCT: Boolean
    NOT: RackTypeFilter
    OR: RackTypeFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    desc_units: BoolFilterLookup
    description: StrFilterLookup
    form_factor: RackFormFactorEnum
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    manufacturer: ManufacturerFilter
    manufacturer_id: ID
    max_weight: IntegerLookup
    model: StrFilterLookup
    mounting_depth: IntegerLookup
    outer_depth: IntegerLookup
    outer_height: IntegerLookup
    outer_unit: RackDimensionUnitEnum
    outer_width: IntegerLookup
    slug: StrFilterLookup
    starting_unit: IntegerLookup
    tags: TagFilter
    u_height: IntegerLookup
    weight: FloatFilterLookup
    weight_unit: WeightUnitEnum
    width: RackWidthEnum
}

"A pass-through port on the rear of a Device."
input RearPortFilter {
    AND: RearPortFilter
    DISTINCT: Boolean
    NOT: RearPortFilter
    OR: RearPortFilter
    cable: CableFilter
    cable_end: CableEndEnum
    cable_id: ID
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    inventory_items: InventoryItemFilter
    journal_entries: JournalEntryFilter
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    mark_connected: BoolFilterLookup
    module: ModuleFilter
    module_id: ID
    name: StrFilterLookup
    positions: IntegerLookup
    tags: TagFilter
    type: PortTypeEnum
}

"Template for a pass-through port on the rear of a new Device."
input RearPortTemplateFilter {
    AND: RearPortTemplateFilter
    DISTINCT: Boolean
    NOT: RearPortTemplateFilter
    OR: RearPortTemplateFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    device_type: DeviceTypeFilter
    device_type_id: ID
    id: ID
    label: StrFilterLookup
    last_updated: DatetimeDatetimeFilterLookup
    module_type: ModuleTypeFilter
    name: StrFilterLookup
    positions: IntegerLookup
    type: PortTypeEnum
}

"""

A region represents a geographic collection of sites. For example, you might create regions representing countries,
states, and/or cities. Regions are recursively nested into a hierarchy: all sites belonging to a child region are
also considered to be members of its parent and ancestor region(s).
"""
input RegionFilter {
    AND: RegionFilter
    DISTINCT: Boolean
    NOT: RegionFilter
    OR: RegionFilter
    changelog: ObjectChangeFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent_id: ID
    prefixes: PrefixFilter
    slug: StrFilterLookup
    tags: TagFilter
    vlan_groups: VLANGroupFilter
}

"""

A Role represents the functional role of a Prefix or VLAN; for example, "Customer," "Infrastructure," or
"Management."
"""
input RoleFilter {
    AND: RoleFilter
    DISTINCT: Boolean
    NOT: RoleFilter
    OR: RoleFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
    weight: IntegerLookup
}

"A BGP extended community used to control the redistribution of routes among VRFs, as defined in RFC 4364."
input RouteTargetFilter {
    AND: RouteTargetFilter
    DISTINCT: Boolean
    NOT: RouteTargetFilter
    OR: RouteTargetFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    exporting_l2vpns: L2VPNFilter
    exporting_vrfs: VRFFilter
    id: ID
    importing_l2vpns: L2VPNFilter
    importing_vrfs: VRFFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"A set of predefined keyword parameters that can be reused to filter for specific objects."
input SavedFilterFilter {
    AND: SavedFilterFilter
    DISTINCT: Boolean
    NOT: SavedFilterFilter
    OR: SavedFilterFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    enabled: BoolFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parameters: JSONFilter
    shared: BoolFilterLookup
    slug: StrFilterLookup
    user: UserFilter
    user_id: ID
    weight: IntegerLookup
}

"""

A Service represents a layer-four service (e.g. HTTP or SSH) running on a Device or VirtualMachine. A Service may
optionally be tied to one or more specific IPAddresses belonging to its parent.
"""
input ServiceFilter {
    AND: ServiceFilter
    DISTINCT: Boolean
    NOT: ServiceFilter
    OR: ServiceFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    ip_addresses: IPAddressFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent_object_id: ID
    parent_object_type: ContentTypeFilter
    ports: IntegerLookup
    protocol: ServiceProtocolEnum
    tags: TagFilter
}

"A template for a Service to be applied to a device or virtual machine."
input ServiceTemplateFilter {
    AND: ServiceTemplateFilter
    DISTINCT: Boolean
    NOT: ServiceTemplateFilter
    OR: ServiceTemplateFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    ports: IntegerLookup
    protocol: ServiceProtocolEnum
    tags: TagFilter
}

"""

A Site represents a geographic location within a network; typically a building or campus. The optional facility
field can be used to include an external designation, such as a data center name (e.g. Equinix SV6).
"""
input SiteFilter {
    AND: SiteFilter
    DISTINCT: Boolean
    NOT: SiteFilter
    OR: SiteFilter
    asns: ASNFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    facility: StrFilterLookup
    group: SiteGroupFilter
    group_id: TreeNodeFilter
    id: ID
    images: ImageAttachmentFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    latitude: FloatLookup
    longitude: FloatLookup
    name: StrFilterLookup
    physical_address: StrFilterLookup
    prefixes: PrefixFilter
    region: RegionFilter
    region_id: TreeNodeFilter
    shipping_address: StrFilterLookup
    slug: StrFilterLookup
    status: SiteStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    time_zone: StrFilterLookup
    vlan_groups: VLANGroupFilter
}

"""

A site group is an arbitrary grouping of sites. For example, you might have corporate sites and customer sites; and
within corporate sites you might distinguish between offices and data centers. Like regions, site groups can be
nested recursively to form a hierarchy.
"""
input SiteGroupFilter {
    AND: SiteGroupFilter
    DISTINCT: Boolean
    NOT: SiteGroupFilter
    OR: SiteGroupFilter
    changelog: ObjectChangeFilter
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent_id: ID
    prefixes: PrefixFilter
    slug: StrFilterLookup
    tags: TagFilter
    vlan_groups: VLANGroupFilter
}

input StrDateFilterLookup {
    day: IntComparisonFilterLookup
    "Exact match. Filter will be skipped on `null` value"
    exact: String
    "Greater than. Filter will be skipped on `null` value"
    gt: String
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: String
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [String!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    iso_week_day: IntComparisonFilterLookup
    iso_year: IntComparisonFilterLookup
    "Less than. Filter will be skipped on `null` value"
    lt: String
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: String
    month: IntComparisonFilterLookup
    quarter: IntComparisonFilterLookup
    "Inclusive range test (between)"
    range: StrRangeLookup
    week: IntComparisonFilterLookup
    week_day: IntComparisonFilterLookup
    year: IntComparisonFilterLookup
}

input StrDatetimeFilterLookup {
    date: IntComparisonFilterLookup
    day: IntComparisonFilterLookup
    "Exact match. Filter will be skipped on `null` value"
    exact: String
    "Greater than. Filter will be skipped on `null` value"
    gt: String
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: String
    hour: IntComparisonFilterLookup
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [String!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    iso_week_day: IntComparisonFilterLookup
    iso_year: IntComparisonFilterLookup
    "Less than. Filter will be skipped on `null` value"
    lt: String
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: String
    minute: IntComparisonFilterLookup
    month: IntComparisonFilterLookup
    quarter: IntComparisonFilterLookup
    "Inclusive range test (between)"
    range: StrRangeLookup
    second: IntComparisonFilterLookup
    time: IntComparisonFilterLookup
    week: IntComparisonFilterLookup
    week_day: IntComparisonFilterLookup
    year: IntComparisonFilterLookup
}

input StrFilterLookup {
    "Case-sensitive containment test. Filter will be skipped on `null` value"
    contains: String
    "Case-sensitive ends-with. Filter will be skipped on `null` value"
    ends_with: String
    "Exact match. Filter will be skipped on `null` value"
    exact: String
    "Case-insensitive containment test. Filter will be skipped on `null` value"
    i_contains: String
    "Case-insensitive ends-with. Filter will be skipped on `null` value"
    i_ends_with: String
    "Case-insensitive exact match. Filter will be skipped on `null` value"
    i_exact: String
    "Case-insensitive regular expression match. Filter will be skipped on `null` value"
    i_regex: String
    "Case-insensitive starts-with. Filter will be skipped on `null` value"
    i_starts_with: String
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [String!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Case-sensitive regular expression match. Filter will be skipped on `null` value"
    regex: String
    "Case-sensitive starts-with. Filter will be skipped on `null` value"
    starts_with: String
}

input StrRangeLookup {
    end: String
    start: String
}

input StrTimeFilterLookup {
    date: IntComparisonFilterLookup
    "Exact match. Filter will be skipped on `null` value"
    exact: String
    "Greater than. Filter will be skipped on `null` value"
    gt: String
    "Greater than or equal to. Filter will be skipped on `null` value"
    gte: String
    hour: IntComparisonFilterLookup
    "Exact match of items in a given list. Filter will be skipped on `null` value"
    in_list: [String!]
    "Assignment test. Filter will be skipped on `null` value"
    is_null: Boolean
    "Less than. Filter will be skipped on `null` value"
    lt: String
    "Less than or equal to. Filter will be skipped on `null` value"
    lte: String
    minute: IntComparisonFilterLookup
    "Inclusive range test (between)"
    range: StrRangeLookup
    second: IntComparisonFilterLookup
    time: IntComparisonFilterLookup
}

"Lookup for Array fields. Only one of the lookup fields can be set."
input StringArrayLookup {
    "Contained by the value"
    contained_by: [String!]
    "Contains the value"
    contains: [String!]
    "Length of the array"
    length: Int
    "Overlaps with the value"
    overlap: [String!]
}

"A saved configuration of columns and ordering which applies to a specific table."
input TableConfigFilter {
    AND: TableConfigFilter
    DISTINCT: Boolean
    NOT: TableConfigFilter
    OR: TableConfigFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    enabled: BoolFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    shared: BoolFilterLookup
    user: UserFilter
    user_id: ID
    weight: IntegerLookup
}

"Tag(name, slug, created, last_updated, id, color, description, weight)"
input TagFilter {
    AND: TagFilter
    DISTINCT: Boolean
    NOT: TagFilter
    OR: TagFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
}

"""

A Tenant represents an organization served by the NetBox owner. This is typically a customer or an internal
department.
"""
input TenantFilter {
    AND: TenantFilter
    DISTINCT: Boolean
    NOT: TenantFilter
    OR: TenantFilter
    aggregates: AggregateFilter
    asn_ranges: ASNRangeFilter
    asns: ASNFilter
    cables: CableFilter
    changelog: ObjectChangeFilter
    circuit_groups: CircuitGroupFilter
    circuits: CircuitFilter
    clusters: ClusterFilter
    comments: StrFilterLookup
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    devices: DeviceFilter
    group: TenantGroupFilter
    group_id: TreeNodeFilter
    id: ID
    ip_addresses: IPAddressFilter
    ip_ranges: IPRangeFilter
    journal_entries: JournalEntryFilter
    l2vpns: L2VPNFilter
    last_updated: DatetimeDatetimeFilterLookup
    locations: LocationFilter
    name: StrFilterLookup
    power_feeds: PowerFeedFilter
    prefixes: PrefixFilter
    rackreservations: RackReservationFilter
    racks: RackFilter
    route_targets: RouteTargetFilter
    sites: SiteFilter
    slug: StrFilterLookup
    tags: TagFilter
    tunnels: TunnelFilter
    vdcs: VirtualDeviceContextFilter
    virtual_circuits: VirtualCircuitFilter
    virtual_machines: VirtualMachineFilter
    vlan_groups: VLANGroupFilter
    vlans: VLANFilter
    vrfs: VRFFilter
    wireless_lans: WirelessLANFilter
    wireless_links: WirelessLinkFilter
}

"An arbitrary collection of Tenants."
input TenantGroupFilter {
    AND: TenantGroupFilter
    DISTINCT: Boolean
    NOT: TenantGroupFilter
    OR: TenantGroupFilter
    changelog: ObjectChangeFilter
    children: TenantGroupFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent: TenantGroupFilter
    parent_id: ID
    slug: StrFilterLookup
    tags: TagFilter
    tenants: TenantFilter
}

input TreeNodeFilter {
    id: ID!
    match_type: TreeNodeMatch!
}

"Tunnel(id, created, last_updated, custom_field_data, description, comments, name, status, group, encapsulation, ipsec_profile, tenant, tunnel_id)"
input TunnelFilter {
    AND: TunnelFilter
    DISTINCT: Boolean
    NOT: TunnelFilter
    OR: TunnelFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    encapsulation: TunnelEncapsulationEnum
    group: TunnelGroupFilter
    group_id: ID
    id: ID
    ipsec_profile: IPSecProfileFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    status: TunnelStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    terminations: TunnelTerminationFilter
    tunnel_id: IntegerLookup
}

"""

An administrative grouping of Tunnels. This can be used to correlate peer-to-peer tunnels which form a mesh,
for example.
"""
input TunnelGroupFilter {
    AND: TunnelGroupFilter
    DISTINCT: Boolean
    NOT: TunnelGroupFilter
    OR: TunnelGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"TunnelTermination(id, created, last_updated, custom_field_data, tunnel, role, termination_type, termination_id, outside_ip)"
input TunnelTerminationFilter {
    AND: TunnelTerminationFilter
    DISTINCT: Boolean
    NOT: TunnelTerminationFilter
    OR: TunnelTerminationFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    outside_ip: IPAddressFilter
    outside_ip_id: ID
    role: TunnelTerminationRoleEnum
    tags: TagFilter
    termination_id: ID
    termination_type: TunnelTerminationTypeEnum
    termination_type_id: ID
    tunnel: TunnelFilter
    tunnel_id: ID
}

"User(id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined)"
input UserFilter {
    AND: UserFilter
    DISTINCT: Boolean
    NOT: UserFilter
    OR: UserFilter
    date_joined: DatetimeDatetimeFilterLookup
    email: StrFilterLookup
    first_name: StrFilterLookup
    groups: GroupFilter
    id: ID
    is_active: BoolFilterLookup
    is_staff: BoolFilterLookup
    is_superuser: BoolFilterLookup
    last_login: DatetimeDatetimeFilterLookup
    last_name: StrFilterLookup
    username: StrFilterLookup
}

"""

A VLAN is a distinct layer two forwarding domain identified by a 12-bit integer (1-4094). Each VLAN must be assigned
to a Site, however VLAN IDs need not be unique within a Site. A VLAN may optionally be assigned to a VLANGroup,
within which all VLAN IDs and names but be unique.

Like Prefixes, each VLAN is assigned an operational status and optionally a user-defined Role. A VLAN can have zero
or more Prefixes assigned to it.
"""
input VLANFilter {
    AND: VLANFilter
    DISTINCT: Boolean
    NOT: VLANFilter
    OR: VLANFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    group: VLANGroupFilter
    group_id: ID
    id: ID
    journal_entries: JournalEntryFilter
    l2vpn_terminations: L2VPNFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    qinq_cvlans: VLANFilter
    qinq_role: VLANQinQRoleEnum
    qinq_svlan: VLANFilter
    qinq_svlan_id: ID
    role: RoleFilter
    role_id: ID
    site: SiteFilter
    site_id: ID
    status: VLANStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vid: IntegerLookup
}

"""

A VLAN group is an arbitrary collection of VLANs within which VLAN IDs and names must be unique. Each group must
define one or more ranges of valid VLAN IDs, and may be assigned a specific scope.
"""
input VLANGroupFilter {
    AND: VLANGroupFilter
    DISTINCT: Boolean
    NOT: VLANGroupFilter
    OR: VLANGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    scope_id: ID
    scope_type: ContentTypeFilter
    slug: StrFilterLookup
    tags: TagFilter
    vid_ranges: IntegerArrayLookup
}

"VLANTranslationPolicy(id, created, last_updated, custom_field_data, description, comments, name)"
input VLANTranslationPolicyFilter {
    AND: VLANTranslationPolicyFilter
    DISTINCT: Boolean
    NOT: VLANTranslationPolicyFilter
    OR: VLANTranslationPolicyFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    tags: TagFilter
}

"VLANTranslationRule(id, created, last_updated, custom_field_data, policy, description, local_vid, remote_vid)"
input VLANTranslationRuleFilter {
    AND: VLANTranslationRuleFilter
    DISTINCT: Boolean
    NOT: VLANTranslationRuleFilter
    OR: VLANTranslationRuleFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    local_vid: IntegerLookup
    policy: VLANTranslationPolicyFilter
    policy_id: ID
    remote_vid: IntegerLookup
    tags: TagFilter
}

"VMInterface(id, created, last_updated, custom_field_data, enabled, mtu, mode, parent, bridge, untagged_vlan, qinq_svlan, vlan_translation_policy, primary_mac_address, description, name, _name, virtual_machine, vrf)"
input VMInterfaceFilter {
    AND: VMInterfaceFilter
    DISTINCT: Boolean
    NOT: VMInterfaceFilter
    OR: VMInterfaceFilter
    bridge: InterfaceFilter
    bridge_id: ID
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    enabled: BoolFilterLookup
    fhrp_group_assignments: FHRPGroupAssignmentFilter
    id: ID
    ip_addresses: IPAddressFilter
    journal_entries: JournalEntryFilter
    l2vpn_terminations: L2VPNFilter
    last_updated: DatetimeDatetimeFilterLookup
    mac_addresses: MACAddressFilter
    mode: InterfaceModeEnum
    mtu: IntegerLookup
    name: StrFilterLookup
    parent: VMInterfaceFilter
    parent_id: ID
    primary_mac_address: MACAddressFilter
    primary_mac_address_id: ID
    qinq_svlan: VLANFilter
    tagged_vlans: VLANFilter
    tags: TagFilter
    tunnel_terminations: TunnelTerminationFilter
    untagged_vlan: VLANFilter
    virtual_machine: VirtualMachineFilter
    virtual_machine_id: ID
    vlan_translation_policy: VLANTranslationPolicyFilter
    vrf: VRFFilter
    vrf_id: ID
}

"""

A virtual routing and forwarding (VRF) table represents a discrete layer three forwarding domain (e.g. a routing
table). Prefixes and IPAddresses can optionally be assigned to VRFs. (Prefixes and IPAddresses not assigned to a VRF
are said to exist in the "global" table.)
"""
input VRFFilter {
    AND: VRFFilter
    DISTINCT: Boolean
    NOT: VRFFilter
    OR: VRFFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    enforce_unique: BoolFilterLookup
    export_targets: RouteTargetFilter
    id: ID
    import_targets: RouteTargetFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    rd: StrFilterLookup
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"A collection of Devices which operate with a shared control plane (e.g. a switch stack)."
input VirtualChassisFilter {
    AND: VirtualChassisFilter
    DISTINCT: Boolean
    NOT: VirtualChassisFilter
    OR: VirtualChassisFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    domain: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    master: DeviceFilter
    master_id: ID
    member_count: IntFilterLookup
    members: DeviceFilter
    name: StrFilterLookup
    tags: TagFilter
}

"A virtual connection between two or more endpoints, delivered across one or more physical circuits."
input VirtualCircuitFilter {
    AND: VirtualCircuitFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitFilter
    OR: VirtualCircuitFilter
    changelog: ObjectChangeFilter
    cid: StrFilterLookup
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    group_assignments: CircuitGroupAssignmentFilter
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    provider_account: ProviderAccountFilter
    provider_account_id: ID
    provider_network: ProviderNetworkFilter
    provider_network_id: ID
    status: status
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    type: VirtualCircuitTypeFilter
    type_id: ID
}

"VirtualCircuitTermination(id, created, last_updated, custom_field_data, virtual_circuit, role, interface, description)"
input VirtualCircuitTerminationFilter {
    AND: VirtualCircuitTerminationFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitTerminationFilter
    OR: VirtualCircuitTerminationFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    interface: InterfaceFilter
    interface_id: ID
    last_updated: DatetimeDatetimeFilterLookup
    role: VirtualCircuitTerminationRoleEnum
    tags: TagFilter
    virtual_circuit: VirtualCircuitFilter
    virtual_circuit_id: ID
}

"""

Like physical circuits, virtual circuits can be organized by their functional role. For example, a user might wish
to categorize virtual circuits by their technological nature or by product name.
"""
input VirtualCircuitTypeFilter {
    AND: VirtualCircuitTypeFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitTypeFilter
    OR: VirtualCircuitTypeFilter
    changelog: ObjectChangeFilter
    color: ColorEnum
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    slug: StrFilterLookup
    tags: TagFilter
}

"VirtualDeviceContext(id, created, last_updated, custom_field_data, description, device, name, status, identifier, primary_ip4, primary_ip6, tenant, comments)"
input VirtualDeviceContextFilter {
    AND: VirtualDeviceContextFilter
    DISTINCT: Boolean
    NOT: VirtualDeviceContextFilter
    OR: VirtualDeviceContextFilter
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    id: ID
    identifier: IntegerLookup
    interfaces: InterfaceFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    primary_ip4: IPAddressFilter
    primary_ip4_id: ID
    primary_ip6: IPAddressFilter
    primary_ip6_id: ID
    status: VirtualDeviceContextStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}

"VirtualDisk(id, created, last_updated, custom_field_data, virtual_machine, name, description, size)"
input VirtualDiskFilter {
    AND: VirtualDiskFilter
    DISTINCT: Boolean
    NOT: VirtualDiskFilter
    OR: VirtualDiskFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    size: IntegerLookup
    tags: TagFilter
    virtual_machine: VirtualMachineFilter
    virtual_machine_id: ID
}

"A virtual machine which runs inside a Cluster."
input VirtualMachineFilter {
    AND: VirtualMachineFilter
    DISTINCT: Boolean
    NOT: VirtualMachineFilter
    OR: VirtualMachineFilter
    changelog: ObjectChangeFilter
    cluster: ClusterFilter
    cluster_id: ID
    comments: StrFilterLookup
    config_template: ConfigTemplateFilter
    config_template_id: ID
    contacts: ContactFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    device: DeviceFilter
    device_id: ID
    disk: IntegerLookup
    id: ID
    images: ImageAttachmentFilter
    interface_count: IntFilterLookup
    interfaces: VMInterfaceFilter
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    local_context_data: JSONFilter
    memory: IntegerLookup
    name: StrFilterLookup
    platform: PlatformFilter
    platform_id: ID
    primary_ip4: IPAddressFilter
    primary_ip4_id: ID
    primary_ip6: IPAddressFilter
    primary_ip6_id: ID
    role: DeviceRoleFilter
    role_id: ID
    serial: StrFilterLookup
    services: ServiceFilter
    site: SiteFilter
    site_id: ID
    status: VirtualMachineStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vcpus: FloatLookup
    virtual_disk_count: IntFilterLookup
    virtual_disks: VirtualDiskFilter
}

"""

A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or
delete in NetBox. The request will contain a representation of the object, which the remote application can act on.
Each Webhook can be limited to firing only on certain actions or certain object types.
"""
input WebhookFilter {
    AND: WebhookFilter
    DISTINCT: Boolean
    NOT: WebhookFilter
    OR: WebhookFilter
    additional_headers: StrFilterLookup
    body_template: StrFilterLookup
    ca_file_path: StrFilterLookup
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    events: EventRuleFilter
    http_content_type: StrFilterLookup
    http_method: WebhookHttpMethodEnum
    id: ID
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    payload_url: StrFilterLookup
    secret: StrFilterLookup
    ssl_verification: BoolFilterLookup
    tags: TagFilter
}

"A wireless network formed among an arbitrary number of access point and clients."
input WirelessLANFilter {
    AND: WirelessLANFilter
    DISTINCT: Boolean
    NOT: WirelessLANFilter
    OR: WirelessLANFilter
    auth_cipher: WirelessAuthCipherEnum
    auth_psk: StrFilterLookup
    auth_type: WirelessAuthTypeEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    group: WirelessLANGroupFilter
    group_id: ID
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    scope_id: ID
    scope_type: ContentTypeFilter
    ssid: StrFilterLookup
    status: WirelessLANStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
    vlan: VLANFilter
    vlan_id: ID
}

"A nested grouping of WirelessLANs"
input WirelessLANGroupFilter {
    AND: WirelessLANGroupFilter
    DISTINCT: Boolean
    NOT: WirelessLANGroupFilter
    OR: WirelessLANGroupFilter
    changelog: ObjectChangeFilter
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    name: StrFilterLookup
    parent_id: ID
    slug: StrFilterLookup
    tags: TagFilter
}

"A point-to-point connection between two wireless Interfaces."
input WirelessLinkFilter {
    AND: WirelessLinkFilter
    DISTINCT: Boolean
    NOT: WirelessLinkFilter
    OR: WirelessLinkFilter
    auth_cipher: WirelessAuthCipherEnum
    auth_psk: StrFilterLookup
    auth_type: WirelessAuthTypeEnum
    changelog: ObjectChangeFilter
    comments: StrFilterLookup
    created: DatetimeDatetimeFilterLookup
    custom_field_data: JSONFilter
    description: StrFilterLookup
    distance: FloatFilterLookup
    distance_unit: DistanceUnitEnum
    id: ID
    interface_a: InterfaceFilter
    interface_a_id: ID
    interface_b: InterfaceFilter
    interface_b_id: ID
    journal_entries: JournalEntryFilter
    last_updated: DatetimeDatetimeFilterLookup
    ssid: StrFilterLookup
    status: WirelessLANStatusEnum
    tags: TagFilter
    tenant: TenantFilter
    tenant_group: TenantGroupFilter
    tenant_group_id: TreeNodeFilter
    tenant_id: ID
}
