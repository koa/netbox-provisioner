# This file was generated. Do not edit manually.

schema {
    query: Query
}

union CableTerminationTerminationType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | RearPortType

union CircuitGroupAssignmentMemberType = CircuitType | VirtualCircuitType

union CircuitTerminationTerminationType = LocationType | ProviderNetworkType | RegionType | SiteGroupType | SiteType

union ClusterScopeType = LocationType | RegionType | SiteGroupType | SiteType

union ConnectedEndpointType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | ProviderNetworkType | RearPortType | VirtualCircuitTerminationType

union FHRPGroupInterfaceType = InterfaceType | VMInterfaceType

union IPAddressAssignmentType = FHRPGroupType | InterfaceType | VMInterfaceType

union InventoryItemComponentType = ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerOutletType | PowerPortType | RearPortType

union InventoryItemTemplateComponentType = ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerOutletType | PowerPortType | RearPortType

union L2VPNAssignmentType = InterfaceType | VLANType | VMInterfaceType

union LinkPeerType = CircuitTerminationType | ConsolePortType | ConsoleServerPortType | FrontPortType | InterfaceType | PowerFeedType | PowerOutletType | PowerPortType | RearPortType

union MACAddressAssignmentType = InterfaceType | VMInterfaceType

union PrefixScopeType = LocationType | RegionType | SiteGroupType | SiteType

union VLANGroupScopeType = ClusterGroupType | ClusterType | LocationType | RackType | RegionType | SiteGroupType | SiteType

union WirelessLANScopeType = LocationType | RegionType | SiteGroupType | SiteType

"ASNRange(id, created, last_updated, custom_field_data, description, name, slug, rir, start, end, tenant)"
type ASNRangeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    end: Union!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    rir: RIRType
    slug: String!
    start: Union!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"""

An autonomous system (AS) number is typically used to represent an independent routing domain. A site can have
one or more ASNs assigned to it.
"""
type ASNType {
    asn: Union!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    providers(filters: ProviderFilter): [ProviderType!]!
    rir: RIRType
    sites(filters: SiteFilter): [SiteType!]!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"""

An aggregate exists at the root level of the IP address space hierarchy in NetBox. Aggregates are used to organize
the hierarchy and track the overall utilization of available address space. Each Aggregate is assigned to a RIR.
"""
type AggregateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    date_added: Date
    description: String!
    display: String!
    family: IPAddressFamilyType!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    prefix: String!
    rir: RIRType
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"A mapping between side A or B of a Cable and a terminating object (e.g. an Interface or CircuitTermination)."
type CableTerminationType {
    cable: CableType
    cable_end: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_fields: JSON!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    tags(filters: TagFilter): [TagType!]!
    termination: CableTerminationTerminationType
}

"A physical connection between two endpoints."
type CableType {
    _abs_length: Decimal
    a_terminations: [CableTerminationTerminationType!]!
    b_terminations: [CableTerminationTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    label: String!
    last_updated: DateTime
    length: Decimal
    length_unit: String
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    terminations(filters: CableTerminationFilter): [CableTerminationType!]!
    type: String
}

"Assignment of a physical or virtual circuit to a CircuitGroup with an optional priority."
type CircuitGroupAssignmentType {
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    display: String!
    group: CircuitGroupType!
    id: ID!
    last_updated: DateTime
    member: CircuitGroupAssignmentMemberType
    priority: String
    tags(filters: TagFilter): [TagType!]!
}

"An administrative grouping of Circuits."
type CircuitGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"CircuitTermination(id, created, last_updated, custom_field_data, cable, cable_end, mark_connected, circuit, term_side, termination_type, termination_id, port_speed, upstream_speed, xconnect_id, pp_info, description, _provider_network, _location, _site, _region, _site_group)"
type CircuitTerminationType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    circuit: CircuitType!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    port_speed: Int
    pp_info: String!
    tags(filters: TagFilter): [TagType!]!
    term_side: String!
    termination: CircuitTerminationTerminationType
    upstream_speed: Int
    xconnect_id: String!
}

"""

A communications circuit connects two points. Each Circuit belongs to a Provider; Providers may have multiple
circuits. Each circuit is also assigned a CircuitType and a Site, and may optionally be assigned to a particular
ProviderAccount. Circuit port speed and commit rate are measured in Kbps.
"""
type CircuitType {
    _abs_distance: Decimal
    changelog: [ObjectChangeType!]!
    cid: String!
    class_type: String!
    comments: String!
    commit_rate: Int
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    distance: Decimal
    distance_unit: String
    id: ID!
    install_date: Date
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    provider: ProviderType!
    provider_account: ProviderAccountType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    termination_a: CircuitTerminationType
    termination_date: Date
    termination_z: CircuitTerminationType
    terminations(filters: CircuitTerminationFilter): [CircuitTerminationType!]!
    type: CircuitTypeType!
}

"""

Circuits can be organized by their functional role. For example, a user might wish to define CircuitTypes named
"Long Haul," "Metro," or "Out-of-Band".
"""
type CircuitTypeType {
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter): [CircuitType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"An organizational group of Clusters."
type ClusterGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    clusters(filters: ClusterFilter): [ClusterType!]!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
}

"A cluster of VirtualMachines. Each Cluster may optionally be associated with one or more Devices."
type ClusterType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    group: ClusterGroupType
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    scope: ClusterScopeType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    type: ClusterTypeType
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
}

"A type of Cluster."
type ClusterTypeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    clusters(filters: ClusterFilter): [ClusterType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned
qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B
will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.
"""
type ConfigContextType {
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster_groups(filters: ClusterGroupFilter): [ClusterGroupType!]!
    cluster_types(filters: ClusterTypeFilter): [ClusterTypeType!]!
    clusters(filters: ClusterFilter): [ClusterType!]!
    created: DateTime
    data: JSON!
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    device_types(filters: DeviceTypeFilter): [DeviceTypeType!]!
    display: String!
    id: ID!
    is_active: Boolean!
    last_updated: DateTime
    locations(filters: LocationFilter): [LocationType!]!
    name: String!
    platforms(filters: PlatformFilter): [PlatformType!]!
    regions(filters: RegionFilter): [RegionType!]!
    roles(filters: DeviceRoleFilter): [DeviceRoleType!]!
    site_groups(filters: SiteGroupFilter): [SiteGroupType!]!
    sites(filters: SiteFilter): [SiteType!]!
    tags(filters: TagFilter): [TagType!]!
    tenant_groups(filters: TenantGroupFilter): [TenantGroupType!]!
    tenants(filters: TenantFilter): [TenantType!]!
    weight: Int!
}

"ConfigTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, name, description, template_code, environment_params)"
type ConfigTemplateType {
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    device_roles(filters: DeviceRoleFilter): [DeviceRoleType!]!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    environment_params: JSON
    id: ID!
    last_updated: DateTime
    name: String!
    platforms(filters: PlatformFilter): [PlatformType!]!
    tags(filters: TagFilter): [TagType!]!
    template_code: String!
    virtualmachines(filters: VirtualMachineFilter): [VirtualMachineType!]!
}

"A template for a ConsolePort to be created for a new Device."
type ConsolePortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    type: String
}

"A physical console port within a Device. ConsolePorts connect to ConsoleServerPorts."
type ConsolePortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    speed: Int
    tags(filters: TagFilter): [TagType!]!
    type: String
}

"A template for a ConsoleServerPort to be created for a new Device."
type ConsoleServerPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    type: String
}

"A physical port within a Device (typically a designated console server) which provides access to ConsolePorts."
type ConsoleServerPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    speed: Int
    tags(filters: TagFilter): [TagType!]!
    type: String
}

"ContactAssignment(id, created, last_updated, custom_field_data, object_type, object_id, contact, role, priority)"
type ContactAssignmentType {
    class_type: String!
    contact: ContactType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    last_updated: DateTime
    object_id: Int!
    object_type: ContentTypeType
    priority: String
    role: ContactRoleType
    tags(filters: TagFilter): [TagType!]!
}

"An arbitrary collection of Contacts."
type ContactGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: ContactGroupFilter): [ContactGroupType!]!
    class_type: String!
    contacts(filters: ContactFilter): [ContactType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: ContactGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
}

"Functional role for a Contact assigned to an object."
type ContactRoleType {
    assignments(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"Contact information for a particular object(s) in NetBox."
type ContactType {
    address: String!
    assignments(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    email: String!
    group: ContactGroupType
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    link: String!
    name: String!
    phone: String!
    tags(filters: TagFilter): [TagType!]!
    title: String!
}

"ContentType(id, app_label, model)"
type ContentTypeType {
    app_label: String!
    id: ID!
    model: String!
}

"Represents a set of choices available for choice and multi-choice custom fields."
type CustomFieldChoiceSetType {
    base_choices: String
    changelog: [ObjectChangeType!]!
    choices_for(filters: CustomFieldFilter): [CustomFieldType!]!
    class_type: String!
    created: DateTime
    description: String!
    display: String!
    extra_choices: [[String!]!]
    id: ID!
    last_updated: DateTime
    name: String!
    order_alphabetically: Boolean!
}

"CustomField(id, created, last_updated, type, related_object_type, name, label, group_name, description, required, unique, search_weight, filter_logic, default, related_object_filter, weight, validation_minimum, validation_maximum, validation_regex, choice_set, ui_visible, ui_editable, is_cloneable, comments)"
type CustomFieldType {
    changelog: [ObjectChangeType!]!
    choice_set: CustomFieldChoiceSetType
    class_type: String!
    comments: String!
    created: DateTime
    default: JSON
    description: String!
    display: String!
    filter_logic: String!
    group_name: String!
    id: ID!
    is_cloneable: Boolean!
    label: String!
    last_updated: DateTime
    name: String!
    related_object_filter: JSON
    related_object_type: ContentTypeType
    required: Boolean!
    search_weight: Int!
    type: String!
    ui_editable: String!
    ui_visible: String!
    unique: Boolean!
    validation_maximum: Int
    validation_minimum: Int
    validation_regex: String!
    weight: Int!
}

"""

A custom link to an external representation of a NetBox object. The link text and URL fields accept Jinja2 template
code to be rendered with an object as context.
"""
type CustomLinkType {
    button_class: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    display: String!
    enabled: Boolean!
    group_name: String!
    id: ID!
    last_updated: DateTime
    link_text: String!
    link_url: String!
    name: String!
    new_window: Boolean!
    weight: Int!
}

"""

The database representation of a remote file fetched from a remote DataSource. DataFile instances should be created,
updated, or deleted only by calling DataSource.sync().
"""
type DataFileType {
    class_type: String!
    created: DateTime!
    display: String!
    hash: String!
    id: ID!
    last_updated: DateTime!
    path: String!
    size: Int!
    source: DataSourceType!
}

"A remote source, such as a git repository, from which DataFiles are synchronized."
type DataSourceType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    datafiles(filters: DataFileFilter): [DataFileType!]!
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    ignore_rules: String!
    journal_entries: [JournalEntryType!]!
    last_synced: DateTime
    last_updated: DateTime
    name: String!
    parameters: JSON
    source_url: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    type: String!
}

"A template for a DeviceBay to be created for a new parent Device."
type DeviceBayTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    name: String!
}

"An empty space within a Device which can house a child device"
type DeviceBayType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    installed_device: DeviceType
    label: String!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

Devices are organized by functional role; for example, "Core Switch" or "File Server". Each DeviceRole is assigned a
color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to
virtual machines as well.
"""
type DeviceRoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    config_template: ConfigTemplateType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
    vm_role: Boolean!
}

"""

A Device represents a piece of physical hardware mounted within a Rack. Each Device is assigned a DeviceType,
DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.

Each Device must be assigned to a site, and optionally to a rack within that site. Associating a device with a
particular rack face or unit is optional (for example, vertically mounted PDUs do not consume rack units).

When a new Device is created, console/power/interface/device bay components are created along with it as dictated
by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the
creation of a Device.
"""
type DeviceType {
    airflow: String
    asset_tag: String
    cabletermination_set(filters: CableTerminationFilter): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster: ClusterType
    comments: String!
    config_context: JSON!
    config_template: ConfigTemplateType
    console_port_count: Union!
    console_server_port_count: Union!
    consoleports(filters: ConsolePortFilter): [ConsolePortType!]!
    consoleserverports(filters: ConsoleServerPortFilter): [ConsoleServerPortType!]!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device_bay_count: Union!
    device_type: DeviceTypeType!
    devicebays(filters: DeviceBayFilter): [DeviceBayType!]!
    display: String!
    face: String
    front_port_count: Union!
    frontports(filters: FrontPortFilter): [FrontPortType!]!
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    interface_count: Union!
    interfaces(filters: InterfaceFilter): [InterfaceType!]!
    inventory_item_count: Union!
    inventoryitems(filters: InventoryItemFilter): [InventoryItemType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    latitude: Decimal
    local_context_data: JSON
    location: LocationType
    longitude: Decimal
    module_bay_count: Union!
    modulebays(filters: ModuleBayFilter): [ModuleBayType!]!
    modules(filters: ModuleFilter): [ModuleType!]!
    name: String
    oob_ip: IPAddressType
    parent_bay: DeviceBayType
    platform: PlatformType
    position: Decimal
    power_outlet_count: Union!
    power_port_count: Union!
    poweroutlets(filters: PowerOutletFilter): [PowerOutletType!]!
    powerports(filters: PowerPortFilter): [PowerPortType!]!
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    rack: RackType
    rear_port_count: Union!
    rearports(filters: RearPortFilter): [RearPortType!]!
    role: DeviceRoleType!
    serial: String!
    services(filters: ServiceFilter): [ServiceType!]!
    site: SiteType!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vc_master_for: VirtualChassisType
    vc_position: Int
    vc_priority: Int
    vdcs(filters: VirtualDeviceContextFilter): [VirtualDeviceContextType!]!
    virtual_chassis: VirtualChassisType
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
}

"""

A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as
well as high-level functional role(s).

Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and
interface objects. For example, a Juniper EX4300-48T DeviceType would have:

* 1 ConsolePortTemplate
* 2 PowerPortTemplates
* 48 InterfaceTemplates

When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the
DeviceType) are automatically created as well.
"""
type DeviceTypeType {
    _abs_weight: Int
    airflow: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    console_port_template_count: Union!
    console_server_port_template_count: Union!
    consoleporttemplates(filters: ConsolePortTemplateFilter): [ConsolePortTemplateType!]!
    consoleserverporttemplates(filters: ConsoleServerPortTemplateFilter): [ConsoleServerPortTemplateType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    default_platform: PlatformType
    description: String!
    device_bay_template_count: Union!
    devicebaytemplates(filters: DeviceBayTemplateFilter): [DeviceBayTemplateType!]!
    display: String!
    exclude_from_utilization: Boolean!
    front_image: DjangoImageType
    front_port_template_count: Union!
    frontporttemplates(filters: FrontPortTemplateFilter): [FrontPortTemplateType!]!
    id: ID!
    instances(filters: DeviceFilter): [DeviceType!]!
    interface_template_count: Union!
    interfacetemplates(filters: InterfaceTemplateFilter): [InterfaceTemplateType!]!
    inventory_item_template_count: Union!
    inventoryitemtemplates(filters: InventoryItemTemplateFilter): [InventoryItemTemplateType!]!
    is_full_depth: Boolean!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    model: String!
    module_bay_template_count: Union!
    modulebaytemplates(filters: ModuleBayTemplateFilter): [ModuleBayTemplateType!]!
    part_number: String!
    power_outlet_template_count: Union!
    power_port_template_count: Union!
    poweroutlettemplates(filters: PowerOutletTemplateFilter): [PowerOutletTemplateType!]!
    powerporttemplates(filters: PowerPortTemplateFilter): [PowerPortTemplateType!]!
    rear_image: DjangoImageType
    rear_port_template_count: Union!
    rearporttemplates(filters: RearPortTemplateFilter): [RearPortTemplateType!]!
    slug: String!
    subdevice_role: String
    tags(filters: TagFilter): [TagType!]!
    u_height: Decimal!
    weight: Decimal
    weight_unit: String
}

type DjangoImageType {
    height: Int!
    name: String!
    path: String!
    size: Int!
    url: String!
    width: Int!
}

type DjangoModelType {
    pk: ID!
}

"""

An EventRule defines an action to be taken automatically in response to a specific set of events, such as when a
specific type of object is created, modified, or deleted. The action to be taken might entail transmitting a
webhook or executing a custom script.
"""
type EventRuleType {
    action_data: JSON
    action_object_id: Int
    action_object_type: ContentTypeType
    action_type: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    conditions: JSON
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enabled: Boolean!
    event_types: [String!]!
    id: ID!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter): [TagType!]!
}

"ExportTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, name, description, template_code, mime_type, file_extension, as_attachment)"
type ExportTemplateType {
    as_attachment: Boolean!
    auto_sync_enabled: Boolean!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    data_file: DataFileType
    data_path: String!
    data_source: DataSourceType
    data_synced: DateTime
    description: String!
    display: String!
    file_extension: String!
    id: ID!
    last_updated: DateTime
    mime_type: String!
    name: String!
    template_code: String!
}

"FHRPGroupAssignment(id, created, last_updated, interface_type, interface_id, group, priority)"
type FHRPGroupAssignmentType {
    class_type: String!
    created: DateTime
    display: String!
    group: FHRPGroupType!
    id: ID!
    interface: FHRPGroupInterfaceType!
    last_updated: DateTime
    priority: Int!
}

"A grouping of next hope resolution protocol (FHRP) peers. (For instance, VRRP or HSRP.)"
type FHRPGroupType {
    auth_key: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    fhrpgroupassignment_set(filters: FHRPGroupAssignmentFilter): [FHRPGroupAssignmentType!]!
    group_id: Int!
    id: ID!
    ip_addresses(filters: IPAddressFilter): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    protocol: String!
    tags(filters: TagFilter): [TagType!]!
}

"Template for a pass-through port on the front of a new Device."
type FrontPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    rear_port: RearPortTemplateType!
    rear_port_position: Int!
    type: String!
}

"A pass-through port on the front of a Device."
type FrontPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    rear_port: RearPortType!
    rear_port_position: Int!
    tags(filters: TagFilter): [TagType!]!
    type: String!
}

"Group(id, name, description)"
type GroupType {
    class_type: String!
    display: String!
    id: ID!
    name: String!
}

"IKEPolicy(id, created, last_updated, custom_field_data, description, comments, name, version, mode, preshared_key)"
type IKEPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ipsec_profiles(filters: IPSecProposalFilter): [IPSecProposalType!]!
    last_updated: DateTime
    mode: String
    name: String!
    preshared_key: String!
    proposals(filters: IKEProposalFilter): [IKEProposalType!]!
    tags(filters: TagFilter): [TagType!]!
    version: Int!
}

"IKEProposal(id, created, last_updated, custom_field_data, description, comments, name, authentication_method, encryption_algorithm, authentication_algorithm, group, sa_lifetime)"
type IKEProposalType {
    authentication_algorithm: String
    authentication_method: String!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encryption_algorithm: String!
    group: Int!
    id: ID!
    ike_policies(filters: IKEPolicyFilter): [IKEPolicyType!]!
    last_updated: DateTime
    name: String!
    sa_lifetime: Int
    tags(filters: TagFilter): [TagType!]!
}

type IPAddressFamilyType {
    label: String!
    value: Int!
}

"""

An IPAddress represents an individual IPv4 or IPv6 address and its mask. The mask length should match what is
configured in the real world. (Typically, only loopback interfaces are configured with /32 or /128 masks.) Like
Prefixes, IPAddresses can optionally be assigned to a VRF. An IPAddress can optionally be assigned to an Interface.
Interfaces can have zero or more IPAddresses assigned to them.

An IPAddress can also optionally point to a NAT inside IP, designating itself as a NAT outside IP. This is useful,
for example, when mapping public addresses to private addresses. When an Interface has been assigned an IPAddress
which has a NAT outside IP, that Interface's Device can use either the inside or outside IP as its primary IP.
"""
type IPAddressType {
    address: String!
    assigned_object: IPAddressAssignmentType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    dns_name: String!
    family: IPAddressFamilyType!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    nat_inside: IPAddressType
    nat_outside(filters: IPAddressFilter): [IPAddressType!]!
    role: String
    services(filters: ServiceFilter): [ServiceType!]!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    tunnel_terminations(filters: TunnelTerminationFilter): [TunnelTerminationType!]!
    vrf: VRFType
}

"A range of IP addresses, defined by start and end addresses."
type IPRangeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    end_address: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mark_utilized: Boolean!
    role: RoleType
    size: Int!
    start_address: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vrf: VRFType
}

"IPSecPolicy(id, created, last_updated, custom_field_data, description, comments, name, pfs_group)"
type IPSecPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ipsec_profiles(filters: IPSecProfileFilter): [IPSecProfileType!]!
    last_updated: DateTime
    name: String!
    pfs_group: Int
    proposals(filters: IPSecProposalFilter): [IPSecProposalType!]!
    tags(filters: TagFilter): [TagType!]!
}

"IPSecProfile(id, created, last_updated, custom_field_data, description, comments, name, mode, ike_policy, ipsec_policy)"
type IPSecProfileType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ike_policy: IKEPolicyType!
    ipsec_policy: IPSecPolicyType!
    last_updated: DateTime
    mode: String!
    name: String!
    tags(filters: TagFilter): [TagType!]!
    tunnels(filters: TunnelFilter): [TunnelType!]!
}

"IPSecProposal(id, created, last_updated, custom_field_data, description, comments, name, encryption_algorithm, authentication_algorithm, sa_lifetime_seconds, sa_lifetime_data)"
type IPSecProposalType {
    authentication_algorithm: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encryption_algorithm: String
    id: ID!
    ipsec_policies(filters: IPSecPolicyFilter): [IPSecPolicyType!]!
    last_updated: DateTime
    name: String!
    sa_lifetime_data: Int
    sa_lifetime_seconds: Int
    tags(filters: TagFilter): [TagType!]!
}

"An uploaded image which is associated with an object."
type ImageAttachmentType {
    class_type: String!
    created: DateTime
    display: String!
    id: ID!
    image: DjangoImageType!
    image_height: Int!
    image_width: Int!
    last_updated: DateTime
    name: String!
    object_id: Int!
    object_type: ContentTypeType
}

"A template for a physical data interface on a new Device."
type InterfaceTemplateType {
    _name: String!
    bridge: InterfaceTemplateType
    bridge_interfaces(filters: InterfaceTemplateFilter): [InterfaceTemplateType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    enabled: Boolean!
    id: ID!
    label: String!
    last_updated: DateTime
    mgmt_only: Boolean!
    module_type: ModuleTypeType
    name: String!
    poe_mode: String
    poe_type: String
    rf_role: String
    type: String!
}

"A network interface within a Device. A physical Interface can connect to exactly one other Interface."
type InterfaceType {
    _name: String!
    bridge: InterfaceType
    bridge_interfaces(filters: InterfaceFilter): [InterfaceType!]!
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    child_interfaces(filters: InterfaceFilter): [InterfaceType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    duplex: String
    enabled: Boolean!
    id: ID!
    ip_addresses(filters: IPAddressFilter): [IPAddressType!]!
    label: String!
    lag: InterfaceType
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mac_addresses(filters: MACAddressFilter): [MACAddressType!]!
    mark_connected: Boolean!
    member_interfaces(filters: InterfaceFilter): [InterfaceType!]!
    mgmt_only: Boolean!
    mode: String
    module: ModuleType
    mtu: Int
    name: String!
    parent: InterfaceType
    poe_mode: String
    poe_type: String
    primary_mac_address: MACAddressType
    qinq_svlan: VLANType
    rf_channel: String
    rf_channel_frequency: Decimal
    rf_channel_width: Decimal
    rf_role: String
    speed: Int
    tagged_vlans(filters: VLANFilter): [VLANType!]!
    tags(filters: TagFilter): [TagType!]!
    tx_power: Int
    type: String!
    untagged_vlan: VLANType
    vdcs(filters: VirtualDeviceContextFilter): [VirtualDeviceContextType!]!
    vlan_translation_policy: VLANTranslationPolicyType
    vrf: VRFType
    wireless_lans(filters: WirelessLANFilter): [WirelessLANType!]!
    wireless_link: WirelessLinkType
    wwn: String
}

"Inventory items may optionally be assigned a functional role."
type InventoryItemRoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    inventory_item_templates(filters: InventoryItemTemplateFilter): [InventoryItemTemplateType!]!
    inventory_items(filters: InventoryItemFilter): [InventoryItemType!]!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"A template for an InventoryItem to be created for a new parent Device."
type InventoryItemTemplateType {
    changelog: [ObjectChangeType!]!
    child_items(filters: InventoryItemTemplateFilter): [InventoryItemTemplateType!]!
    class_type: String!
    component: InventoryItemTemplateComponentType
    created: DateTime
    description: String!
    device_type: DeviceTypeType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    manufacturer: ManufacturerType!
    name: String!
    parent: InventoryItemTemplateType
    part_id: String!
    rght: Int!
    role: InventoryItemRoleType
    tree_id: Int!
}

"""

An InventoryItem represents a serialized piece of hardware within a Device, such as a line card or power supply.
InventoryItems are used only for inventory purposes.
"""
type InventoryItemType {
    asset_tag: String
    changelog: [ObjectChangeType!]!
    child_items(filters: InventoryItemFilter): [InventoryItemType!]!
    class_type: String!
    component: InventoryItemComponentType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    discovered: Boolean!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    manufacturer: ManufacturerType
    name: String!
    parent: InventoryItemType
    part_id: String!
    rght: Int!
    role: InventoryItemRoleType
    serial: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
}

"""

A historical remark concerning an object; collectively, these form an object's journal. The journal is used to
preserve historical context around an object, and complements NetBox's built-in change logging. For example, you
might record a new journal entry when a device undergoes maintenance, or when a prefix is expanded.
"""
type JournalEntryType {
    assigned_object_id: Int!
    assigned_object_type: ContentTypeType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    created_by: UserType
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    kind: String!
    last_updated: DateTime
    tags(filters: TagFilter): [TagType!]!
}

"L2VPNTermination(id, created, last_updated, custom_field_data, l2vpn, assigned_object_type, assigned_object_id)"
type L2VPNTerminationType {
    assigned_object: L2VPNAssignmentType!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    l2vpn: L2VPNType!
    last_updated: DateTime
    tags(filters: TagFilter): [TagType!]!
}

"L2VPN(id, created, last_updated, custom_field_data, description, comments, name, slug, type, identifier, tenant)"
type L2VPNType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    export_targets(filters: RouteTargetFilter): [RouteTargetType!]!
    id: ID!
    identifier: Int
    import_targets(filters: RouteTargetFilter): [RouteTargetType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    terminations(filters: L2VPNTerminationFilter): [L2VPNTerminationType!]!
    type: String!
}

"""

A Location represents a subgroup of Racks and/or Devices within a Site. A Location may represent a building within a
site, or a room within a building, for example.
"""
type LocationType {
    cabletermination_set(filters: CableTerminationFilter): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    children(filters: LocationFilter): [LocationType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    facility: String!
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: LocationType
    powerpanel_set(filters: PowerPanelFilter): [PowerPanelType!]!
    racks(filters: RackFilter): [RackType!]!
    rght: Int!
    site: SiteType!
    slug: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
}

"MACAddress(id, created, last_updated, custom_field_data, description, comments, mac_address, assigned_object_type, assigned_object_id)"
type MACAddressType {
    assigned_object: MACAddressAssignmentType
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mac_address: String!
    tags(filters: TagFilter): [TagType!]!
}

"A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell."
type ManufacturerType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device_types(filters: DeviceFilter): [DeviceType!]!
    display: String!
    id: ID!
    inventory_item_templates(filters: InventoryItemTemplateFilter): [InventoryItemTemplateType!]!
    inventory_items(filters: InventoryItemFilter): [InventoryItemType!]!
    last_updated: DateTime
    module_types(filters: ModuleFilter): [ModuleType!]!
    name: String!
    platforms(filters: PlatformFilter): [PlatformType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"A template for a ModuleBay to be created for a new parent Device."
type ModuleBayTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    position: String!
}

"An empty space within a Device which can house a child device"
type ModuleBayType {
    changelog: [ObjectChangeType!]!
    children(filters: ModuleBayFilter): [ModuleBayType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    installed_module: ModuleType
    label: String!
    last_updated: DateTime
    level: Int!
    lft: Int!
    module: ModuleType
    name: String!
    parent: ModuleBayType
    position: String!
    rght: Int!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
}

"""

A Module represents a field-installable component within a Device which may itself hold multiple device components
(for example, a line card within a chassis switch). Modules are instantiated from ModuleTypes.
"""
type ModuleType {
    asset_tag: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    consoleports(filters: ConsolePortFilter): [ConsolePortType!]!
    consoleserverports(filters: ConsoleServerPortFilter): [ConsoleServerPortType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    frontports(filters: FrontPortFilter): [FrontPortType!]!
    id: ID!
    interfaces(filters: InterfaceFilter): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_context_data: JSON
    module_bay: ModuleBayType!
    module_type: ModuleTypeType!
    poweroutlets(filters: PowerOutletFilter): [PowerOutletType!]!
    powerports(filters: PowerPortFilter): [PowerPortType!]!
    rearports(filters: RearPortFilter): [RearPortType!]!
    serial: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

A ModuleType represents a hardware element that can be installed within a device and which houses additional
components; for example, a line card within a chassis-based switch such as the Cisco Catalyst 6500. Like a
DeviceType, each ModuleType can have console, power, interface, and pass-through port templates assigned to it. It
cannot, however house device bays or module bays.
"""
type ModuleTypeType {
    _abs_weight: Int
    airflow: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    consoleporttemplates(filters: ModuleFilter): [ModuleType!]!
    consoleserverporttemplates(filters: ConsoleServerPortTemplateFilter): [ConsoleServerPortTemplateType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    frontporttemplates(filters: FrontPortTemplateFilter): [FrontPortTemplateType!]!
    id: ID!
    instances(filters: InterfaceFilter): [InterfaceType!]!
    interfacetemplates(filters: InterfaceTemplateFilter): [InterfaceTemplateType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    model: String!
    part_number: String!
    poweroutlettemplates(filters: PowerOutletTemplateFilter): [PowerOutletTemplateType!]!
    powerporttemplates(filters: PowerOutletTemplateFilter): [PowerOutletTemplateType!]!
    rearporttemplates(filters: RearPortTemplateFilter): [RearPortTemplateType!]!
    tags(filters: TagFilter): [TagType!]!
    weight: Decimal
    weight_unit: String
}

"A collection of users and/or groups to be informed for certain notifications."
type NotificationGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    groups(filters: GroupFilter): [GroupType!]!
    users(filters: UserFilter): [UserType!]!
}

"A notification message for a User relating to a specific object in NetBox."
type NotificationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    user: UserType
}

"""

Record a change to an object and the user account associated with that change. A change record may optionally
indicate an object related to the one being changed. For example, a change to an interface may also indicate the
parent device. This will ensure changes made to component models appear in the parent model's changelog.
"""
type ObjectChangeType {
    action: String!
    changed_object_id: Int!
    changed_object_type: DjangoModelType!
    class_type: String!
    display: String!
    id: ID!
    object_repr: String!
    postchange_data: JSON
    prechange_data: JSON
    related_object_id: Int
    related_object_type: DjangoModelType
    request_id: UUID!
    time: DateTime!
    user: DjangoModelType
    user_name: String!
}

"""

Platform refers to the software or firmware running on a Device. For example, "Cisco IOS-XR" or "Juniper Junos". A
Platform may optionally be associated with a particular Manufacturer.
"""
type PlatformType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    config_template: ConfigTemplateType
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    id: ID!
    last_updated: DateTime
    manufacturer: ManufacturerType
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
}

"An electrical circuit delivered from a PowerPanel."
type PowerFeedType {
    amperage: Int!
    available_power: Int!
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    max_utilization: Int!
    name: String!
    phase: String!
    power_panel: PowerPanelType!
    rack: RackType
    status: String!
    supply: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    type: String!
    voltage: Int!
}

"A template for a PowerOutlet to be created for a new Device."
type PowerOutletTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    feed_leg: String
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    power_port: PowerPortTemplateType
    type: String
}

"A physical power outlet (output) within a Device which provides power to a PowerPort."
type PowerOutletType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    feed_leg: String
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    power_port: PowerPortType
    tags(filters: TagFilter): [TagType!]!
    type: String
}

"A distribution point for electrical power; e.g. a data center RPP."
type PowerPanelType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    location: LocationType
    name: String!
    powerfeeds(filters: PowerFeedFilter): [PowerFeedType!]!
    site: SiteType!
    tags(filters: TagFilter): [TagType!]!
}

"A template for a PowerPort to be created for a new Device."
type PowerPortTemplateType {
    allocated_draw: Int
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    maximum_draw: Int
    module_type: ModuleTypeType
    name: String!
    poweroutlet_templates(filters: PowerOutletTemplateFilter): [PowerOutletTemplateType!]!
    type: String
}

"A physical power supply (intake) port within a Device. PowerPorts connect to PowerOutlets."
type PowerPortType {
    allocated_draw: Int
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    connected_endpoints: [ConnectedEndpointType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    maximum_draw: Int
    module: ModuleType
    name: String!
    poweroutlets(filters: PowerOutletFilter): [PowerOutletType!]!
    tags(filters: TagFilter): [TagType!]!
    type: String
}

"""

A Prefix represents an IPv4 or IPv6 network, including mask length. Prefixes can optionally be scoped to certain
areas and/or assigned to VRFs. A Prefix must be assigned a status and may optionally be assigned a used-define Role.
A Prefix can also be assigned to a VLAN where appropriate.
"""
type PrefixType {
    _children: Int!
    _depth: Int!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    family: IPAddressFamilyType!
    id: ID!
    is_pool: Boolean!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mark_utilized: Boolean!
    prefix: String!
    role: RoleType
    scope: PrefixScopeType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vlan: VLANType
    vrf: VRFType
}

"This is a discrete account within a provider.  Each Circuit belongs to a Provider Account."
type ProviderAccountType {
    account: String!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter): [CircuitType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    provider: ProviderType!
    tags(filters: TagFilter): [TagType!]!
}

"""

This represents a provider network which exists outside of NetBox, the details of which are unknown or
unimportant to the user.
"""
type ProviderNetworkType {
    changelog: [ObjectChangeType!]!
    circuit_terminations(filters: CircuitTerminationFilter): [CircuitTerminationType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    provider: ProviderType!
    service_id: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

Each Circuit belongs to a Provider. This is usually a telecommunications company or similar organization. This model
stores information pertinent to the user's relationship with the Provider.
"""
type ProviderType {
    accounts(filters: ProviderAccountFilter): [ProviderAccountType!]!
    asns(filters: ASNFilter): [ASNType!]!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter): [CircuitType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    networks(filters: ProviderNetworkFilter): [ProviderNetworkType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

type Query {
    aggregate(id: ID!): AggregateType!
    aggregate_list(filters: AggregateFilter): [AggregateType!]!
    asn(id: ID!): ASNType!
    asn_list(filters: ASNFilter): [ASNType!]!
    asn_range(id: ID!): ASNRangeType!
    asn_range_list(filters: ASNRangeFilter): [ASNRangeType!]!
    cable(id: ID!): CableType!
    cable_list(filters: CableFilter): [CableType!]!
    circuit(id: ID!): CircuitType!
    circuit_group(id: ID!): CircuitGroupType!
    circuit_group_assignment(id: ID!): CircuitGroupAssignmentType!
    circuit_group_assignment_list(filters: CircuitGroupAssignmentFilter): [CircuitGroupAssignmentType!]!
    circuit_group_list(filters: CircuitGroupFilter): [CircuitGroupType!]!
    circuit_list(filters: CircuitFilter): [CircuitType!]!
    circuit_termination(id: ID!): CircuitTerminationType!
    circuit_termination_list(filters: CircuitTerminationFilter): [CircuitTerminationType!]!
    circuit_type(id: ID!): CircuitTypeType!
    circuit_type_list(filters: CircuitTypeFilter): [CircuitTypeType!]!
    cluster(id: ID!): ClusterType!
    cluster_group(id: ID!): ClusterGroupType!
    cluster_group_list(filters: ClusterGroupFilter): [ClusterGroupType!]!
    cluster_list(filters: ClusterFilter): [ClusterType!]!
    cluster_type(id: ID!): ClusterTypeType!
    cluster_type_list(filters: ClusterTypeFilter): [ClusterTypeType!]!
    config_context(id: ID!): ConfigContextType!
    config_context_list(filters: ConfigContextFilter): [ConfigContextType!]!
    config_template(id: ID!): ConfigTemplateType!
    config_template_list(filters: ConfigTemplateFilter): [ConfigTemplateType!]!
    console_port(id: ID!): ConsolePortType!
    console_port_list(filters: ConsolePortFilter): [ConsolePortType!]!
    console_port_template(id: ID!): ConsolePortTemplateType!
    console_port_template_list(filters: ConsolePortTemplateFilter): [ConsolePortTemplateType!]!
    console_server_port(id: ID!): ConsoleServerPortType!
    console_server_port_list(filters: ConsoleServerPortFilter): [ConsoleServerPortType!]!
    console_server_port_template(id: ID!): ConsoleServerPortTemplateType!
    console_server_port_template_list(filters: ConsoleServerPortTemplateFilter): [ConsoleServerPortTemplateType!]!
    contact(id: ID!): ContactType!
    contact_assignment(id: ID!): ContactAssignmentType!
    contact_assignment_list(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    contact_group(id: ID!): ContactGroupType!
    contact_group_list(filters: ContactGroupFilter): [ContactGroupType!]!
    contact_list(filters: ContactFilter): [ContactType!]!
    contact_role(id: ID!): ContactRoleType!
    contact_role_list(filters: ContactRoleFilter): [ContactRoleType!]!
    custom_field(id: ID!): CustomFieldType!
    custom_field_choice_set(id: ID!): CustomFieldChoiceSetType!
    custom_field_choice_set_list(filters: CustomFieldChoiceSetFilter): [CustomFieldChoiceSetType!]!
    custom_field_list(filters: CustomFieldFilter): [CustomFieldType!]!
    custom_link(id: ID!): CustomLinkType!
    custom_link_list(filters: CustomLinkFilter): [CustomLinkType!]!
    data_file(id: ID!): DataFileType!
    data_file_list(filters: DataFileFilter): [DataFileType!]!
    data_source(id: ID!): DataSourceType!
    data_source_list(filters: DataSourceFilter): [DataSourceType!]!
    device(id: ID!): DeviceType!
    device_bay(id: ID!): DeviceBayType!
    device_bay_list(filters: DeviceBayFilter): [DeviceBayType!]!
    device_bay_template(id: ID!): DeviceBayTemplateType!
    device_bay_template_list(filters: DeviceBayTemplateFilter): [DeviceBayTemplateType!]!
    device_list(filters: DeviceFilter): [DeviceType!]!
    device_role(id: ID!): DeviceRoleType!
    device_role_list(filters: DeviceRoleFilter): [DeviceRoleType!]!
    device_type(id: ID!): DeviceTypeType!
    device_type_list(filters: DeviceTypeFilter): [DeviceTypeType!]!
    event_rule(id: ID!): EventRuleType!
    event_rule_list(filters: EventRuleFilter): [EventRuleType!]!
    export_template(id: ID!): ExportTemplateType!
    export_template_list(filters: ExportTemplateFilter): [ExportTemplateType!]!
    fhrp_group(id: ID!): FHRPGroupType!
    fhrp_group_assignment(id: ID!): FHRPGroupAssignmentType!
    fhrp_group_assignment_list(filters: FHRPGroupAssignmentFilter): [FHRPGroupAssignmentType!]!
    fhrp_group_list(filters: FHRPGroupFilter): [FHRPGroupType!]!
    front_port(id: ID!): FrontPortType!
    front_port_list(filters: FrontPortFilter): [FrontPortType!]!
    front_port_template(id: ID!): FrontPortTemplateType!
    front_port_template_list(filters: FrontPortTemplateFilter): [FrontPortTemplateType!]!
    group(id: ID!): GroupType!
    group_list(filters: GroupFilter): [GroupType!]!
    ike_policy(id: ID!): IKEPolicyType!
    ike_policy_list(filters: IKEPolicyFilter): [IKEPolicyType!]!
    ike_proposal(id: ID!): IKEProposalType!
    ike_proposal_list(filters: IKEProposalFilter): [IKEProposalType!]!
    image_attachment(id: ID!): ImageAttachmentType!
    image_attachment_list(filters: ImageAttachmentFilter): [ImageAttachmentType!]!
    interface(id: ID!): InterfaceType!
    interface_list(filters: InterfaceFilter): [InterfaceType!]!
    interface_template(id: ID!): InterfaceTemplateType!
    interface_template_list(filters: InterfaceTemplateFilter): [InterfaceTemplateType!]!
    inventory_item(id: ID!): InventoryItemType!
    inventory_item_list(filters: InventoryItemFilter): [InventoryItemType!]!
    inventory_item_role(id: ID!): InventoryItemRoleType!
    inventory_item_role_list(filters: InventoryItemRoleFilter): [InventoryItemRoleType!]!
    inventory_item_template(id: ID!): InventoryItemTemplateType!
    inventory_item_template_list(filters: InventoryItemTemplateFilter): [InventoryItemTemplateType!]!
    ip_address(id: ID!): IPAddressType!
    ip_address_list(filters: IPAddressFilter): [IPAddressType!]!
    ip_range(id: ID!): IPRangeType!
    ip_range_list(filters: IPRangeFilter): [IPRangeType!]!
    ipsec_policy(id: ID!): IPSecPolicyType!
    ipsec_policy_list(filters: IPSecPolicyFilter): [IPSecPolicyType!]!
    ipsec_profile(id: ID!): IPSecProfileType!
    ipsec_profile_list(filters: IPSecProfileFilter): [IPSecProfileType!]!
    ipsec_proposal(id: ID!): IPSecProposalType!
    ipsec_proposal_list(filters: IPSecProposalFilter): [IPSecProposalType!]!
    journal_entry(id: ID!): JournalEntryType!
    journal_entry_list(filters: JournalEntryFilter): [JournalEntryType!]!
    l2vpn(id: ID!): L2VPNType!
    l2vpn_list(filters: L2VPNFilter): [L2VPNType!]!
    l2vpn_termination(id: ID!): L2VPNTerminationType!
    l2vpn_termination_list(filters: L2VPNTerminationFilter): [L2VPNTerminationType!]!
    location(id: ID!): LocationType!
    location_list(filters: LocationFilter): [LocationType!]!
    mac_address(id: ID!): MACAddressType!
    mac_address_list(filters: MACAddressFilter): [MACAddressType!]!
    manufacturer(id: ID!): ManufacturerType!
    manufacturer_list(filters: ManufacturerFilter): [ManufacturerType!]!
    module(id: ID!): ModuleType!
    module_bay(id: ID!): ModuleBayType!
    module_bay_list(filters: ModuleBayFilter): [ModuleBayType!]!
    module_bay_template(id: ID!): ModuleBayTemplateType!
    module_bay_template_list(filters: ModuleBayTemplateFilter): [ModuleBayTemplateType!]!
    module_list(filters: ModuleFilter): [ModuleType!]!
    module_type(id: ID!): ModuleTypeType!
    module_type_list(filters: ModuleTypeFilter): [ModuleTypeType!]!
    notification(id: ID!): NotificationType!
    notification_group(id: ID!): NotificationGroupType!
    notification_group_list(filters: NotificationGroupFilter): [NotificationGroupType!]!
    notification_list: [NotificationType!]!
    platform(id: ID!): PlatformType!
    platform_list(filters: PlatformFilter): [PlatformType!]!
    power_feed(id: ID!): PowerFeedType!
    power_feed_list(filters: PowerFeedFilter): [PowerFeedType!]!
    power_outlet(id: ID!): PowerOutletType!
    power_outlet_list(filters: PowerOutletFilter): [PowerOutletType!]!
    power_outlet_template(id: ID!): PowerOutletTemplateType!
    power_outlet_template_list(filters: PowerOutletTemplateFilter): [PowerOutletTemplateType!]!
    power_panel(id: ID!): PowerPanelType!
    power_panel_list(filters: PowerPanelFilter): [PowerPanelType!]!
    power_port(id: ID!): PowerPortType!
    power_port_list(filters: PowerPortFilter): [PowerPortType!]!
    power_port_template(id: ID!): PowerPortTemplateType!
    power_port_template_list(filters: PowerPortTemplateFilter): [PowerPortTemplateType!]!
    prefix(id: ID!): PrefixType!
    prefix_list(filters: PrefixFilter): [PrefixType!]!
    provider(id: ID!): ProviderType!
    provider_account(id: ID!): ProviderAccountType!
    provider_account_list(filters: ProviderAccountFilter): [ProviderAccountType!]!
    provider_list(filters: ProviderFilter): [ProviderType!]!
    provider_network(id: ID!): ProviderNetworkType!
    provider_network_list(filters: ProviderNetworkFilter): [ProviderNetworkType!]!
    rack(id: ID!): RackType!
    rack_list(filters: RackFilter): [RackType!]!
    rack_reservation(id: ID!): RackReservationType!
    rack_reservation_list(filters: RackReservationFilter): [RackReservationType!]!
    rack_role(id: ID!): RackRoleType!
    rack_role_list(filters: RackRoleFilter): [RackRoleType!]!
    rack_type(id: ID!): RackTypeType!
    rack_type_list(filters: RackTypeFilter): [RackTypeType!]!
    rear_port(id: ID!): RearPortType!
    rear_port_list(filters: RearPortFilter): [RearPortType!]!
    rear_port_template(id: ID!): RearPortTemplateType!
    rear_port_template_list(filters: RearPortTemplateFilter): [RearPortTemplateType!]!
    region(id: ID!): RegionType!
    region_list(filters: RegionFilter): [RegionType!]!
    rir(id: ID!): RIRType!
    rir_list(filters: RIRFilter): [RIRType!]!
    role(id: ID!): RoleType!
    role_list(filters: RoleFilter): [RoleType!]!
    route_target(id: ID!): RouteTargetType!
    route_target_list(filters: RouteTargetFilter): [RouteTargetType!]!
    saved_filter(id: ID!): SavedFilterType!
    saved_filter_list(filters: SavedFilterFilter): [SavedFilterType!]!
    service(id: ID!): ServiceType!
    service_list(filters: ServiceFilter): [ServiceType!]!
    service_template(id: ID!): ServiceTemplateType!
    service_template_list(filters: ServiceTemplateFilter): [ServiceTemplateType!]!
    site(id: ID!): SiteType!
    site_group(id: ID!): SiteGroupType!
    site_group_list(filters: SiteGroupFilter): [SiteGroupType!]!
    site_list(filters: SiteFilter): [SiteType!]!
    subscription(id: ID!): SubscriptionType!
    subscription_list: [SubscriptionType!]!
    tag(id: ID!): TagType!
    tag_list(filters: TagFilter): [TagType!]!
    tenant(id: ID!): TenantType!
    tenant_group(id: ID!): TenantGroupType!
    tenant_group_list(filters: TenantGroupFilter): [TenantGroupType!]!
    tenant_list(filters: TenantFilter): [TenantType!]!
    tunnel(id: ID!): TunnelType!
    tunnel_group(id: ID!): TunnelGroupType!
    tunnel_group_list(filters: TunnelGroupFilter): [TunnelGroupType!]!
    tunnel_list(filters: TunnelFilter): [TunnelType!]!
    tunnel_termination(id: ID!): TunnelTerminationType!
    tunnel_termination_list(filters: TunnelTerminationFilter): [TunnelTerminationType!]!
    user(id: ID!): UserType!
    user_list(filters: UserFilter): [UserType!]!
    virtual_chassis(id: ID!): VirtualChassisType!
    virtual_chassis_list(filters: VirtualChassisFilter): [VirtualChassisType!]!
    virtual_circuit(id: ID!): VirtualCircuitType!
    virtual_circuit_list(filters: VirtualCircuitFilter): [VirtualCircuitType!]!
    virtual_circuit_termination(id: ID!): VirtualCircuitTerminationType!
    virtual_circuit_termination_list(filters: VirtualCircuitTerminationFilter): [VirtualCircuitTerminationType!]!
    virtual_circuit_type(id: ID!): VirtualCircuitTypeType!
    virtual_circuit_type_list(filters: VirtualCircuitTypeFilter): [VirtualCircuitTypeType!]!
    virtual_device_context(id: ID!): VirtualDeviceContextType!
    virtual_device_context_list(filters: VirtualDeviceContextFilter): [VirtualDeviceContextType!]!
    virtual_disk(id: ID!): VirtualDiskType!
    virtual_disk_list(filters: VirtualDiskFilter): [VirtualDiskType!]!
    virtual_machine(id: ID!): VirtualMachineType!
    virtual_machine_list(filters: VirtualMachineFilter): [VirtualMachineType!]!
    vlan(id: ID!): VLANType!
    vlan_group(id: ID!): VLANGroupType!
    vlan_group_list(filters: VLANGroupFilter): [VLANGroupType!]!
    vlan_list(filters: VLANFilter): [VLANType!]!
    vlan_translation_policy(id: ID!): VLANTranslationPolicyType!
    vlan_translation_policy_list(filters: VLANTranslationPolicyFilter): [VLANTranslationPolicyType!]!
    vlan_translation_rule(id: ID!): VLANTranslationRuleType!
    vlan_translation_rule_list(filters: VLANTranslationRuleFilter): [VLANTranslationRuleType!]!
    vm_interface(id: ID!): VMInterfaceType!
    vm_interface_list(filters: VMInterfaceFilter): [VMInterfaceType!]!
    vrf(id: ID!): VRFType!
    vrf_list(filters: VRFFilter): [VRFType!]!
    webhook(id: ID!): WebhookType!
    webhook_list(filters: WebhookFilter): [WebhookType!]!
    wireless_lan(id: ID!): WirelessLANType!
    wireless_lan_group(id: ID!): WirelessLANGroupType!
    wireless_lan_group_list(filters: WirelessLANGroupFilter): [WirelessLANGroupType!]!
    wireless_lan_list(filters: WirelessLANFilter): [WirelessLANType!]!
    wireless_link(id: ID!): WirelessLinkType!
    wireless_link_list(filters: WirelessLinkFilter): [WirelessLinkType!]!
}

"""

A Regional Internet Registry (RIR) is responsible for the allocation of a large portion of the global IP address
space. This can be an organization like ARIN or RIPE, or a governing standard such as RFC 1918.
"""
type RIRType {
    aggregates(filters: AggregateFilter): [AggregateType!]!
    asn_ranges(filters: ASNRangeFilter): [ASNRangeType!]!
    asns(filters: ASNFilter): [ASNType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    is_private: Boolean!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"One or more reserved units within a Rack."
type RackReservationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    rack: RackType!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    units: [Int!]!
    user: UserType!
}

"Racks can be organized by functional role, similar to Devices."
type RackRoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    racks(filters: RackFilter): [RackType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
type RackType {
    _abs_max_weight: Int
    _abs_weight: Int
    airflow: String
    asset_tag: String
    cabletermination_set(filters: CableTerminationFilter): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    desc_units: Boolean!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    facility_id: String
    form_factor: String
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    location: LocationType
    max_weight: Int
    mounting_depth: Int
    name: String!
    outer_depth: Int
    outer_unit: String
    outer_width: Int
    powerfeeds(filters: PowerFeedFilter): [PowerFeedType!]!
    rack_type: RackTypeType
    reservations(filters: RackReservationFilter): [RackReservationType!]!
    role: RackRoleType
    serial: String!
    site: SiteType!
    starting_unit: Int!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    u_height: Int!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
    weight: Decimal
    weight_unit: String
    width: Int!
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
type RackTypeType {
    _abs_max_weight: Int
    _abs_weight: Int
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    desc_units: Boolean!
    description: String!
    display: String!
    form_factor: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    manufacturer: ManufacturerType!
    max_weight: Int
    model: String!
    mounting_depth: Int
    outer_depth: Int
    outer_unit: String
    outer_width: Int
    slug: String!
    starting_unit: Int!
    tags(filters: TagFilter): [TagType!]!
    u_height: Int!
    weight: Decimal
    weight_unit: String
    width: Int!
}

"Template for a pass-through port on the rear of a new Device."
type RearPortTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    device_type: DeviceTypeType
    display: String!
    frontport_templates(filters: FrontPortTemplateFilter): [FrontPortTemplateType!]!
    id: ID!
    label: String!
    last_updated: DateTime
    module_type: ModuleTypeType
    name: String!
    positions: Int!
    type: String!
}

"A pass-through port on the rear of a Device."
type RearPortType {
    cable: CableType
    cable_end: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType!
    display: String!
    frontports(filters: FrontPortFilter): [FrontPortType!]!
    id: ID!
    label: String!
    last_updated: DateTime
    link_peers: [LinkPeerType!]!
    mark_connected: Boolean!
    module: ModuleType
    name: String!
    positions: Int!
    tags(filters: TagFilter): [TagType!]!
    type: String!
}

"""

A region represents a geographic collection of sites. For example, you might create regions representing countries,
states, and/or cities. Regions are recursively nested into a hierarchy: all sites belonging to a child region are
also considered to be members of its parent and ancestor region(s).
"""
type RegionType {
    changelog: [ObjectChangeType!]!
    children(filters: RegionFilter): [RegionType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: RegionType
    rght: Int!
    sites(filters: SiteFilter): [SiteType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
}

"""

A Role represents the functional role of a Prefix or VLAN; for example, "Customer," "Infrastructure," or
"Management."
"""
type RoleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    ip_ranges(filters: IPRangeFilter): [IPRangeType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter): [PrefixType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    vlans(filters: VLANFilter): [VLANType!]!
    weight: Int!
}

"A BGP extended community used to control the redistribution of routes among VRFs, as defined in RFC 4364."
type RouteTargetType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    exporting_l2vpns(filters: L2VPNFilter): [L2VPNType!]!
    exporting_vrfs(filters: VRFFilter): [VRFType!]!
    id: ID!
    importing_l2vpns(filters: L2VPNFilter): [L2VPNType!]!
    importing_vrfs(filters: VRFFilter): [VRFType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"A set of predefined keyword parameters that can be reused to filter for specific objects."
type SavedFilterType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    last_updated: DateTime
    name: String!
    parameters: JSON!
    shared: Boolean!
    slug: String!
    user: UserType
    weight: Int!
}

"A template for a Service to be applied to a device or virtual machine."
type ServiceTemplateType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    ports: [Int!]!
    protocol: String!
    tags(filters: TagFilter): [TagType!]!
}

"""

A Service represents a layer-four service (e.g. HTTP or SSH) running on a Device or VirtualMachine. A Service may
optionally be tied to one or more specific IPAddresses belonging to its parent.
"""
type ServiceType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType
    display: String!
    id: ID!
    ipaddresses(filters: IPAddressFilter): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    ports: [Int!]!
    protocol: String!
    tags(filters: TagFilter): [TagType!]!
    virtual_machine: VirtualMachineType
}

"""

A site group is an arbitrary grouping of sites. For example, you might have corporate sites and customer sites; and
within corporate sites you might distinguish between offices and data centers. Like regions, site groups can be
nested recursively to form a hierarchy.
"""
type SiteGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: SiteGroupFilter): [SiteGroupType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: SiteGroupType
    rght: Int!
    sites(filters: SiteFilter): [SiteType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
}

"""

A Site represents a geographic location within a network; typically a building or campus. The optional facility
field can be used to include an external designation, such as a data center name (e.g. Equinix SV6).
"""
type SiteType {
    asns(filters: ASNFilter): [ASNType!]!
    cabletermination_set(filters: CableTerminationFilter): [CableTerminationType!]!
    changelog: [ObjectChangeType!]!
    circuit_terminations: [CircuitTerminationType!]!
    class_type: String!
    clusters: [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    facility: String!
    group: SiteGroupType
    id: ID!
    image_attachments: [ImageAttachmentType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    latitude: Decimal
    locations(filters: LocationFilter): [LocationType!]!
    longitude: Decimal
    name: String!
    physical_address: String!
    powerpanel_set(filters: PowerPanelFilter): [PowerPanelType!]!
    prefixes(filters: PrefixFilter): [PrefixType!]!
    racks(filters: RackFilter): [RackType!]!
    region: RegionType
    shipping_address: String!
    slug: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    time_zone: String
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
    vlan_groups(filters: VLANGroupFilter): [VLANGroupType!]!
    vlans(filters: VLANFilter): [VLANType!]!
}

"A User's subscription to a particular object, to be notified of changes."
type SubscriptionType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    display: String!
    user: UserType
}

"Tag(name, slug, created, last_updated, id, color, description)"
type TagType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    object_types: [ContentTypeType!]!
    slug: String!
}

"An arbitrary collection of Tenants."
type TenantGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: TenantGroupFilter): [TenantGroupType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: TenantGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tenants(filters: TenantFilter): [TenantType!]!
    tree_id: Int!
}

"""

A Tenant represents an organization served by the NetBox owner. This is typically a customer or an internal
department.
"""
type TenantType {
    aggregates(filters: AggregateFilter): [AggregateType!]!
    asn_ranges(filters: ASNRangeFilter): [ASNRangeType!]!
    asns(filters: ASNFilter): [ASNType!]!
    cables(filters: CableFilter): [CableType!]!
    changelog: [ObjectChangeType!]!
    circuits(filters: CircuitFilter): [CircuitType!]!
    class_type: String!
    clusters(filters: ClusterFilter): [ClusterType!]!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    devices(filters: DeviceFilter): [DeviceType!]!
    display: String!
    group: TenantGroupType
    id: ID!
    ip_addresses(filters: IPAddressFilter): [IPAddressType!]!
    ip_ranges(filters: IPRangeFilter): [IPRangeType!]!
    journal_entries: [JournalEntryType!]!
    l2vpns(filters: L2VPNFilter): [L2VPNType!]!
    last_updated: DateTime
    locations(filters: LocationFilter): [LocationType!]!
    name: String!
    power_feeds(filters: PowerFeedFilter): [PowerFeedType!]!
    prefixes(filters: PrefixFilter): [PrefixType!]!
    rackreservations(filters: RackReservationFilter): [RackReservationType!]!
    racks(filters: RackFilter): [RackType!]!
    route_targets(filters: RouteTargetFilter): [RouteTargetType!]!
    sites(filters: SiteFilter): [SiteType!]!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tunnels(filters: TunnelFilter): [TunnelType!]!
    vdcs(filters: VirtualDeviceContextFilter): [VirtualDeviceContextType!]!
    virtual_machines(filters: VirtualMachineFilter): [VirtualMachineType!]!
    vlans(filters: VLANFilter): [VLANType!]!
    vrfs(filters: VRFFilter): [VRFType!]!
    wireless_lans(filters: WirelessLANFilter): [WirelessLANType!]!
    wireless_links(filters: WirelessLinkFilter): [WirelessLinkType!]!
}

"""

An administrative grouping of Tunnels. This can be used to correlate peer-to-peer tunnels which form a mesh,
for example.
"""
type TunnelGroupType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tunnels(filters: TunnelFilter): [TunnelType!]!
}

"TunnelTermination(id, created, last_updated, custom_field_data, tunnel, role, termination_type, termination_id, outside_ip)"
type TunnelTerminationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    display: String!
    id: ID!
    last_updated: DateTime
    outside_ip: IPAddressType
    role: String!
    tags(filters: TagFilter): [TagType!]!
    termination_id: Int
    termination_type: ContentTypeType
    tunnel: TunnelType!
}

"Tunnel(id, created, last_updated, custom_field_data, description, comments, name, status, group, encapsulation, ipsec_profile, tenant, tunnel_id)"
type TunnelType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    encapsulation: String!
    group: TunnelGroupType
    id: ID!
    ipsec_profile: IPSecProfileType
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    terminations(filters: TunnelTerminationFilter): [TunnelTerminationType!]!
    tunnel_id: Int
}

"User(id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined)"
type UserType {
    class_type: String!
    date_joined: DateTime!
    display: String!
    email: String!
    first_name: String!
    groups(filters: GroupFilter): [GroupType!]!
    id: ID!
    is_active: Boolean!
    is_staff: Boolean!
    last_name: String!
    username: String!
}

"""

A VLAN group is an arbitrary collection of VLANs within which VLAN IDs and names must be unique. Each group must
define one or more ranges of valid VLAN IDs, and may be assigned a specific scope.
"""
type VLANGroupType {
    _total_vlan_ids: Int!
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    scope: VLANGroupScopeType
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    vid_ranges: [String!]!
    vlans(filters: VLANFilter): [VLANType!]!
}

"VLANTranslationPolicy(id, created, last_updated, custom_field_data, description, comments, name)"
type VLANTranslationPolicyType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    rules(filters: VLANTranslationRuleFilter): [VLANTranslationRuleType!]!
    tags(filters: TagFilter): [TagType!]!
}

"VLANTranslationRule(id, created, last_updated, custom_field_data, policy, description, local_vid, remote_vid)"
type VLANTranslationRuleType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_vid: Int!
    policy: VLANTranslationPolicyType!
    remote_vid: Int!
    tags(filters: TagFilter): [TagType!]!
}

"""

A VLAN is a distinct layer two forwarding domain identified by a 12-bit integer (1-4094). Each VLAN must be assigned
to a Site, however VLAN IDs need not be unique within a Site. A VLAN may optionally be assigned to a VLANGroup,
within which all VLAN IDs and names but be unique.

Like Prefixes, each VLAN is assigned an operational status and optionally a user-defined Role. A VLAN can have zero
or more Prefixes assigned to it.
"""
type VLANType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    group: VLANGroupType
    id: ID!
    interfaces_as_tagged(filters: InterfaceFilter): [InterfaceType!]!
    interfaces_as_untagged(filters: InterfaceFilter): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter): [PrefixType!]!
    qinq_role: String
    qinq_svlan: VLANType
    role: RoleType
    site: SiteType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vid: Int!
    vminterfaces_as_tagged(filters: VMInterfaceFilter): [VMInterfaceType!]!
    vminterfaces_as_untagged(filters: VMInterfaceFilter): [VMInterfaceType!]!
    wirelesslan_set(filters: WirelessLANFilter): [WirelessLANType!]!
}

"VMInterface(id, created, last_updated, custom_field_data, enabled, mtu, mode, parent, bridge, untagged_vlan, qinq_svlan, vlan_translation_policy, primary_mac_address, description, name, _name, virtual_machine, vrf)"
type VMInterfaceType {
    _name: String!
    bridge: VMInterfaceType
    bridge_interfaces(filters: VMInterfaceFilter): [VMInterfaceType!]!
    changelog: [ObjectChangeType!]!
    child_interfaces(filters: VMInterfaceFilter): [VMInterfaceType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enabled: Boolean!
    id: ID!
    ip_addresses(filters: IPAddressFilter): [IPAddressType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    mac_address: String
    mac_addresses(filters: MACAddressFilter): [MACAddressType!]!
    mode: String
    mtu: Int
    name: String!
    parent: VMInterfaceType
    primary_mac_address: MACAddressType
    qinq_svlan: VLANType
    tagged_vlans(filters: VLANFilter): [VLANType!]!
    tags(filters: TagFilter): [TagType!]!
    untagged_vlan: VLANType
    virtual_machine: VirtualMachineType!
    vlan_translation_policy: VLANTranslationPolicyType
    vrf: VRFType
}

"""

A virtual routing and forwarding (VRF) table represents a discrete layer three forwarding domain (e.g. a routing
table). Prefixes and IPAddresses can optionally be assigned to VRFs. (Prefixes and IPAddresses not assigned to a VRF
are said to exist in the "global" table.)
"""
type VRFType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    enforce_unique: Boolean!
    export_targets(filters: RouteTargetFilter): [RouteTargetType!]!
    id: ID!
    import_targets(filters: RouteTargetFilter): [RouteTargetType!]!
    interfaces(filters: InterfaceFilter): [InterfaceType!]!
    ip_addresses(filters: IPAddressFilter): [IPAddressType!]!
    ip_ranges(filters: IPRangeFilter): [IPRangeType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    prefixes(filters: PrefixFilter): [PrefixType!]!
    rd: String
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vminterfaces(filters: VMInterfaceFilter): [VMInterfaceType!]!
}

"A collection of Devices which operate with a shared control plane (e.g. a switch stack)."
type VirtualChassisType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    domain: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    master: DeviceType
    member_count: Union!
    members(filters: DeviceFilter): [DeviceType!]!
    name: String!
    tags(filters: TagFilter): [TagType!]!
}

"VirtualCircuitTermination(id, created, last_updated, custom_field_data, virtual_circuit, role, interface, description)"
type VirtualCircuitTerminationType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    interface: InterfaceType!
    last_updated: DateTime
    role: String!
    tags(filters: TagFilter): [TagType!]!
    virtual_circuit: VirtualCircuitType!
}

"A virtual connection between two or more endpoints, delivered across one or more physical circuits."
type VirtualCircuitType {
    changelog: [ObjectChangeType!]!
    cid: String!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    provider_account: ProviderAccountType
    provider_network: ProviderNetworkType!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    terminations(filters: VirtualCircuitTerminationFilter): [VirtualCircuitTerminationType!]!
    type: VirtualCircuitTypeType!
}

"""

Like physical circuits, virtual circuits can be organized by their functional role. For example, a user might wish
to categorize virtual circuits by their technological nature or by product name.
"""
type VirtualCircuitTypeType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    color: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    name: String!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    virtual_circuits(filters: VirtualCircuitFilter): [VirtualCircuitType!]!
}

"VirtualDeviceContext(id, created, last_updated, custom_field_data, description, device, name, status, identifier, primary_ip4, primary_ip6, tenant, comments)"
type VirtualDeviceContextType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType
    display: String!
    id: ID!
    identifier: Int
    interfaces(filters: InterfaceFilter): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"VirtualDisk(id, created, last_updated, custom_field_data, virtual_machine, name, description, size)"
type VirtualDiskType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    name: String!
    size: Int!
    tags(filters: TagFilter): [TagType!]!
    virtual_machine: VirtualMachineType!
}

"A virtual machine which runs inside a Cluster."
type VirtualMachineType {
    changelog: [ObjectChangeType!]!
    class_type: String!
    cluster: ClusterType
    comments: String!
    config_context: JSON!
    config_template: ConfigTemplateType
    contacts(filters: ContactAssignmentFilter): [ContactAssignmentType!]!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    device: DeviceType
    disk: Int
    display: String!
    id: ID!
    interface_count: Union!
    interfaces(filters: VMInterfaceFilter): [VMInterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    local_context_data: JSON
    memory: Int
    name: String!
    platform: PlatformType
    primary_ip4: IPAddressType
    primary_ip6: IPAddressType
    role: DeviceRoleType
    serial: String!
    services(filters: ServiceFilter): [ServiceType!]!
    site: SiteType
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vcpus: Decimal
    virtual_disk_count: Union!
    virtualdisks(filters: VirtualDiskFilter): [VirtualDiskType!]!
}

"""

A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or
delete in NetBox. The request will contain a representation of the object, which the remote application can act on.
Each Webhook can be limited to firing only on certain actions or certain object types.
"""
type WebhookType {
    additional_headers: String!
    body_template: String!
    ca_file_path: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    http_content_type: String!
    http_method: String!
    id: ID!
    last_updated: DateTime
    name: String!
    payload_url: String!
    secret: String!
    ssl_verification: Boolean!
    tags(filters: TagFilter): [TagType!]!
}

"A nested grouping of WirelessLANs"
type WirelessLANGroupType {
    changelog: [ObjectChangeType!]!
    children(filters: WirelessLANGroupFilter): [WirelessLANGroupType!]!
    class_type: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    id: ID!
    last_updated: DateTime
    level: Int!
    lft: Int!
    name: String!
    parent: WirelessLANGroupType
    rght: Int!
    slug: String!
    tags(filters: TagFilter): [TagType!]!
    tree_id: Int!
    wireless_lans(filters: WirelessLANFilter): [WirelessLANType!]!
}

"A wireless network formed among an arbitrary number of access point and clients."
type WirelessLANType {
    auth_cipher: String
    auth_psk: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    group: WirelessLANGroupType
    id: ID!
    interfaces(filters: InterfaceFilter): [InterfaceType!]!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    scope: WirelessLANScopeType
    ssid: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
    vlan: VLANType
}

"A point-to-point connection between two wireless Interfaces."
type WirelessLinkType {
    _abs_distance: Decimal
    _interface_a_device: DeviceType
    _interface_b_device: DeviceType
    auth_cipher: String
    auth_psk: String!
    auth_type: String
    changelog: [ObjectChangeType!]!
    class_type: String!
    comments: String!
    created: DateTime
    custom_field_data: JSON!
    custom_fields: JSON!
    description: String!
    display: String!
    distance: Decimal
    distance_unit: String
    id: ID!
    interface_a: InterfaceType!
    interface_b: InterfaceType!
    journal_entries: [JournalEntryType!]!
    last_updated: DateTime
    ssid: String!
    status: String!
    tags(filters: TagFilter): [TagType!]!
    tenant: TenantType
}

"Date (isoformat)"
scalar Date

"Date with time (isoformat)"
scalar DateTime

"Decimal (fixed-point)"
scalar Decimal

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf)."
scalar JSON

scalar UUID

"BigInt field"
scalar Union

"""

An autonomous system (AS) number is typically used to represent an independent routing domain. A site can have
one or more ASNs assigned to it.
"""
input ASNFilter {
    AND: ASNFilter
    DISTINCT: Boolean
    NOT: ASNFilter
    OR: ASNFilter
    asn: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    provider: [String!]
    provider_id: [String!]
    q: String
    rir: [String!]
    rir_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"ASNRange(id, created, last_updated, custom_field_data, description, name, slug, rir, start, end, tenant)"
input ASNRangeFilter {
    AND: ASNRangeFilter
    DISTINCT: Boolean
    NOT: ASNRangeFilter
    OR: ASNRangeFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    end: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    rir: [String!]
    rir_id: [String!]
    slug: StrFilterLookup
    start: [String!]
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"""

An aggregate exists at the root level of the IP address space hierarchy in NetBox. Aggregates are used to organize
the hierarchy and track the overall utilization of available address space. Each Aggregate is assigned to a RIR.
"""
input AggregateFilter {
    AND: AggregateFilter
    DISTINCT: Boolean
    NOT: AggregateFilter
    OR: AggregateFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    date_added: DateFilterLookup
    description: StrFilterLookup
    family: Int
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    prefix: String
    q: String
    rir: [String!]
    rir_id: [String!]
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"A physical connection between two endpoints."
input CableFilter {
    AND: CableFilter
    DISTINCT: Boolean
    NOT: CableFilter
    OR: CableFilter
    circuittermination_id: [String!]
    color: String
    consoleport_id: [String!]
    consoleserverport_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: StrFilterLookup
    device_id: [String!]
    frontport_id: [String!]
    id: IDFilterLookup
    interface_id: [String!]
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    length: DecimalFilterLookup
    length_unit: StrFilterLookup
    location: StrFilterLookup
    location_id: [String!]
    modified_by_request: String
    powerfeed_id: [String!]
    poweroutlet_id: [String!]
    powerport_id: [String!]
    q: String
    rack: StrFilterLookup
    rack_id: [String!]
    rearport_id: [String!]
    site: StrFilterLookup
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    termination_a_id: [String!]
    termination_a_type: String
    termination_b_id: [String!]
    termination_b_type: String
    type: String
    unterminated: Boolean
    updated_by_request: String
}

"A mapping between side A or B of a Cable and a terminating object (e.g. an Interface or CircuitTermination)."
input CableTerminationFilter {
    AND: CableTerminationFilter
    DISTINCT: Boolean
    NOT: CableTerminationFilter
    OR: CableTerminationFilter
    cable: DjangoModelFilterInput
    cable_end: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    termination_id: IntFilterLookup
    termination_type: DjangoModelFilterInput
    updated_by_request: String
}

"""

A communications circuit connects two points. Each Circuit belongs to a Provider; Providers may have multiple
circuits. Each circuit is also assigned a CircuitType and a Site, and may optionally be assigned to a particular
ProviderAccount. Circuit port speed and commit rate are measured in Kbps.
"""
input CircuitFilter {
    AND: CircuitFilter
    DISTINCT: Boolean
    NOT: CircuitFilter
    OR: CircuitFilter
    cid: StrFilterLookup
    commit_rate: IntFilterLookup
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    distance: DecimalFilterLookup
    distance_unit: StrFilterLookup
    id: IDFilterLookup
    install_date: DateFilterLookup
    last_updated: DatetimeFilterLookup
    location_id: [String!]
    modified_by_request: String
    provider: [String!]
    provider_account: [String!]
    provider_account_id: [String!]
    provider_id: [String!]
    provider_network_id: [String!]
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    termination_a_id: [String!]
    termination_date: DateFilterLookup
    termination_z_id: [String!]
    type: [String!]
    type_id: [String!]
    updated_by_request: String
}

"Assignment of a physical or virtual circuit to a CircuitGroup with an optional priority."
input CircuitGroupAssignmentFilter {
    AND: CircuitGroupAssignmentFilter
    DISTINCT: Boolean
    NOT: CircuitGroupAssignmentFilter
    OR: CircuitGroupAssignmentFilter
    circuit: StrFilterLookup
    circuit_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    member_id: IntFilterLookup
    member_type: String
    modified_by_request: String
    priority: StrFilterLookup
    provider: StrFilterLookup
    provider_id: [String!]
    q: String
    tag: [String!]
    updated_by_request: String
    virtual_circuit: StrFilterLookup
    virtual_circuit_id: [String!]
}

"An administrative grouping of Circuits."
input CircuitGroupFilter {
    AND: CircuitGroupFilter
    DISTINCT: Boolean
    NOT: CircuitGroupFilter
    OR: CircuitGroupFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"CircuitTermination(id, created, last_updated, custom_field_data, cable, cable_end, mark_connected, circuit, term_side, termination_type, termination_id, port_speed, upstream_speed, xconnect_id, pp_info, description, _provider_network, _location, _site, _region, _site_group)"
input CircuitTerminationFilter {
    AND: CircuitTerminationFilter
    DISTINCT: Boolean
    NOT: CircuitTerminationFilter
    OR: CircuitTerminationFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    circuit_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    occupied: Boolean
    port_speed: IntFilterLookup
    pp_info: StrFilterLookup
    provider: [String!]
    provider_id: [String!]
    provider_network_id: [String!]
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    term_side: StrFilterLookup
    termination_id: IntFilterLookup
    termination_type: String
    updated_by_request: String
    upstream_speed: IntFilterLookup
    xconnect_id: StrFilterLookup
}

"""

Circuits can be organized by their functional role. For example, a user might wish to define CircuitTypes named
"Long Haul," "Metro," or "Out-of-Band".
"""
input CircuitTypeFilter {
    AND: CircuitTypeFilter
    DISTINCT: Boolean
    NOT: CircuitTypeFilter
    OR: CircuitTypeFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"A cluster of VirtualMachines. Each Cluster may optionally be associated with one or more Devices."
input ClusterFilter {
    AND: ClusterFilter
    DISTINCT: Boolean
    NOT: ClusterFilter
    OR: ClusterFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    q: String
    region: [String!]
    region_id: [String!]
    scope_id: IntFilterLookup
    scope_type: String
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    type: [String!]
    type_id: [String!]
    updated_by_request: String
}

"An organizational group of Clusters."
input ClusterGroupFilter {
    AND: ClusterGroupFilter
    DISTINCT: Boolean
    NOT: ClusterGroupFilter
    OR: ClusterGroupFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"A type of Cluster."
input ClusterTypeFilter {
    AND: ClusterTypeFilter
    DISTINCT: Boolean
    NOT: ClusterTypeFilter
    OR: ClusterTypeFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned
qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B
will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.
"""
input ConfigContextFilter {
    AND: ConfigContextFilter
    DISTINCT: Boolean
    NOT: ConfigContextFilter
    OR: ConfigContextFilter
    auto_sync_enabled: Boolean
    cluster_group: [String!]
    cluster_group_id: [String!]
    cluster_id: [String!]
    cluster_type: [String!]
    cluster_type_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    data_file_id: [String!]
    data_source_id: [String!]
    data_synced: DatetimeFilterLookup
    description: StrFilterLookup
    device_role: [String!]
    device_role_id: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    is_active: Boolean
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    platform: [String!]
    platform_id: [String!]
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    tag_id: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    weight: IntFilterLookup
}

"ConfigTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, name, description, template_code, environment_params)"
input ConfigTemplateFilter {
    AND: ConfigTemplateFilter
    DISTINCT: Boolean
    NOT: ConfigTemplateFilter
    OR: ConfigTemplateFilter
    auto_sync_enabled: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    data_file_id: [String!]
    data_source_id: [String!]
    data_synced: DatetimeFilterLookup
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
}

"A physical console port within a Device. ConsolePorts connect to ConsoleServerPorts."
input ConsolePortFilter {
    AND: ConsolePortFilter
    DISTINCT: Boolean
    NOT: ConsolePortFilter
    OR: ConsolePortFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    speed: IntFilterLookup
    tag: [String!]
    type: String
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a ConsolePort to be created for a new Device."
input ConsolePortTemplateFilter {
    AND: ConsolePortTemplateFilter
    DISTINCT: Boolean
    NOT: ConsolePortTemplateFilter
    OR: ConsolePortTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    q: String
    type: StrFilterLookup
    updated_by_request: String
}

"A physical port within a Device (typically a designated console server) which provides access to ConsolePorts."
input ConsoleServerPortFilter {
    AND: ConsoleServerPortFilter
    DISTINCT: Boolean
    NOT: ConsoleServerPortFilter
    OR: ConsoleServerPortFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    speed: IntFilterLookup
    tag: [String!]
    type: String
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a ConsoleServerPort to be created for a new Device."
input ConsoleServerPortTemplateFilter {
    AND: ConsoleServerPortTemplateFilter
    DISTINCT: Boolean
    NOT: ConsoleServerPortTemplateFilter
    OR: ConsoleServerPortTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    q: String
    type: StrFilterLookup
    updated_by_request: String
}

"ContactAssignment(id, created, last_updated, custom_field_data, object_type, object_id, contact, role, priority)"
input ContactAssignmentFilter {
    AND: ContactAssignmentFilter
    DISTINCT: Boolean
    NOT: ContactAssignmentFilter
    OR: ContactAssignmentFilter
    contact_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    object_id: IntFilterLookup
    object_type: String
    object_type_id: IDFilterLookup
    priority: StrFilterLookup
    q: String
    role: [String!]
    role_id: [String!]
    tag: [String!]
    updated_by_request: String
}

"Contact information for a particular object(s) in NetBox."
input ContactFilter {
    AND: ContactFilter
    DISTINCT: Boolean
    NOT: ContactFilter
    OR: ContactFilter
    address: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    email: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    link: StrFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    phone: StrFilterLookup
    q: String
    tag: [String!]
    title: StrFilterLookup
    updated_by_request: String
}

"An arbitrary collection of Contacts."
input ContactGroupFilter {
    AND: ContactGroupFilter
    DISTINCT: Boolean
    NOT: ContactGroupFilter
    OR: ContactGroupFilter
    ancestor: [String!]
    ancestor_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"Functional role for a Contact assigned to an object."
input ContactRoleFilter {
    AND: ContactRoleFilter
    DISTINCT: Boolean
    NOT: ContactRoleFilter
    OR: ContactRoleFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"Represents a set of choices available for choice and multi-choice custom fields."
input CustomFieldChoiceSetFilter {
    AND: CustomFieldChoiceSetFilter
    DISTINCT: Boolean
    NOT: CustomFieldChoiceSetFilter
    OR: CustomFieldChoiceSetFilter
    base_choices: StrFilterLookup
    choice: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    order_alphabetically: Boolean
    q: String
    updated_by_request: String
}

"CustomField(id, created, last_updated, type, related_object_type, name, label, group_name, description, required, unique, search_weight, filter_logic, default, related_object_filter, weight, validation_minimum, validation_maximum, validation_regex, choice_set, ui_visible, ui_editable, is_cloneable, comments)"
input CustomFieldFilter {
    AND: CustomFieldFilter
    DISTINCT: Boolean
    NOT: CustomFieldFilter
    OR: CustomFieldFilter
    choice_set: [String!]
    choice_set_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    filter_logic: StrFilterLookup
    group_name: StrFilterLookup
    id: IDFilterLookup
    is_cloneable: Boolean
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_type: String
    object_type_id: [String!]
    q: String
    related_object_type: String
    related_object_type_id: [String!]
    required: Boolean
    search_weight: IntFilterLookup
    type: String
    ui_editable: StrFilterLookup
    ui_visible: StrFilterLookup
    unique: Boolean
    updated_by_request: String
    validation_maximum: IntFilterLookup
    validation_minimum: IntFilterLookup
    validation_regex: StrFilterLookup
    weight: IntFilterLookup
}

"""

A custom link to an external representation of a NetBox object. The link text and URL fields accept Jinja2 template
code to be rendered with an object as context.
"""
input CustomLinkFilter {
    AND: CustomLinkFilter
    DISTINCT: Boolean
    NOT: CustomLinkFilter
    OR: CustomLinkFilter
    button_class: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    enabled: Boolean
    group_name: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    link_text: StrFilterLookup
    link_url: StrFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    new_window: Boolean
    object_type: String
    object_type_id: [String!]
    q: String
    updated_by_request: String
    weight: IntFilterLookup
}

"""

The database representation of a remote file fetched from a remote DataSource. DataFile instances should be created,
updated, or deleted only by calling DataSource.sync().
"""
input DataFileFilter {
    AND: DataFileFilter
    DISTINCT: Boolean
    NOT: DataFileFilter
    OR: DataFileFilter
    created: DatetimeFilterLookup
    created_by_request: String
    hash: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    path: StrFilterLookup
    q: String
    size: IntFilterLookup
    source: [String!]
    source_id: [String!]
    updated_by_request: String
}

"A remote source, such as a git repository, from which DataFiles are synchronized."
input DataSourceFilter {
    AND: DataSourceFilter
    DISTINCT: Boolean
    NOT: DataSourceFilter
    OR: DataSourceFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    enabled: Boolean
    id: IDFilterLookup
    last_synced: DatetimeFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    source_url: StrFilterLookup
    status: String
    tag: [String!]
    type: String
    updated_by_request: String
}

input DateFilterLookup {
    contains: Date
    ends_with: Date
    exact: Date
    gt: Date
    gte: Date
    i_contains: Date
    i_ends_with: Date
    i_exact: Date
    i_regex: String
    i_starts_with: Date
    in_list: [Date!]
    is_null: Boolean
    lt: Date
    lte: Date
    range: [Date!]
    regex: String
    starts_with: Date
}

input DatetimeFilterLookup {
    contains: DateTime
    ends_with: DateTime
    exact: DateTime
    gt: DateTime
    gte: DateTime
    i_contains: DateTime
    i_ends_with: DateTime
    i_exact: DateTime
    i_regex: String
    i_starts_with: DateTime
    in_list: [DateTime!]
    is_null: Boolean
    lt: DateTime
    lte: DateTime
    range: [DateTime!]
    regex: String
    starts_with: DateTime
}

input DecimalFilterLookup {
    contains: Decimal
    ends_with: Decimal
    exact: Decimal
    gt: Decimal
    gte: Decimal
    i_contains: Decimal
    i_ends_with: Decimal
    i_exact: Decimal
    i_regex: String
    i_starts_with: Decimal
    in_list: [Decimal!]
    is_null: Boolean
    lt: Decimal
    lte: Decimal
    range: [Decimal!]
    regex: String
    starts_with: Decimal
}

"An empty space within a Device which can house a child device"
input DeviceBayFilter {
    AND: DeviceBayFilter
    DISTINCT: Boolean
    NOT: DeviceBayFilter
    OR: DeviceBayFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    installed_device: [String!]
    installed_device_id: [String!]
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a DeviceBay to be created for a new parent Device."
input DeviceBayTemplateFilter {
    AND: DeviceBayTemplateFilter
    DISTINCT: Boolean
    NOT: DeviceBayTemplateFilter
    OR: DeviceBayTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    updated_by_request: String
}

"""

A Device represents a piece of physical hardware mounted within a Rack. Each Device is assigned a DeviceType,
DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.

Each Device must be assigned to a site, and optionally to a rack within that site. Associating a device with a
particular rack face or unit is optional (for example, vertically mounted PDUs do not consume rack units).

When a new Device is created, console/power/interface/device bay components are created along with it as dictated
by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the
creation of a Device.
"""
input DeviceFilter {
    AND: DeviceFilter
    DISTINCT: Boolean
    NOT: DeviceFilter
    OR: DeviceFilter
    airflow: StrFilterLookup
    asset_tag: StrFilterLookup
    cluster_group: [String!]
    cluster_group_id: [String!]
    cluster_id: [String!]
    config_template_id: [String!]
    console_port_count: Union
    console_ports: Boolean
    console_server_port_count: Union
    console_server_ports: Boolean
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_bay_count: Union
    device_bays: Boolean
    device_type: [String!]
    device_type_id: [String!]
    face: StrFilterLookup
    front_port_count: Union
    has_oob_ip: Boolean
    has_primary_ip: Boolean
    has_virtual_device_context: Boolean
    id: IDFilterLookup
    interface_count: Union
    interfaces: Boolean
    inventory_item_count: Union
    is_full_depth: Boolean
    last_updated: DatetimeFilterLookup
    latitude: DecimalFilterLookup
    local_context_data: Boolean
    location: [String!]
    location_id: [String!]
    longitude: DecimalFilterLookup
    mac_address: [String!]
    manufacturer: [String!]
    manufacturer_id: [String!]
    model: [String!]
    modified_by_request: String
    module_bay_count: Union
    module_bays: Boolean
    name: StrFilterLookup
    oob_ip_id: [String!]
    parent_bay_id: [String!]
    parent_device_id: [String!]
    pass_through_ports: Boolean
    platform: [String!]
    platform_id: [String!]
    position: DecimalFilterLookup
    power_outlet_count: Union
    power_outlets: Boolean
    power_port_count: Union
    power_ports: Boolean
    primary_ip4_id: [String!]
    primary_ip6_id: [String!]
    q: String
    rack_id: [String!]
    rear_port_count: Union
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    serial: StrFilterLookup
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vc_position: IntFilterLookup
    vc_priority: IntFilterLookup
    virtual_chassis_id: [String!]
    virtual_chassis_member: Boolean
}

"""

Devices are organized by functional role; for example, "Core Switch" or "File Server". Each DeviceRole is assigned a
color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to
virtual machines as well.
"""
input DeviceRoleFilter {
    AND: DeviceRoleFilter
    DISTINCT: Boolean
    NOT: DeviceRoleFilter
    OR: DeviceRoleFilter
    color: [String!]
    config_template_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
    vm_role: Boolean
}

"""

A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as
well as high-level functional role(s).

Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and
interface objects. For example, a Juniper EX4300-48T DeviceType would have:

* 1 ConsolePortTemplate
* 2 PowerPortTemplates
* 48 InterfaceTemplates

When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the
DeviceType) are automatically created as well.
"""
input DeviceTypeFilter {
    AND: DeviceTypeFilter
    DISTINCT: Boolean
    NOT: DeviceTypeFilter
    OR: DeviceTypeFilter
    airflow: StrFilterLookup
    console_port_template_count: Union
    console_ports: Boolean
    console_server_port_template_count: Union
    console_server_ports: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    default_platform: [String!]
    default_platform_id: [String!]
    description: StrFilterLookup
    device_bay_template_count: Union
    device_bays: Boolean
    exclude_from_utilization: Boolean
    front_port_template_count: Union
    has_front_image: Boolean
    has_rear_image: Boolean
    id: IDFilterLookup
    interface_template_count: Union
    interfaces: Boolean
    inventory_item_template_count: Union
    inventory_items: Boolean
    is_full_depth: Boolean
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    model: StrFilterLookup
    modified_by_request: String
    module_bay_template_count: Union
    module_bays: Boolean
    part_number: StrFilterLookup
    pass_through_ports: Boolean
    power_outlet_template_count: Union
    power_outlets: Boolean
    power_port_template_count: Union
    power_ports: Boolean
    q: String
    rear_port_template_count: Union
    slug: StrFilterLookup
    subdevice_role: StrFilterLookup
    tag: [String!]
    u_height: DecimalFilterLookup
    updated_by_request: String
    weight: DecimalFilterLookup
    weight_unit: StrFilterLookup
}

input DjangoModelFilterInput {
    id: ID!
}

"""

An EventRule defines an action to be taken automatically in response to a specific set of events, such as when a
specific type of object is created, modified, or deleted. The action to be taken might entail transmitting a
webhook or executing a custom script.
"""
input EventRuleFilter {
    AND: EventRuleFilter
    DISTINCT: Boolean
    NOT: EventRuleFilter
    OR: EventRuleFilter
    action_object_id: [String!]
    action_object_type: String
    action_type: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    enabled: Boolean
    event_type: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_type: String
    object_type_id: [String!]
    q: String
    tag: [String!]
    updated_by_request: String
}

"ExportTemplate(id, created, last_updated, data_source, data_file, data_path, auto_sync_enabled, data_synced, name, description, template_code, mime_type, file_extension, as_attachment)"
input ExportTemplateFilter {
    AND: ExportTemplateFilter
    DISTINCT: Boolean
    NOT: ExportTemplateFilter
    OR: ExportTemplateFilter
    as_attachment: Boolean
    auto_sync_enabled: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    data_file_id: [String!]
    data_source_id: [String!]
    data_synced: DatetimeFilterLookup
    description: StrFilterLookup
    file_extension: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    mime_type: StrFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_type: String
    object_type_id: [String!]
    q: String
    updated_by_request: String
}

"FHRPGroupAssignment(id, created, last_updated, interface_type, interface_id, group, priority)"
input FHRPGroupAssignmentFilter {
    AND: FHRPGroupAssignmentFilter
    DISTINCT: Boolean
    NOT: FHRPGroupAssignmentFilter
    OR: FHRPGroupAssignmentFilter
    created: DatetimeFilterLookup
    created_by_request: String
    device: StrFilterLookup
    device_id: [String!]
    group_id: IDFilterLookup
    id: IDFilterLookup
    interface_id: IntFilterLookup
    interface_type: DjangoModelFilterInput
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    priority: IntFilterLookup
    updated_by_request: String
    virtual_machine: StrFilterLookup
    virtual_machine_id: [String!]
}

"A grouping of next hope resolution protocol (FHRP) peers. (For instance, VRRP or HSRP.)"
input FHRPGroupFilter {
    AND: FHRPGroupFilter
    DISTINCT: Boolean
    NOT: FHRPGroupFilter
    OR: FHRPGroupFilter
    auth_key: StrFilterLookup
    auth_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group_id: IntFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    protocol: String
    q: String
    related_ip: [String!]
    tag: [String!]
    updated_by_request: String
}

"A pass-through port on the front of a Device."
input FrontPortFilter {
    AND: FrontPortFilter
    DISTINCT: Boolean
    NOT: FrontPortFilter
    OR: FrontPortFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    q: String
    rack: [String!]
    rack_id: [String!]
    rear_port_id: [String!]
    rear_port_position: IntFilterLookup
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    type: StrFilterLookup
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"Template for a pass-through port on the front of a new Device."
input FrontPortTemplateFilter {
    AND: FrontPortTemplateFilter
    DISTINCT: Boolean
    NOT: FrontPortTemplateFilter
    OR: FrontPortTemplateFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    q: String
    rear_port_id: [String!]
    rear_port_position: IntFilterLookup
    type: StrFilterLookup
    updated_by_request: String
}

"Group(id, name, description)"
input GroupFilter {
    AND: GroupFilter
    DISTINCT: Boolean
    NOT: GroupFilter
    OR: GroupFilter
    description: StrFilterLookup
    id: IDFilterLookup
    name: StrFilterLookup
    notification_group_id: [String!]
    permission_id: [String!]
    q: String
    user_id: [String!]
}

input IDFilterLookup {
    contains: ID
    ends_with: ID
    exact: ID
    gt: ID
    gte: ID
    i_contains: ID
    i_ends_with: ID
    i_exact: ID
    i_regex: String
    i_starts_with: ID
    in_list: [ID!]
    is_null: Boolean
    lt: ID
    lte: ID
    range: [ID!]
    regex: String
    starts_with: ID
}

"IKEPolicy(id, created, last_updated, custom_field_data, description, comments, name, version, mode, preshared_key)"
input IKEPolicyFilter {
    AND: IKEPolicyFilter
    DISTINCT: Boolean
    NOT: IKEPolicyFilter
    OR: IKEPolicyFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    ike_proposal: [String!]
    ike_proposal_id: [String!]
    last_updated: DatetimeFilterLookup
    mode: String
    modified_by_request: String
    name: StrFilterLookup
    preshared_key: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
    version: String
}

"IKEProposal(id, created, last_updated, custom_field_data, description, comments, name, authentication_method, encryption_algorithm, authentication_algorithm, group, sa_lifetime)"
input IKEProposalFilter {
    AND: IKEProposalFilter
    DISTINCT: Boolean
    NOT: IKEProposalFilter
    OR: IKEProposalFilter
    authentication_algorithm: String
    authentication_method: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    encryption_algorithm: String
    group: String
    id: IDFilterLookup
    ike_policy: [String!]
    ike_policy_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    sa_lifetime: IntFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

An IPAddress represents an individual IPv4 or IPv6 address and its mask. The mask length should match what is
configured in the real world. (Typically, only loopback interfaces are configured with /32 or /128 masks.) Like
Prefixes, IPAddresses can optionally be assigned to a VRF. An IPAddress can optionally be assigned to an Interface.
Interfaces can have zero or more IPAddresses assigned to them.

An IPAddress can also optionally point to a NAT inside IP, designating itself as a NAT outside IP. This is useful,
for example, when mapping public addresses to private addresses. When an Interface has been assigned an IPAddress
which has a NAT outside IP, that Interface's Device can use either the inside or outside IP as its primary IP.
"""
input IPAddressFilter {
    AND: IPAddressFilter
    DISTINCT: Boolean
    NOT: IPAddressFilter
    OR: IPAddressFilter
    address: StrFilterLookup
    assigned: Boolean
    assigned_object_id: IntFilterLookup
    assigned_object_type: DjangoModelFilterInput
    assigned_to_interface: Boolean
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: StrFilterLookup
    device_id: [String!]
    dns_name: StrFilterLookup
    family: Int
    fhrpgroup_id: [String!]
    id: IDFilterLookup
    interface: [String!]
    interface_id: [String!]
    last_updated: DatetimeFilterLookup
    mask_length: [String!]
    mask_length__gte: Int
    mask_length__lte: Int
    modified_by_request: String
    nat_inside_id: [String!]
    parent: StrFilterLookup
    present_in_vrf: String
    present_in_vrf_id: String
    q: String
    role: String
    service_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    virtual_machine: StrFilterLookup
    virtual_machine_id: [String!]
    vminterface: [String!]
    vminterface_id: [String!]
    vrf: [String!]
    vrf_id: [String!]
}

"A range of IP addresses, defined by start and end addresses."
input IPRangeFilter {
    AND: IPRangeFilter
    DISTINCT: Boolean
    NOT: IPRangeFilter
    OR: IPRangeFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    contains: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    end_address: StrFilterLookup
    family: Int
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    mark_utilized: Boolean
    modified_by_request: String
    parent: StrFilterLookup
    q: String
    role: [String!]
    role_id: [String!]
    size: IntFilterLookup
    start_address: StrFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vrf: [String!]
    vrf_id: [String!]
}

"IPSecPolicy(id, created, last_updated, custom_field_data, description, comments, name, pfs_group)"
input IPSecPolicyFilter {
    AND: IPSecPolicyFilter
    DISTINCT: Boolean
    NOT: IPSecPolicyFilter
    OR: IPSecPolicyFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    ipsec_proposal: [String!]
    ipsec_proposal_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    pfs_group: String
    q: String
    tag: [String!]
    updated_by_request: String
}

"IPSecProfile(id, created, last_updated, custom_field_data, description, comments, name, mode, ike_policy, ipsec_policy)"
input IPSecProfileFilter {
    AND: IPSecProfileFilter
    DISTINCT: Boolean
    NOT: IPSecProfileFilter
    OR: IPSecProfileFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    ike_policy: [String!]
    ike_policy_id: [String!]
    ipsec_policy: [String!]
    ipsec_policy_id: [String!]
    last_updated: DatetimeFilterLookup
    mode: String
    modified_by_request: String
    name: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
}

"IPSecProposal(id, created, last_updated, custom_field_data, description, comments, name, encryption_algorithm, authentication_algorithm, sa_lifetime_seconds, sa_lifetime_data)"
input IPSecProposalFilter {
    AND: IPSecProposalFilter
    DISTINCT: Boolean
    NOT: IPSecProposalFilter
    OR: IPSecProposalFilter
    authentication_algorithm: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    encryption_algorithm: String
    id: IDFilterLookup
    ipsec_policy: [String!]
    ipsec_policy_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    sa_lifetime_data: IntFilterLookup
    sa_lifetime_seconds: IntFilterLookup
    tag: [String!]
    updated_by_request: String
}

"An uploaded image which is associated with an object."
input ImageAttachmentFilter {
    AND: ImageAttachmentFilter
    DISTINCT: Boolean
    NOT: ImageAttachmentFilter
    OR: ImageAttachmentFilter
    created: DatetimeFilterLookup
    created_by_request: String
    id: IDFilterLookup
    image_height: IntFilterLookup
    image_width: IntFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_id: IntFilterLookup
    object_type: String
    object_type_id: IDFilterLookup
    q: String
    updated_by_request: String
}

input IntFilterLookup {
    contains: Int
    ends_with: Int
    exact: Int
    gt: Int
    gte: Int
    i_contains: Int
    i_ends_with: Int
    i_exact: Int
    i_regex: String
    i_starts_with: Int
    in_list: [Int!]
    is_null: Boolean
    lt: Int
    lte: Int
    range: [Int!]
    regex: String
    starts_with: Int
}

"A network interface within a Device. A physical Interface can connect to exactly one other Interface."
input InterfaceFilter {
    AND: InterfaceFilter
    DISTINCT: Boolean
    NOT: InterfaceFilter
    OR: InterfaceFilter
    bridge_id: [String!]
    cable_end: StrFilterLookup
    cable_id: IDFilterLookup
    cabled: Boolean
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    duplex: String
    enabled: Boolean
    id: IDFilterLookup
    kind: String
    l2vpn: [String!]
    l2vpn_id: [String!]
    label: StrFilterLookup
    lag_id: [String!]
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mac_address: [String!]
    mark_connected: Boolean
    mgmt_only: Boolean
    mode: StrFilterLookup
    modified_by_request: String
    module_id: [String!]
    mtu: IntFilterLookup
    name: StrFilterLookup
    occupied: Boolean
    parent_id: [String!]
    poe_mode: StrFilterLookup
    poe_type: StrFilterLookup
    primary_mac_address: [String!]
    primary_mac_address_id: [String!]
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    rf_channel: StrFilterLookup
    rf_channel_frequency: DecimalFilterLookup
    rf_channel_width: DecimalFilterLookup
    rf_role: StrFilterLookup
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    speed: [String!]
    tag: [String!]
    tx_power: IntFilterLookup
    type: StrFilterLookup
    updated_by_request: String
    vdc: [String!]
    vdc_id: [String!]
    vdc_identifier: [String!]
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
    virtual_chassis_member: StrFilterLookup
    virtual_chassis_member_id: [String!]
    virtual_circuit_id: [String!]
    virtual_circuit_termination_id: [String!]
    vlan: String
    vlan_id: String
    vlan_translation_policy: [String!]
    vlan_translation_policy_id: [String!]
    vrf: [String!]
    vrf_id: [String!]
    wireless_lan_id: [String!]
    wireless_link_id: [String!]
    wwn: [String!]
}

"A template for a physical data interface on a new Device."
input InterfaceTemplateFilter {
    AND: InterfaceTemplateFilter
    DISTINCT: Boolean
    NOT: InterfaceTemplateFilter
    OR: InterfaceTemplateFilter
    bridge_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    enabled: Boolean
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    mgmt_only: Boolean
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    poe_mode: String
    poe_type: String
    q: String
    rf_role: String
    type: StrFilterLookup
    updated_by_request: String
}

"""

An InventoryItem represents a serialized piece of hardware within a Device, such as a line card or power supply.
InventoryItems are used only for inventory purposes.
"""
input InventoryItemFilter {
    AND: InventoryItemFilter
    DISTINCT: Boolean
    NOT: InventoryItemFilter
    OR: InventoryItemFilter
    asset_tag: StrFilterLookup
    component_id: [String!]
    component_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    discovered: Boolean
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    manufacturer: [String!]
    manufacturer_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    parent_id: [String!]
    part_id: StrFilterLookup
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    serial: StrFilterLookup
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: StrFilterLookup
    tag: [String!]
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"Inventory items may optionally be assigned a functional role."
input InventoryItemRoleFilter {
    AND: InventoryItemRoleFilter
    DISTINCT: Boolean
    NOT: InventoryItemRoleFilter
    OR: InventoryItemRoleFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"A template for an InventoryItem to be created for a new parent Device."
input InventoryItemTemplateFilter {
    AND: InventoryItemTemplateFilter
    DISTINCT: Boolean
    NOT: InventoryItemTemplateFilter
    OR: InventoryItemTemplateFilter
    component_id: [String!]
    component_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    parent_id: [String!]
    part_id: StrFilterLookup
    q: String
    role: [String!]
    role_id: [String!]
    updated_by_request: String
}

"""

A historical remark concerning an object; collectively, these form an object's journal. The journal is used to
preserve historical context around an object, and complements NetBox's built-in change logging. For example, you
might record a new journal entry when a device undergoes maintenance, or when a prefix is expanded.
"""
input JournalEntryFilter {
    AND: JournalEntryFilter
    DISTINCT: Boolean
    NOT: JournalEntryFilter
    OR: JournalEntryFilter
    assigned_object_id: IntFilterLookup
    assigned_object_type: String
    assigned_object_type_id: IDFilterLookup
    created: DatetimeFilterLookup
    created_by: [String!]
    created_by_id: [String!]
    created_by_request: String
    id: IDFilterLookup
    kind: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    q: String
    tag: [String!]
    updated_by_request: String
}

"L2VPN(id, created, last_updated, custom_field_data, description, comments, name, slug, type, identifier, tenant)"
input L2VPNFilter {
    AND: L2VPNFilter
    DISTINCT: Boolean
    NOT: L2VPNFilter
    OR: L2VPNFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    export_target: [String!]
    export_target_id: [String!]
    id: IDFilterLookup
    identifier: IntFilterLookup
    import_target: [String!]
    import_target_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    type: StrFilterLookup
    updated_by_request: String
}

"L2VPNTermination(id, created, last_updated, custom_field_data, l2vpn, assigned_object_type, assigned_object_id)"
input L2VPNTerminationFilter {
    AND: L2VPNTerminationFilter
    DISTINCT: Boolean
    NOT: L2VPNTerminationFilter
    OR: L2VPNTerminationFilter
    assigned_object_id: IntFilterLookup
    assigned_object_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    device: [String!]
    device_id: [String!]
    id: IDFilterLookup
    interface: [String!]
    interface_id: [String!]
    l2vpn: [String!]
    l2vpn_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    q: String
    region: StrFilterLookup
    region_id: [String!]
    site: StrFilterLookup
    site_id: [String!]
    tag: [String!]
    updated_by_request: String
    virtual_machine: [String!]
    virtual_machine_id: [String!]
    vlan: [String!]
    vlan_id: [String!]
    vlan_vid: Int
    vminterface: [String!]
    vminterface_id: [String!]
}

"""

A Location represents a subgroup of Racks and/or Devices within a Site. A Location may represent a building within a
site, or a room within a building, for example.
"""
input LocationFilter {
    AND: LocationFilter
    DISTINCT: Boolean
    NOT: LocationFilter
    OR: LocationFilter
    ancestor: [String!]
    ancestor_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    facility: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    slug: StrFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"MACAddress(id, created, last_updated, custom_field_data, description, comments, mac_address, assigned_object_type, assigned_object_id)"
input MACAddressFilter {
    AND: MACAddressFilter
    DISTINCT: Boolean
    NOT: MACAddressFilter
    OR: MACAddressFilter
    assigned_object_id: IntFilterLookup
    assigned_object_type: DjangoModelFilterInput
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: StrFilterLookup
    device_id: [String!]
    id: IDFilterLookup
    interface: [String!]
    interface_id: [String!]
    last_updated: DatetimeFilterLookup
    mac_address: [String!]
    modified_by_request: String
    q: String
    tag: [String!]
    updated_by_request: String
    virtual_machine: StrFilterLookup
    virtual_machine_id: [String!]
    vminterface: [String!]
    vminterface_id: [String!]
}

"A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell."
input ManufacturerFilter {
    AND: ManufacturerFilter
    DISTINCT: Boolean
    NOT: ManufacturerFilter
    OR: ManufacturerFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"An empty space within a Device which can house a child device"
input ModuleBayFilter {
    AND: ModuleBayFilter
    DISTINCT: Boolean
    NOT: ModuleBayFilter
    OR: ModuleBayFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    installed_module_id: [String!]
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    parent_id: [String!]
    position: StrFilterLookup
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a ModuleBay to be created for a new parent Device."
input ModuleBayTemplateFilter {
    AND: ModuleBayTemplateFilter
    DISTINCT: Boolean
    NOT: ModuleBayTemplateFilter
    OR: ModuleBayTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    position: StrFilterLookup
    q: String
    updated_by_request: String
}

"""

A Module represents a field-installable component within a Device which may itself hold multiple device components
(for example, a line card within a chassis switch). Modules are instantiated from ModuleTypes.
"""
input ModuleFilter {
    AND: ModuleFilter
    DISTINCT: Boolean
    NOT: ModuleFilter
    OR: ModuleFilter
    asset_tag: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    modified_by_request: String
    module_bay_id: [String!]
    module_type: [String!]
    module_type_id: [String!]
    q: String
    serial: StrFilterLookup
    status: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

A ModuleType represents a hardware element that can be installed within a device and which houses additional
components; for example, a line card within a chassis-based switch such as the Cisco Catalyst 6500. Like a
DeviceType, each ModuleType can have console, power, interface, and pass-through port templates assigned to it. It
cannot, however house device bays or module bays.
"""
input ModuleTypeFilter {
    AND: ModuleTypeFilter
    DISTINCT: Boolean
    NOT: ModuleTypeFilter
    OR: ModuleTypeFilter
    airflow: StrFilterLookup
    console_ports: Boolean
    console_server_ports: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    interfaces: Boolean
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    model: StrFilterLookup
    modified_by_request: String
    part_number: StrFilterLookup
    pass_through_ports: Boolean
    power_outlets: Boolean
    power_ports: Boolean
    q: String
    tag: [String!]
    updated_by_request: String
    weight: DecimalFilterLookup
    weight_unit: StrFilterLookup
}

"A collection of users and/or groups to be informed for certain notifications."
input NotificationGroupFilter {
    AND: NotificationGroupFilter
    DISTINCT: Boolean
    NOT: NotificationGroupFilter
    OR: NotificationGroupFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    updated_by_request: String
    user: [String!]
    user_id: [String!]
}

"""

Platform refers to the software or firmware running on a Device. For example, "Cisco IOS-XR" or "Juniper Junos". A
Platform may optionally be associated with a particular Manufacturer.
"""
input PlatformFilter {
    AND: PlatformFilter
    DISTINCT: Boolean
    NOT: PlatformFilter
    OR: PlatformFilter
    available_for_device_type: String
    config_template_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"An electrical circuit delivered from a PowerPanel."
input PowerFeedFilter {
    AND: PowerFeedFilter
    DISTINCT: Boolean
    NOT: PowerFeedFilter
    OR: PowerFeedFilter
    amperage: IntFilterLookup
    available_power: IntFilterLookup
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    mark_connected: Boolean
    max_utilization: IntFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    occupied: Boolean
    phase: StrFilterLookup
    power_panel_id: [String!]
    q: String
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: StrFilterLookup
    supply: StrFilterLookup
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    type: StrFilterLookup
    updated_by_request: String
    voltage: IntFilterLookup
}

"A physical power outlet (output) within a Device which provides power to a PowerPort."
input PowerOutletFilter {
    AND: PowerOutletFilter
    DISTINCT: Boolean
    NOT: PowerOutletFilter
    OR: PowerOutletFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    color: [String!]
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    feed_leg: StrFilterLookup
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    power_port_id: [String!]
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    type: String
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a PowerOutlet to be created for a new Device."
input PowerOutletTemplateFilter {
    AND: PowerOutletTemplateFilter
    DISTINCT: Boolean
    NOT: PowerOutletTemplateFilter
    OR: PowerOutletTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    feed_leg: StrFilterLookup
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    power_port_id: [String!]
    q: String
    type: StrFilterLookup
    updated_by_request: String
}

"A distribution point for electrical power; e.g. a data center RPP."
input PowerPanelFilter {
    AND: PowerPanelFilter
    DISTINCT: Boolean
    NOT: PowerPanelFilter
    OR: PowerPanelFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location_id: [String!]
    modified_by_request: String
    name: StrFilterLookup
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    updated_by_request: String
}

"A physical power supply (intake) port within a Device. PowerPorts connect to PowerOutlets."
input PowerPortFilter {
    AND: PowerPortFilter
    DISTINCT: Boolean
    NOT: PowerPortFilter
    OR: PowerPortFilter
    allocated_draw: IntFilterLookup
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    connected: Boolean
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    maximum_draw: IntFilterLookup
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    type: String
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"A template for a PowerPort to be created for a new Device."
input PowerPortTemplateFilter {
    AND: PowerPortTemplateFilter
    DISTINCT: Boolean
    NOT: PowerPortTemplateFilter
    OR: PowerPortTemplateFilter
    allocated_draw: IntFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    maximum_draw: IntFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    q: String
    type: StrFilterLookup
    updated_by_request: String
}

"""

A Prefix represents an IPv4 or IPv6 network, including mask length. Prefixes can optionally be scoped to certain
areas and/or assigned to VRFs. A Prefix must be assigned a status and may optionally be assigned a used-define Role.
A Prefix can also be assigned to a VLAN where appropriate.
"""
input PrefixFilter {
    AND: PrefixFilter
    DISTINCT: Boolean
    NOT: PrefixFilter
    OR: PrefixFilter
    children: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    contains: String
    created: DatetimeFilterLookup
    created_by_request: String
    depth: [String!]
    description: StrFilterLookup
    family: Int
    id: IDFilterLookup
    is_pool: Boolean
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_utilized: Boolean
    mask_length: [String!]
    mask_length__gte: Int
    mask_length__lte: Int
    modified_by_request: String
    prefix: StrFilterLookup
    present_in_vrf: String
    present_in_vrf_id: String
    q: String
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    scope_id: IntFilterLookup
    scope_type: String
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vlan_group: [String!]
    vlan_group_id: [String!]
    vlan_id: [String!]
    vlan_vid: Int
    vrf: [String!]
    vrf_id: [String!]
    within: String
    within_include: String
}

"This is a discrete account within a provider.  Each Circuit belongs to a Provider Account."
input ProviderAccountFilter {
    AND: ProviderAccountFilter
    DISTINCT: Boolean
    NOT: ProviderAccountFilter
    OR: ProviderAccountFilter
    account: StrFilterLookup
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    provider: [String!]
    provider_id: [String!]
    q: String
    tag: [String!]
    updated_by_request: String
}

"""

Each Circuit belongs to a Provider. This is usually a telecommunications company or similar organization. This model
stores information pertinent to the user's relationship with the Provider.
"""
input ProviderFilter {
    AND: ProviderFilter
    DISTINCT: Boolean
    NOT: ProviderFilter
    OR: ProviderFilter
    asn: [String!]
    asn_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

This represents a provider network which exists outside of NetBox, the details of which are unknown or
unimportant to the user.
"""
input ProviderNetworkFilter {
    AND: ProviderNetworkFilter
    DISTINCT: Boolean
    NOT: ProviderNetworkFilter
    OR: ProviderNetworkFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    provider: [String!]
    provider_id: [String!]
    q: String
    service_id: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

A Regional Internet Registry (RIR) is responsible for the allocation of a large portion of the global IP address
space. This can be an organization like ARIN or RIPE, or a governing standard such as RFC 1918.
"""
input RIRFilter {
    AND: RIRFilter
    DISTINCT: Boolean
    NOT: RIRFilter
    OR: RIRFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    is_private: Boolean
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
input RackFilter {
    AND: RackFilter
    DISTINCT: Boolean
    NOT: RackFilter
    OR: RackFilter
    airflow: StrFilterLookup
    asset_tag: StrFilterLookup
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    desc_units: Boolean
    description: StrFilterLookup
    facility_id: StrFilterLookup
    form_factor: String
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    manufacturer: [String!]
    manufacturer_id: [String!]
    max_weight: IntFilterLookup
    modified_by_request: String
    mounting_depth: IntFilterLookup
    name: StrFilterLookup
    outer_depth: IntFilterLookup
    outer_unit: StrFilterLookup
    outer_width: IntFilterLookup
    q: String
    rack_type: [String!]
    rack_type_id: [String!]
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    serial: StrFilterLookup
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    starting_unit: IntFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    u_height: IntFilterLookup
    updated_by_request: String
    weight: DecimalFilterLookup
    weight_unit: StrFilterLookup
    width: String
}

"One or more reserved units within a Rack."
input RackReservationFilter {
    AND: RackReservationFilter
    DISTINCT: Boolean
    NOT: RackReservationFilter
    OR: RackReservationFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    q: String
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    unit: Int
    updated_by_request: String
    user: [String!]
    user_id: [String!]
}

"Racks can be organized by functional role, similar to Devices."
input RackRoleFilter {
    AND: RackRoleFilter
    DISTINCT: Boolean
    NOT: RackRoleFilter
    OR: RackRoleFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

Devices are housed within Racks. Each rack has a defined height measured in rack units, and a front and rear face.
Each Rack is assigned to a Site and (optionally) a Location.
"""
input RackTypeFilter {
    AND: RackTypeFilter
    DISTINCT: Boolean
    NOT: RackTypeFilter
    OR: RackTypeFilter
    created: DatetimeFilterLookup
    created_by_request: String
    desc_units: Boolean
    description: StrFilterLookup
    form_factor: String
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    manufacturer: [String!]
    manufacturer_id: [String!]
    max_weight: IntFilterLookup
    model: StrFilterLookup
    modified_by_request: String
    mounting_depth: IntFilterLookup
    outer_depth: IntFilterLookup
    outer_unit: StrFilterLookup
    outer_width: IntFilterLookup
    q: String
    slug: StrFilterLookup
    starting_unit: IntFilterLookup
    tag: [String!]
    u_height: IntFilterLookup
    updated_by_request: String
    weight: DecimalFilterLookup
    weight_unit: StrFilterLookup
    width: String
}

"A pass-through port on the rear of a Device."
input RearPortFilter {
    AND: RearPortFilter
    DISTINCT: Boolean
    NOT: RearPortFilter
    OR: RearPortFilter
    cable_end: StrFilterLookup
    cable_id: [String!]
    cabled: Boolean
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    device_role: [String!]
    device_role_id: [String!]
    device_status: String
    device_type: [String!]
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    mark_connected: Boolean
    modified_by_request: String
    module_id: [String!]
    name: StrFilterLookup
    occupied: Boolean
    positions: IntFilterLookup
    q: String
    rack: [String!]
    rack_id: [String!]
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    type: StrFilterLookup
    updated_by_request: String
    virtual_chassis: [String!]
    virtual_chassis_id: [String!]
}

"Template for a pass-through port on the rear of a new Device."
input RearPortTemplateFilter {
    AND: RearPortTemplateFilter
    DISTINCT: Boolean
    NOT: RearPortTemplateFilter
    OR: RearPortTemplateFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device_type_id: [String!]
    id: IDFilterLookup
    label: StrFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    module_type_id: [String!]
    name: StrFilterLookup
    positions: IntFilterLookup
    q: String
    type: StrFilterLookup
    updated_by_request: String
}

"""

A region represents a geographic collection of sites. For example, you might create regions representing countries,
states, and/or cities. Regions are recursively nested into a hierarchy: all sites belonging to a child region are
also considered to be members of its parent and ancestor region(s).
"""
input RegionFilter {
    AND: RegionFilter
    DISTINCT: Boolean
    NOT: RegionFilter
    OR: RegionFilter
    ancestor: [String!]
    ancestor_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"""

A Role represents the functional role of a Prefix or VLAN; for example, "Customer," "Infrastructure," or
"Management."
"""
input RoleFilter {
    AND: RoleFilter
    DISTINCT: Boolean
    NOT: RoleFilter
    OR: RoleFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
    weight: IntFilterLookup
}

"A BGP extended community used to control the redistribution of routes among VRFs, as defined in RFC 4364."
input RouteTargetFilter {
    AND: RouteTargetFilter
    DISTINCT: Boolean
    NOT: RouteTargetFilter
    OR: RouteTargetFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    exporting_l2vpn: [String!]
    exporting_l2vpn_id: [String!]
    exporting_vrf: [String!]
    exporting_vrf_id: [String!]
    id: IDFilterLookup
    importing_l2vpn: [String!]
    importing_l2vpn_id: [String!]
    importing_vrf: [String!]
    importing_vrf_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"A set of predefined keyword parameters that can be reused to filter for specific objects."
input SavedFilterFilter {
    AND: SavedFilterFilter
    DISTINCT: Boolean
    NOT: SavedFilterFilter
    OR: SavedFilterFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    enabled: Boolean
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_type: String
    object_type_id: [String!]
    q: String
    shared: Boolean
    slug: StrFilterLookup
    updated_by_request: String
    usable: Boolean
    user: [String!]
    user_id: [String!]
    weight: IntFilterLookup
}

"""

A Service represents a layer-four service (e.g. HTTP or SSH) running on a Device or VirtualMachine. A Service may
optionally be tied to one or more specific IPAddresses belonging to its parent.
"""
input ServiceFilter {
    AND: ServiceFilter
    DISTINCT: Boolean
    NOT: ServiceFilter
    OR: ServiceFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    id: IDFilterLookup
    ip_address: [String!]
    ip_address_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    port: Int
    protocol: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
    virtual_machine: [String!]
    virtual_machine_id: [String!]
}

"A template for a Service to be applied to a device or virtual machine."
input ServiceTemplateFilter {
    AND: ServiceTemplateFilter
    DISTINCT: Boolean
    NOT: ServiceTemplateFilter
    OR: ServiceTemplateFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    port: Int
    protocol: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
}

"""

A Site represents a geographic location within a network; typically a building or campus. The optional facility
field can be used to include an external designation, such as a data center name (e.g. Equinix SV6).
"""
input SiteFilter {
    AND: SiteFilter
    DISTINCT: Boolean
    NOT: SiteFilter
    OR: SiteFilter
    asn: [String!]
    asn_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    facility: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    latitude: DecimalFilterLookup
    longitude: DecimalFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    region: [String!]
    region_id: [String!]
    slug: StrFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    time_zone: StrFilterLookup
    updated_by_request: String
}

"""

A site group is an arbitrary grouping of sites. For example, you might have corporate sites and customer sites; and
within corporate sites you might distinguish between offices and data centers. Like regions, site groups can be
nested recursively to form a hierarchy.
"""
input SiteGroupFilter {
    AND: SiteGroupFilter
    DISTINCT: Boolean
    NOT: SiteGroupFilter
    OR: SiteGroupFilter
    ancestor: [String!]
    ancestor_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

input StrFilterLookup {
    contains: String
    ends_with: String
    exact: String
    gt: String
    gte: String
    i_contains: String
    i_ends_with: String
    i_exact: String
    i_regex: String
    i_starts_with: String
    in_list: [String!]
    is_null: Boolean
    lt: String
    lte: String
    range: [String!]
    regex: String
    starts_with: String
}

"Tag(name, slug, created, last_updated, id, color, description)"
input TagFilter {
    AND: TagFilter
    DISTINCT: Boolean
    NOT: TagFilter
    OR: TagFilter
    color: [String!]
    content_type: StrFilterLookup
    content_type_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    for_object_type_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    object_types: DjangoModelFilterInput
    q: String
    slug: StrFilterLookup
    updated_by_request: String
}

"""

A Tenant represents an organization served by the NetBox owner. This is typically a customer or an internal
department.
"""
input TenantFilter {
    AND: TenantFilter
    DISTINCT: Boolean
    NOT: TenantFilter
    OR: TenantFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"An arbitrary collection of Tenants."
input TenantGroupFilter {
    AND: TenantGroupFilter
    DISTINCT: Boolean
    NOT: TenantGroupFilter
    OR: TenantGroupFilter
    ancestor: [String!]
    ancestor_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"Tunnel(id, created, last_updated, custom_field_data, description, comments, name, status, group, encapsulation, ipsec_profile, tenant, tunnel_id)"
input TunnelFilter {
    AND: TunnelFilter
    DISTINCT: Boolean
    NOT: TunnelFilter
    OR: TunnelFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    encapsulation: String
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    ipsec_profile: [String!]
    ipsec_profile_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    tunnel_id: IntFilterLookup
    updated_by_request: String
}

"""

An administrative grouping of Tunnels. This can be used to correlate peer-to-peer tunnels which form a mesh,
for example.
"""
input TunnelGroupFilter {
    AND: TunnelGroupFilter
    DISTINCT: Boolean
    NOT: TunnelGroupFilter
    OR: TunnelGroupFilter
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"TunnelTermination(id, created, last_updated, custom_field_data, tunnel, role, termination_type, termination_id, outside_ip)"
input TunnelTerminationFilter {
    AND: TunnelTerminationFilter
    DISTINCT: Boolean
    NOT: TunnelTerminationFilter
    OR: TunnelTerminationFilter
    created: DatetimeFilterLookup
    created_by_request: String
    id: IDFilterLookup
    interface: [String!]
    interface_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    outside_ip_id: [String!]
    q: String
    role: String
    tag: [String!]
    termination_id: IntFilterLookup
    termination_type: String
    tunnel: [String!]
    tunnel_id: [String!]
    updated_by_request: String
    vminterface: [String!]
    vminterface_id: [String!]
}

"User(id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined)"
input UserFilter {
    AND: UserFilter
    DISTINCT: Boolean
    NOT: UserFilter
    OR: UserFilter
    date_joined: DatetimeFilterLookup
    email: StrFilterLookup
    first_name: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    is_active: Boolean
    is_staff: Boolean
    is_superuser: Boolean
    last_login: DatetimeFilterLookup
    last_name: StrFilterLookup
    notification_group_id: [String!]
    permission_id: [String!]
    q: String
    username: StrFilterLookup
}

"""

A VLAN is a distinct layer two forwarding domain identified by a 12-bit integer (1-4094). Each VLAN must be assigned
to a Site, however VLAN IDs need not be unique within a Site. A VLAN may optionally be assigned to a VLANGroup,
within which all VLAN IDs and names but be unique.

Like Prefixes, each VLAN is assigned an operational status and optionally a user-defined Role. A VLAN can have zero
or more Prefixes assigned to it.
"""
input VLANFilter {
    AND: VLANFilter
    DISTINCT: Boolean
    NOT: VLANFilter
    OR: VLANFilter
    available_at_site: String
    available_on_device: String
    available_on_virtualmachine: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    interface_id: String
    l2vpn: [String!]
    l2vpn_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    qinq_role: String
    qinq_svlan_id: [String!]
    qinq_svlan_vid: [String!]
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vid: IntFilterLookup
    vminterface_id: String
}

"""

A VLAN group is an arbitrary collection of VLANs within which VLAN IDs and names must be unique. Each group must
define one or more ranges of valid VLAN IDs, and may be assigned a specific scope.
"""
input VLANGroupFilter {
    AND: VLANGroupFilter
    DISTINCT: Boolean
    NOT: VLANGroupFilter
    OR: VLANGroupFilter
    cluster: Int
    cluster_group: Int
    contains_vid: Int
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    location: Int
    modified_by_request: String
    name: StrFilterLookup
    q: String
    rack: Int
    region: Int
    scope_id: IntFilterLookup
    scope_type: String
    site: Int
    site_group: Int
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"VLANTranslationPolicy(id, created, last_updated, custom_field_data, description, comments, name)"
input VLANTranslationPolicyFilter {
    AND: VLANTranslationPolicyFilter
    DISTINCT: Boolean
    NOT: VLANTranslationPolicyFilter
    OR: VLANTranslationPolicyFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    tag: [String!]
    updated_by_request: String
}

"VLANTranslationRule(id, created, last_updated, custom_field_data, policy, description, local_vid, remote_vid)"
input VLANTranslationRuleFilter {
    AND: VLANTranslationRuleFilter
    DISTINCT: Boolean
    NOT: VLANTranslationRuleFilter
    OR: VLANTranslationRuleFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    local_vid: IntFilterLookup
    modified_by_request: String
    policy: DjangoModelFilterInput
    policy_id: IDFilterLookup
    q: String
    remote_vid: IntFilterLookup
    tag: [String!]
    updated_by_request: String
}

"VMInterface(id, created, last_updated, custom_field_data, enabled, mtu, mode, parent, bridge, untagged_vlan, qinq_svlan, vlan_translation_policy, primary_mac_address, description, name, _name, virtual_machine, vrf)"
input VMInterfaceFilter {
    AND: VMInterfaceFilter
    DISTINCT: Boolean
    NOT: VMInterfaceFilter
    OR: VMInterfaceFilter
    bridge_id: [String!]
    cluster: [String!]
    cluster_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    enabled: Boolean
    id: IDFilterLookup
    l2vpn: [String!]
    l2vpn_id: [String!]
    last_updated: DatetimeFilterLookup
    mac_address: [String!]
    mode: StrFilterLookup
    modified_by_request: String
    mtu: IntFilterLookup
    name: StrFilterLookup
    parent_id: [String!]
    primary_mac_address: [String!]
    primary_mac_address_id: [String!]
    q: String
    tag: [String!]
    updated_by_request: String
    virtual_machine: [String!]
    virtual_machine_id: [String!]
    vlan: String
    vlan_id: String
    vlan_translation_policy: [String!]
    vlan_translation_policy_id: [String!]
    vrf: [String!]
    vrf_id: [String!]
}

"""

A virtual routing and forwarding (VRF) table represents a discrete layer three forwarding domain (e.g. a routing
table). Prefixes and IPAddresses can optionally be assigned to VRFs. (Prefixes and IPAddresses not assigned to a VRF
are said to exist in the "global" table.)
"""
input VRFFilter {
    AND: VRFFilter
    DISTINCT: Boolean
    NOT: VRFFilter
    OR: VRFFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    enforce_unique: Boolean
    export_target: [String!]
    export_target_id: [String!]
    id: IDFilterLookup
    import_target: [String!]
    import_target_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    rd: StrFilterLookup
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"A collection of Devices which operate with a shared control plane (e.g. a switch stack)."
input VirtualChassisFilter {
    AND: VirtualChassisFilter
    DISTINCT: Boolean
    NOT: VirtualChassisFilter
    OR: VirtualChassisFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    domain: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    master: [String!]
    master_id: [String!]
    member_count: Union
    modified_by_request: String
    name: StrFilterLookup
    q: String
    region: [String!]
    region_id: [String!]
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    tag: [String!]
    tenant: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"A virtual connection between two or more endpoints, delivered across one or more physical circuits."
input VirtualCircuitFilter {
    AND: VirtualCircuitFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitFilter
    OR: VirtualCircuitFilter
    cid: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    provider: [String!]
    provider_account: [String!]
    provider_account_id: [String!]
    provider_id: [String!]
    provider_network_id: [String!]
    q: String
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    type: [String!]
    type_id: [String!]
    updated_by_request: String
}

"VirtualCircuitTermination(id, created, last_updated, custom_field_data, virtual_circuit, role, interface, description)"
input VirtualCircuitTerminationFilter {
    AND: VirtualCircuitTerminationFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitTerminationFilter
    OR: VirtualCircuitTerminationFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    interface_id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    provider: [String!]
    provider_account: [String!]
    provider_account_id: [String!]
    provider_id: [String!]
    provider_network_id: [String!]
    q: String
    role: String
    tag: [String!]
    updated_by_request: String
    virtual_circuit_id: [String!]
}

"""

Like physical circuits, virtual circuits can be organized by their functional role. For example, a user might wish
to categorize virtual circuits by their technological nature or by product name.
"""
input VirtualCircuitTypeFilter {
    AND: VirtualCircuitTypeFilter
    DISTINCT: Boolean
    NOT: VirtualCircuitTypeFilter
    OR: VirtualCircuitTypeFilter
    color: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"VirtualDeviceContext(id, created, last_updated, custom_field_data, description, device, name, status, identifier, primary_ip4, primary_ip6, tenant, comments)"
input VirtualDeviceContextFilter {
    AND: VirtualDeviceContextFilter
    DISTINCT: Boolean
    NOT: VirtualDeviceContextFilter
    OR: VirtualDeviceContextFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: DjangoModelFilterInput
    device_id: [String!]
    has_primary_ip: Boolean
    id: IDFilterLookup
    identifier: IntFilterLookup
    interface_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    primary_ip4_id: [String!]
    primary_ip6_id: [String!]
    q: String
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}

"VirtualDisk(id, created, last_updated, custom_field_data, virtual_machine, name, description, size)"
input VirtualDiskFilter {
    AND: VirtualDiskFilter
    DISTINCT: Boolean
    NOT: VirtualDiskFilter
    OR: VirtualDiskFilter
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    q: String
    size: IntFilterLookup
    tag: [String!]
    updated_by_request: String
    virtual_machine: [String!]
    virtual_machine_id: [String!]
}

"A virtual machine which runs inside a Cluster."
input VirtualMachineFilter {
    AND: VirtualMachineFilter
    DISTINCT: Boolean
    NOT: VirtualMachineFilter
    OR: VirtualMachineFilter
    cluster: DjangoModelFilterInput
    cluster_group: [String!]
    cluster_group_id: [String!]
    cluster_id: [String!]
    cluster_type: [String!]
    cluster_type_id: [String!]
    config_template_id: [String!]
    contact: [String!]
    contact_group: [String!]
    contact_role: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    device: [String!]
    device_id: [String!]
    disk: IntFilterLookup
    has_primary_ip: Boolean
    id: IDFilterLookup
    interface_count: Union
    last_updated: DatetimeFilterLookup
    local_context_data: Boolean
    mac_address: [String!]
    memory: IntFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    platform: [String!]
    platform_id: [String!]
    primary_ip4_id: [String!]
    primary_ip6_id: [String!]
    q: String
    region: [String!]
    region_id: [String!]
    role: [String!]
    role_id: [String!]
    serial: StrFilterLookup
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vcpus: DecimalFilterLookup
    virtual_disk_count: Union
}

"""

A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or
delete in NetBox. The request will contain a representation of the object, which the remote application can act on.
Each Webhook can be limited to firing only on certain actions or certain object types.
"""
input WebhookFilter {
    AND: WebhookFilter
    DISTINCT: Boolean
    NOT: WebhookFilter
    OR: WebhookFilter
    ca_file_path: StrFilterLookup
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    http_content_type: StrFilterLookup
    http_method: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    payload_url: StrFilterLookup
    q: String
    secret: StrFilterLookup
    ssl_verification: Boolean
    tag: [String!]
    updated_by_request: String
}

"A wireless network formed among an arbitrary number of access point and clients."
input WirelessLANFilter {
    AND: WirelessLANFilter
    DISTINCT: Boolean
    NOT: WirelessLANFilter
    OR: WirelessLANFilter
    auth_cipher: String
    auth_psk: StrFilterLookup
    auth_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    group: [String!]
    group_id: [String!]
    id: IDFilterLookup
    interface_id: [String!]
    last_updated: DatetimeFilterLookup
    location: [String!]
    location_id: [String!]
    modified_by_request: String
    q: String
    region: [String!]
    region_id: [String!]
    scope_id: IntFilterLookup
    scope_type: String
    site: [String!]
    site_group: [String!]
    site_group_id: [String!]
    site_id: [String!]
    ssid: StrFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
    vlan_id: [String!]
}

"A nested grouping of WirelessLANs"
input WirelessLANGroupFilter {
    AND: WirelessLANGroupFilter
    DISTINCT: Boolean
    NOT: WirelessLANGroupFilter
    OR: WirelessLANGroupFilter
    ancestor: [String!]
    ancestor_id: [String!]
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    id: IDFilterLookup
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    name: StrFilterLookup
    parent: [String!]
    parent_id: [String!]
    q: String
    slug: StrFilterLookup
    tag: [String!]
    updated_by_request: String
}

"A point-to-point connection between two wireless Interfaces."
input WirelessLinkFilter {
    AND: WirelessLinkFilter
    DISTINCT: Boolean
    NOT: WirelessLinkFilter
    OR: WirelessLinkFilter
    auth_cipher: String
    auth_psk: StrFilterLookup
    auth_type: String
    created: DatetimeFilterLookup
    created_by_request: String
    description: StrFilterLookup
    distance: DecimalFilterLookup
    distance_unit: StrFilterLookup
    id: IDFilterLookup
    interface_a_id: [String!]
    interface_b_id: [String!]
    last_updated: DatetimeFilterLookup
    modified_by_request: String
    q: String
    ssid: StrFilterLookup
    status: String
    tag: [String!]
    tenant: [String!]
    tenant_group: [String!]
    tenant_group_id: [String!]
    tenant_id: [String!]
    updated_by_request: String
}
